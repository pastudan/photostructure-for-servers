{
  "version": 3,
  "sources": ["../../../node_modules/source-map/lib/base64.js", "../../../node_modules/source-map/lib/base64-vlq.js", "../../../node_modules/source-map/lib/util.js", "../../../node_modules/source-map/lib/array-set.js", "../../../node_modules/source-map/lib/mapping-list.js", "../../../node_modules/source-map/lib/source-map-generator.js", "../../../node_modules/source-map/lib/binary-search.js", "../../../node_modules/source-map/lib/quick-sort.js", "../../../node_modules/source-map/lib/source-map-consumer.js", "../../../node_modules/source-map/lib/source-node.js", "../../../node_modules/source-map/source-map.js", "../../../node_modules/buffer-from/index.js", "../../../node_modules/source-map-support/source-map-support.js", "../../../list.ts", "../../../../fe/Iterable.ts", "../../../../fe/toS.ts", "../../../../fe/Primitive.ts", "../../../../fe/ObjectType.ts", "../../../../fe/Thunk.ts", "../../../../fe/Maybe.ts", "../../../../fe/Blank.ts", "../../../../fe/JSON.ts", "../../../../fe/Eql.ts", "../../../../fe/List.ts", "../../../../fe/Map.ts", "../../../../fe/Opt.ts", "../../../../fe/Number.ts", "../../../../fe/Random.ts", "../../../../fe/String.ts", "../../../../fe/toA.ts", "../../../../fe/Array.ts", "../../../../fe/Lazy.ts", "../../../../fe/Date.ts", "../../../../fe/StrEnum.ts", "../../../../core/Chalk.ts", "../../../../core/Env.ts", "../../../../fe/Object.ts", "../../../../fe/Boolean.ts", "../../../../core/ServiceNames.ts", "../../../../core/NodeEnv.ts", "../../../../core/AppName.ts", "../../../../core/settings/Settings.ts", "../../../../fe/ImageSizes.ts", "../../../../fe/Units.ts", "../../../../core/fs/Path.ts", "../../../../core/Array.ts", "../../../../core/Eql.ts", "../../../../fe/Delay.ts", "../../../../fe/Promise.ts", "../../../../core/String.ts", "../../../../core/Object.ts", "../../../../fe/Latch.ts", "../../../../core/math/Average.ts", "../../../../core/BoundedList.ts", "../../../../core/CountingSet.ts", "../../../../core/Number.ts", "../../../../core/Set.ts", "../../../../core/math/Vector.ts", "../../../../core/work/MaxCpus.ts", "../../../../core/event/EventEmitter.ts", "../../../../core/event/TestEventEmitter.ts", "../../../../core/async/Deferred.ts", "../../../../fe/Error.ts", "../../../../fe/PromiseState.ts", "../../../../core/error/ErrorTypes.ts", "../../../../core/async/Timers.ts", "../../../../core/async/Promises.ts", "../../../../fe/AsPromise.ts", "../../../../core/async/thenOrTimeout.ts", "../../../../core/async/Promise.ts", "../../../../core/Platform.ts", "../../../../core/volumes/VolumeTtls.ts", "../../../../core/fs/StatTimeout.ts", "../../../../core/fs/Streams.ts", "../../../../core/HomeDir.ts", "../../../../core/DefaultCacheDir.ts", "../../../../core/LogDir.ts", "../../../../core/AppData.ts", "../../../../core/Version.ts", "../../../../core/PhotoStructureVersion.ts", "../../../../core/PicturesDir.ts", "../../../../core/pwsh/PowerShell.ts", "../../../../core/async/until.ts", "../../../../core/BatchClusterObserver.ts", "../../../../core/async/EndableWrapper.ts", "../../../../core/child/ChildProcess.ts", "../../../../fe/AsyncRetry.ts", "../../../../core/math/Rate.ts", "../../../../core/TTLArray.ts", "../../../../core/error/ErrorCodes.ts", "../../../../core/error/Error.ts", "../../../../core/Pids.ts", "../../../../core/FifoCache.ts", "../../../../core/fs/BaseFile.ts", "../../../../core/async/Predicate.ts", "../../../../core/Elapsed.ts", "../../../../core/async/PromiseTimer.ts", "../../../../core/math/Radix.ts", "../../../../core/math/b64.ts", "../../../../core/CussWords.ts", "../../../../core/Leet.ts", "../../../../core/MultiMap.ts", "../../../../core/Cuss.ts", "../../../../core/StringSimilarity.ts", "../../../../core/fs/CRLF.ts", "../../../../core/fs/DirectoryEntry.ts", "../../../../core/fs/Readdir.ts", "../../../../core/fs/Hash.ts", "../../../../core/fs/zcat.ts", "../../../../core/error/WrappedError.ts", "../../../../core/fs/WritableToBuffer.ts", "../../../../core/fs/FileCache.ts", "../../../../core/fs/LineReader.ts", "../../../../core/fs/ProgressObservers.ts", "../../../../core/event/ProgressEvt.ts", "../../../../fe/Throttle.ts", "../../../../core/fs/ProjectPath.ts", "../../../../core/fs/Ancestors.ts", "../../../../core/fs/StreamChunker.ts", "../../../../core/Map.ts", "../../../../core/Ps.ts", "../../../../core/RegExp.ts", "../../../../core/Fixed.ts", "../../../../core/fs/PathTo.ts", "../../../../core/WinDate.ts", "../../../../core/UserData.ts", "../../../../core/PriorityClass.ts", "../../../../core/TTLSet.ts", "../../../../core/Renice.ts", "../../../../core/child/ChildEnv.ts", "../../../../core/Locale.ts", "../../../../fe/OptAsync.ts", "../../../../core/async/Later.ts", "../../../../core/log/LogMeta.ts", "../../../../core/log/LogLevel.ts", "../../../../core/log/RecentLogs.ts", "../../../../core/log/Logger.ts", "../../../../core/tags/DefaultLensMakes.ts", "../../../../core/tags/SidecarExts.ts", "../../../../core/settings/Setting.ts", "../../../../core/StringCase.ts", "../../../../core/log/LogFilter.ts", "../../../../core/SortedArray.ts", "../../../../core/log/DefaultLogFormatter.ts", "../../../../core/log/ColoredLogFormatter.ts", "../../../../core/log/LogCommon.ts", "../../../../core/log/PlaintextLogFormatter.ts", "../../../../core/log/LogEntry.ts", "../../../../core/log/LogTailEntries.ts", "../../../../core/log/ConsoleLogger.ts", "../../../../core/log/LogWriter.ts", "../../../../core/Logger.ts", "../../../../core/async/Endable.ts", "../../../../core/cli/CLI.ts", "../../../../core/cli/CliConstants.ts", "../../../../core/fs/PosixFile.ts", "../../../../core/tags/FileExts.ts", "../../../../fe/URI.ts", "../../../../core/net/nslookup.ts", "../../../../core/async/MemoizedAsyncFunc.ts", "../../../../core/net/ping.ts", "../../../../core/volumes/Mount.ts", "../../../../core/volumes/DfPosixRaw.ts", "../../../../core/volumes/Gio.ts", "../../../../core/date/Date.ts", "../../../../core/child/WatchedChild.ts", "../../../../core/Debounce.ts", "../../../../core/volumes/MountpointsPosix.ts", "../../../../core/volumes/MountpointsWin.ts", "../../../../core/volumes/Mountpoints.ts", "../../../../core/volumes/LazyFsAsync.ts", "../../../../core/volumes/DfPosix.ts", "../../../../core/volumes/RemoteVolumesWin.ts", "../../../../core/volumes/DfWin.ts", "../../../../core/volumes/LocalVolumesMac.ts", "../../../../core/EnvTokens.ts", "../../../../core/volumes/LocalVolumesPosix.ts", "../../../../core/volumes/RemoteVolumesPosix.ts", "../../../../core/async/TryWithErrorHandling.ts", "../../../../core/math/UUID.ts", "../../../../core/volumes/VolumeUUID.ts", "../../../../core/volumes/Volumes.ts", "../../../../core/uri/psfile.ts", "../../../../core/MemoizedFunc.ts", "../../../../core/uri/URI.ts", "../../../../core/CharCode.ts", "../../../../core/uri/pslib.ts", "../../../../core/uri/psnet.ts", "../../../../core/uri/UriNormalization.ts", "../../../../core/uri/FileURI.ts", "../../../../core/fs/Hidden.ts", "../../../../core/LoggedThunks.ts", "../../../../core/SetSet.ts", "../../../../core/fs/NeverIgnoredPaths.ts", "../../../../core/fs/NoMedia.ts", "../../../../core/fs/SeemsRecursive.ts", "../../../../core/async/AsyncFilter.ts", "../../../../core/fs/Snap.ts", "../../../../core/fs/Ignorable.ts", "../../../../core/settings/LibraryDirs.ts", "../../../../core/settings/SettingsIO.ts", "../../../../core/cli/IsDaemon.ts", "../../../../core/cli/LogArgs.ts", "../../../cli/CommonArgs.ts", "../../../db/DbPath.ts"],
  "sourcesContent": ["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   \u201Csources\u201D entry.  This value is prepended to the individual\n    //   entries in the \u201Csource\u201D field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   \u201CsourceRoot\u201D, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  if (sourceRoot) {\n    sourceRoot = util.normalize(sourceRoot);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this._absoluteSources = this._sources.toArray().map(function (s) {\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n  });\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this._sourceMapURL = aSourceMapURL;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n  var relativeSource = aSource;\n  if (this.sourceRoot != null) {\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\n  }\n\n  if (this._sources.has(relativeSource)) {\n    return this._sources.indexOf(relativeSource);\n  }\n\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\n  // this case we can't simply undo the transform.\n  var i;\n  for (i = 0; i < this._absoluteSources.length; ++i) {\n    if (this._absoluteSources[i] == aSource) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._absoluteSources.slice();\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = null;\n        if (mapping.name) {\n          name = section.consumer._names.at(mapping.name);\n          this._names.add(name);\n          name = this._names.indexOf(name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex] || '';\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n", "/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n", "var toString = Object.prototype.toString\n\nvar isModern = (\n  typeof Buffer.alloc === 'function' &&\n  typeof Buffer.allocUnsafe === 'function' &&\n  typeof Buffer.from === 'function'\n)\n\nfunction isArrayBuffer (input) {\n  return toString.call(input).slice(8, -1) === 'ArrayBuffer'\n}\n\nfunction fromArrayBuffer (obj, byteOffset, length) {\n  byteOffset >>>= 0\n\n  var maxLength = obj.byteLength - byteOffset\n\n  if (maxLength < 0) {\n    throw new RangeError(\"'offset' is out of bounds\")\n  }\n\n  if (length === undefined) {\n    length = maxLength\n  } else {\n    length >>>= 0\n\n    if (length > maxLength) {\n      throw new RangeError(\"'length' is out of bounds\")\n    }\n  }\n\n  return isModern\n    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))\n    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  return isModern\n    ? Buffer.from(string, encoding)\n    : new Buffer(string, encoding)\n}\n\nfunction bufferFrom (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (isArrayBuffer(value)) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return isModern\n    ? Buffer.from(value)\n    : new Buffer(value)\n}\n\nmodule.exports = bufferFrom\n", "var SourceMapConsumer = require('source-map').SourceMapConsumer;\nvar path = require('path');\n\nvar fs;\ntry {\n  fs = require('fs');\n  if (!fs.existsSync || !fs.readFileSync) {\n    // fs doesn't have all methods we need\n    fs = null;\n  }\n} catch (err) {\n  /* nop */\n}\n\nvar bufferFrom = require('buffer-from');\n\n/**\n * Requires a module which is protected against bundler minification.\n *\n * @param {NodeModule} mod\n * @param {string} request\n */\nfunction dynamicRequire(mod, request) {\n  return mod.require(request);\n}\n\n// Only install once if called multiple times\nvar errorFormatterInstalled = false;\nvar uncaughtShimInstalled = false;\n\n// If true, the caches are reset before a stack trace formatting operation\nvar emptyCacheBetweenOperations = false;\n\n// Supports {browser, node, auto}\nvar environment = \"auto\";\n\n// Maps a file path to a string containing the file contents\nvar fileContentsCache = {};\n\n// Maps a file path to a source map for that file\nvar sourceMapCache = {};\n\n// Regex for detecting source maps\nvar reSourceMap = /^data:application\\/json[^,]+base64,/;\n\n// Priority list of retrieve handlers\nvar retrieveFileHandlers = [];\nvar retrieveMapHandlers = [];\n\nfunction isInBrowser() {\n  if (environment === \"browser\")\n    return true;\n  if (environment === \"node\")\n    return false;\n  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === \"renderer\"));\n}\n\nfunction hasGlobalProcessEventEmitter() {\n  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));\n}\n\nfunction handlerExec(list) {\n  return function(arg) {\n    for (var i = 0; i < list.length; i++) {\n      var ret = list[i](arg);\n      if (ret) {\n        return ret;\n      }\n    }\n    return null;\n  };\n}\n\nvar retrieveFile = handlerExec(retrieveFileHandlers);\n\nretrieveFileHandlers.push(function(path) {\n  // Trim the path to make sure there is no extra whitespace.\n  path = path.trim();\n  if (/^file:/.test(path)) {\n    // existsSync/readFileSync can't handle file protocol, but once stripped, it works\n    path = path.replace(/file:\\/\\/\\/(\\w:)?/, function(protocol, drive) {\n      return drive ?\n        '' : // file:///C:/dir/file -> C:/dir/file\n        '/'; // file:///root-dir/file -> /root-dir/file\n    });\n  }\n  if (path in fileContentsCache) {\n    return fileContentsCache[path];\n  }\n\n  var contents = '';\n  try {\n    if (!fs) {\n      // Use SJAX if we are in the browser\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', path, /** async */ false);\n      xhr.send(null);\n      if (xhr.readyState === 4 && xhr.status === 200) {\n        contents = xhr.responseText;\n      }\n    } else if (fs.existsSync(path)) {\n      // Otherwise, use the filesystem\n      contents = fs.readFileSync(path, 'utf8');\n    }\n  } catch (er) {\n    /* ignore any errors */\n  }\n\n  return fileContentsCache[path] = contents;\n});\n\n// Support URLs relative to a directory, but be careful about a protocol prefix\n// in case we are in the browser (i.e. directories may start with \"http://\" or \"file:///\")\nfunction supportRelativeURL(file, url) {\n  if (!file) return url;\n  var dir = path.dirname(file);\n  var match = /^\\w+:\\/\\/[^\\/]*/.exec(dir);\n  var protocol = match ? match[0] : '';\n  var startPath = dir.slice(protocol.length);\n  if (protocol && /^\\/\\w\\:/.test(startPath)) {\n    // handle file:///C:/ paths\n    protocol += '/';\n    return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\\\/g, '/');\n  }\n  return protocol + path.resolve(dir.slice(protocol.length), url);\n}\n\nfunction retrieveSourceMapURL(source) {\n  var fileData;\n\n  if (isInBrowser()) {\n     try {\n       var xhr = new XMLHttpRequest();\n       xhr.open('GET', source, false);\n       xhr.send(null);\n       fileData = xhr.readyState === 4 ? xhr.responseText : null;\n\n       // Support providing a sourceMappingURL via the SourceMap header\n       var sourceMapHeader = xhr.getResponseHeader(\"SourceMap\") ||\n                             xhr.getResponseHeader(\"X-SourceMap\");\n       if (sourceMapHeader) {\n         return sourceMapHeader;\n       }\n     } catch (e) {\n     }\n  }\n\n  // Get the URL of the source map\n  fileData = retrieveFile(source);\n  var re = /(?:\\/\\/[@#][\\s]*sourceMappingURL=([^\\s'\"]+)[\\s]*$)|(?:\\/\\*[@#][\\s]*sourceMappingURL=([^\\s*'\"]+)[\\s]*(?:\\*\\/)[\\s]*$)/mg;\n  // Keep executing the search to find the *last* sourceMappingURL to avoid\n  // picking up sourceMappingURLs from comments, strings, etc.\n  var lastMatch, match;\n  while (match = re.exec(fileData)) lastMatch = match;\n  if (!lastMatch) return null;\n  return lastMatch[1];\n};\n\n// Can be overridden by the retrieveSourceMap option to install. Takes a\n// generated source filename; returns a {map, optional url} object, or null if\n// there is no source map.  The map field may be either a string or the parsed\n// JSON object (ie, it must be a valid argument to the SourceMapConsumer\n// constructor).\nvar retrieveSourceMap = handlerExec(retrieveMapHandlers);\nretrieveMapHandlers.push(function(source) {\n  var sourceMappingURL = retrieveSourceMapURL(source);\n  if (!sourceMappingURL) return null;\n\n  // Read the contents of the source map\n  var sourceMapData;\n  if (reSourceMap.test(sourceMappingURL)) {\n    // Support source map URL as a data url\n    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);\n    sourceMapData = bufferFrom(rawData, \"base64\").toString();\n    sourceMappingURL = source;\n  } else {\n    // Support source map URLs relative to the source URL\n    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);\n    sourceMapData = retrieveFile(sourceMappingURL);\n  }\n\n  if (!sourceMapData) {\n    return null;\n  }\n\n  return {\n    url: sourceMappingURL,\n    map: sourceMapData\n  };\n});\n\nfunction mapSourcePosition(position) {\n  var sourceMap = sourceMapCache[position.source];\n  if (!sourceMap) {\n    // Call the (overrideable) retrieveSourceMap function to get the source map.\n    var urlAndMap = retrieveSourceMap(position.source);\n    if (urlAndMap) {\n      sourceMap = sourceMapCache[position.source] = {\n        url: urlAndMap.url,\n        map: new SourceMapConsumer(urlAndMap.map)\n      };\n\n      // Load all sources stored inline with the source map into the file cache\n      // to pretend like they are already loaded. They may not exist on disk.\n      if (sourceMap.map.sourcesContent) {\n        sourceMap.map.sources.forEach(function(source, i) {\n          var contents = sourceMap.map.sourcesContent[i];\n          if (contents) {\n            var url = supportRelativeURL(sourceMap.url, source);\n            fileContentsCache[url] = contents;\n          }\n        });\n      }\n    } else {\n      sourceMap = sourceMapCache[position.source] = {\n        url: null,\n        map: null\n      };\n    }\n  }\n\n  // Resolve the source URL relative to the URL of the source map\n  if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === 'function') {\n    var originalPosition = sourceMap.map.originalPositionFor(position);\n\n    // Only return the original position if a matching line was found. If no\n    // matching line is found then we return position instead, which will cause\n    // the stack trace to print the path and line for the compiled file. It is\n    // better to give a precise location in the compiled file than a vague\n    // location in the original file.\n    if (originalPosition.source !== null) {\n      originalPosition.source = supportRelativeURL(\n        sourceMap.url, originalPosition.source);\n      return originalPosition;\n    }\n  }\n\n  return position;\n}\n\n// Parses code generated by FormatEvalOrigin(), a function inside V8:\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js\nfunction mapEvalOrigin(origin) {\n  // Most eval() calls are in this format\n  var match = /^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(origin);\n  if (match) {\n    var position = mapSourcePosition({\n      source: match[2],\n      line: +match[3],\n      column: match[4] - 1\n    });\n    return 'eval at ' + match[1] + ' (' + position.source + ':' +\n      position.line + ':' + (position.column + 1) + ')';\n  }\n\n  // Parse nested eval() calls using recursion\n  match = /^eval at ([^(]+) \\((.+)\\)$/.exec(origin);\n  if (match) {\n    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';\n  }\n\n  // Make sure we still return useful information if we didn't find anything\n  return origin;\n}\n\n// This is copied almost verbatim from the V8 source code at\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The\n// implementation of wrapCallSite() used to just forward to the actual source\n// code of CallSite.prototype.toString but unfortunately a new release of V8\n// did something to the prototype chain and broke the shim. The only fix I\n// could find was copy/paste.\nfunction CallSiteToString() {\n  var fileName;\n  var fileLocation = \"\";\n  if (this.isNative()) {\n    fileLocation = \"native\";\n  } else {\n    fileName = this.getScriptNameOrSourceURL();\n    if (!fileName && this.isEval()) {\n      fileLocation = this.getEvalOrigin();\n      fileLocation += \", \";  // Expecting source position to follow.\n    }\n\n    if (fileName) {\n      fileLocation += fileName;\n    } else {\n      // Source code does not originate from a file and is not native, but we\n      // can still get the source position inside the source string, e.g. in\n      // an eval string.\n      fileLocation += \"<anonymous>\";\n    }\n    var lineNumber = this.getLineNumber();\n    if (lineNumber != null) {\n      fileLocation += \":\" + lineNumber;\n      var columnNumber = this.getColumnNumber();\n      if (columnNumber) {\n        fileLocation += \":\" + columnNumber;\n      }\n    }\n  }\n\n  var line = \"\";\n  var functionName = this.getFunctionName();\n  var addSuffix = true;\n  var isConstructor = this.isConstructor();\n  var isMethodCall = !(this.isToplevel() || isConstructor);\n  if (isMethodCall) {\n    var typeName = this.getTypeName();\n    // Fixes shim to be backward compatable with Node v0 to v4\n    if (typeName === \"[object Object]\") {\n      typeName = \"null\";\n    }\n    var methodName = this.getMethodName();\n    if (functionName) {\n      if (typeName && functionName.indexOf(typeName) != 0) {\n        line += typeName + \".\";\n      }\n      line += functionName;\n      if (methodName && functionName.indexOf(\".\" + methodName) != functionName.length - methodName.length - 1) {\n        line += \" [as \" + methodName + \"]\";\n      }\n    } else {\n      line += typeName + \".\" + (methodName || \"<anonymous>\");\n    }\n  } else if (isConstructor) {\n    line += \"new \" + (functionName || \"<anonymous>\");\n  } else if (functionName) {\n    line += functionName;\n  } else {\n    line += fileLocation;\n    addSuffix = false;\n  }\n  if (addSuffix) {\n    line += \" (\" + fileLocation + \")\";\n  }\n  return line;\n}\n\nfunction cloneCallSite(frame) {\n  var object = {};\n  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {\n    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];\n  });\n  object.toString = CallSiteToString;\n  return object;\n}\n\nfunction wrapCallSite(frame, state) {\n  // provides interface backward compatibility\n  if (state === undefined) {\n    state = { nextPosition: null, curPosition: null }\n  }\n  if(frame.isNative()) {\n    state.curPosition = null;\n    return frame;\n  }\n\n  // Most call sites will return the source file from getFileName(), but code\n  // passed to eval() ending in \"//# sourceURL=...\" will return the source file\n  // from getScriptNameOrSourceURL() instead\n  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();\n  if (source) {\n    var line = frame.getLineNumber();\n    var column = frame.getColumnNumber() - 1;\n\n    // Fix position in Node where some (internal) code is prepended.\n    // See https://github.com/evanw/node-source-map-support/issues/36\n    // Header removed in node at ^10.16 || >=11.11.0\n    // v11 is not an LTS candidate, we can just test the one version with it.\n    // Test node versions for: 10.16-19, 10.20+, 12-19, 20-99, 100+, or 11.11\n    var noHeader = /^v(10\\.1[6-9]|10\\.[2-9][0-9]|10\\.[0-9]{3,}|1[2-9]\\d*|[2-9]\\d|\\d{3,}|11\\.11)/;\n    var headerLength = noHeader.test(process.version) ? 0 : 62;\n    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {\n      column -= headerLength;\n    }\n\n    var position = mapSourcePosition({\n      source: source,\n      line: line,\n      column: column\n    });\n    state.curPosition = position;\n    frame = cloneCallSite(frame);\n    var originalFunctionName = frame.getFunctionName;\n    frame.getFunctionName = function() {\n      if (state.nextPosition == null) {\n        return originalFunctionName();\n      }\n      return state.nextPosition.name || originalFunctionName();\n    };\n    frame.getFileName = function() { return position.source; };\n    frame.getLineNumber = function() { return position.line; };\n    frame.getColumnNumber = function() { return position.column + 1; };\n    frame.getScriptNameOrSourceURL = function() { return position.source; };\n    return frame;\n  }\n\n  // Code called using eval() needs special handling\n  var origin = frame.isEval() && frame.getEvalOrigin();\n  if (origin) {\n    origin = mapEvalOrigin(origin);\n    frame = cloneCallSite(frame);\n    frame.getEvalOrigin = function() { return origin; };\n    return frame;\n  }\n\n  // If we get here then we were unable to change the source position\n  return frame;\n}\n\n// This function is part of the V8 stack trace API, for more info see:\n// https://v8.dev/docs/stack-trace-api\nfunction prepareStackTrace(error, stack) {\n  if (emptyCacheBetweenOperations) {\n    fileContentsCache = {};\n    sourceMapCache = {};\n  }\n\n  var name = error.name || 'Error';\n  var message = error.message || '';\n  var errorString = name + \": \" + message;\n\n  var state = { nextPosition: null, curPosition: null };\n  var processedStack = [];\n  for (var i = stack.length - 1; i >= 0; i--) {\n    processedStack.push('\\n    at ' + wrapCallSite(stack[i], state));\n    state.nextPosition = state.curPosition;\n  }\n  state.curPosition = state.nextPosition = null;\n  return errorString + processedStack.reverse().join('');\n}\n\n// Generate position and snippet of original source with pointer\nfunction getErrorSource(error) {\n  var match = /\\n    at [^(]+ \\((.*):(\\d+):(\\d+)\\)/.exec(error.stack);\n  if (match) {\n    var source = match[1];\n    var line = +match[2];\n    var column = +match[3];\n\n    // Support the inline sourceContents inside the source map\n    var contents = fileContentsCache[source];\n\n    // Support files on disk\n    if (!contents && fs && fs.existsSync(source)) {\n      try {\n        contents = fs.readFileSync(source, 'utf8');\n      } catch (er) {\n        contents = '';\n      }\n    }\n\n    // Format the line from the original source code like node does\n    if (contents) {\n      var code = contents.split(/(?:\\r\\n|\\r|\\n)/)[line - 1];\n      if (code) {\n        return source + ':' + line + '\\n' + code + '\\n' +\n          new Array(column).join(' ') + '^';\n      }\n    }\n  }\n  return null;\n}\n\nfunction printErrorAndExit (error) {\n  var source = getErrorSource(error);\n\n  // Ensure error is printed synchronously and not truncated\n  if (process.stderr._handle && process.stderr._handle.setBlocking) {\n    process.stderr._handle.setBlocking(true);\n  }\n\n  if (source) {\n    console.error();\n    console.error(source);\n  }\n\n  console.error(error.stack);\n  process.exit(1);\n}\n\nfunction shimEmitUncaughtException () {\n  var origEmit = process.emit;\n\n  process.emit = function (type) {\n    if (type === 'uncaughtException') {\n      var hasStack = (arguments[1] && arguments[1].stack);\n      var hasListeners = (this.listeners(type).length > 0);\n\n      if (hasStack && !hasListeners) {\n        return printErrorAndExit(arguments[1]);\n      }\n    }\n\n    return origEmit.apply(this, arguments);\n  };\n}\n\nvar originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);\nvar originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);\n\nexports.wrapCallSite = wrapCallSite;\nexports.getErrorSource = getErrorSource;\nexports.mapSourcePosition = mapSourcePosition;\nexports.retrieveSourceMap = retrieveSourceMap;\n\nexports.install = function(options) {\n  options = options || {};\n\n  if (options.environment) {\n    environment = options.environment;\n    if ([\"node\", \"browser\", \"auto\"].indexOf(environment) === -1) {\n      throw new Error(\"environment \" + environment + \" was unknown. Available options are {auto, browser, node}\")\n    }\n  }\n\n  // Allow sources to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveFile) {\n    if (options.overrideRetrieveFile) {\n      retrieveFileHandlers.length = 0;\n    }\n\n    retrieveFileHandlers.unshift(options.retrieveFile);\n  }\n\n  // Allow source maps to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveSourceMap) {\n    if (options.overrideRetrieveSourceMap) {\n      retrieveMapHandlers.length = 0;\n    }\n\n    retrieveMapHandlers.unshift(options.retrieveSourceMap);\n  }\n\n  // Support runtime transpilers that include inline source maps\n  if (options.hookRequire && !isInBrowser()) {\n    // Use dynamicRequire to avoid including in browser bundles\n    var Module = dynamicRequire(module, 'module');\n    var $compile = Module.prototype._compile;\n\n    if (!$compile.__sourceMapSupport) {\n      Module.prototype._compile = function(content, filename) {\n        fileContentsCache[filename] = content;\n        sourceMapCache[filename] = undefined;\n        return $compile.call(this, content, filename);\n      };\n\n      Module.prototype._compile.__sourceMapSupport = true;\n    }\n  }\n\n  // Configure options\n  if (!emptyCacheBetweenOperations) {\n    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?\n      options.emptyCacheBetweenOperations : false;\n  }\n\n  // Install the error reformatter\n  if (!errorFormatterInstalled) {\n    errorFormatterInstalled = true;\n    Error.prepareStackTrace = prepareStackTrace;\n  }\n\n  if (!uncaughtShimInstalled) {\n    var installHandler = 'handleUncaughtExceptions' in options ?\n      options.handleUncaughtExceptions : true;\n\n    // Do not override 'uncaughtException' with our own handler in Node.js\n    // Worker threads. Workers pass the error to the main thread as an event,\n    // rather than printing something to stderr and exiting.\n    try {\n      // We need to use `dynamicRequire` because `require` on it's own will be optimized by WebPack/Browserify.\n      var worker_threads = dynamicRequire(module, 'worker_threads');\n      if (worker_threads.isMainThread === false) {\n        installHandler = false;\n      }\n    } catch(e) {}\n\n    // Provide the option to not install the uncaught exception handler. This is\n    // to support other uncaught exception handlers (in test frameworks, for\n    // example). If this handler is not installed and there are no other uncaught\n    // exception handlers, uncaught exceptions will be caught by node's built-in\n    // exception handler and the process will still be terminated. However, the\n    // generated JavaScript code will be shown above the stack trace instead of\n    // the original source code.\n    if (installHandler && hasGlobalProcessEventEmitter()) {\n      uncaughtShimInstalled = true;\n      shimEmitUncaughtException();\n    }\n  }\n};\n\nexports.resetRetrieveHandlers = function() {\n  retrieveFileHandlers.length = 0;\n  retrieveMapHandlers.length = 0;\n\n  retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);\n  retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);\n\n  retrieveSourceMap = handlerExec(retrieveMapHandlers);\n  retrieveFile = handlerExec(retrieveFileHandlers);\n}\n", "try {\n  require(\"source-map-support\").install()\n} catch {\n  //\n}\nimport bs from \"better-sqlite3\"\nimport { Command } from \"commander\"\nimport { endEndables } from \"../core/async/Endable\"\nimport { CLI } from \"../core/cli/CLI\"\nimport { PosixFile } from \"../core/fs/PosixFile\"\nimport { mkLogger } from \"../core/Logger\"\nimport { Pojo } from \"../core/Object\"\nimport { setServiceName } from \"../core/ServiceNames\"\nimport { libraryDataDir } from \"../core/settings/LibraryDirs\"\nimport { Settings } from \"../core/settings/Settings\"\nimport {\n  readLibrarySettings,\n  readSystemSettings\n} from \"../core/settings/SettingsIO\"\nimport { blank, mapNotBlankOr, notBlankOr } from \"../fe/Blank\"\nimport { isTrue } from \"../fe/Boolean\"\nimport { errorToVerbose } from \"../fe/Error\"\nimport { stringify } from \"../fe/JSON\"\nimport { mapOr } from \"../fe/Maybe\"\nimport { omit } from \"../fe/Object\"\nimport { CommonArgs } from \"./cli/CommonArgs\"\nimport { pathToDb } from \"./db/DbPath\"\n\nasync function run() {\n  try {\n    let emitJson = false\n    let dump = false\n    let sqlArg = \"\"\n    let whereArg = \"\"\n    let orderArg = \"\"\n    let dirname = false\n\n    const cli = new CLI(\"list\").add(CommonArgs)\n    cli.add({\n      beforeParse(cmd: Command): Command {\n        return cmd\n          .option(\n            \"-j --json\",\n            `Emit a JSON object for every asset file with \"hidden\" and \"shown\" flags`\n          )\n          .option(\n            \"--dump\",\n            \"Emit a JSON object that includes all column values\"\n          )\n          .option(\n            \"--sql <Full SQL query>\",\n            \"Run the given SQL query. Note that the SELECT clause must include at least the AssetFile.uri and AssetFile.mountpoint columns.\"\n          )\n          .option(\n            \"--where <WHERE clause>\",\n            \"Apply a SQL WHERE clause to filter the rows returned.\",\n            \"\"\n          )\n          .option(\n            \"--orderby <ORDER BT clause>\",\n            \"Apply a SQL ORDER BY clause to filter the rows returned.\",\n            \"\"\n          )\n          .option(\n            \"--dirname\",\n            \"Only emit asset file directory names (ignored by --json and --dump modes)\"\n          )\n      },\n      afterParse(opts: Pojo) {\n        emitJson = isTrue(opts.json)\n        if (isTrue(opts.dump)) {\n          emitJson = true\n          dump = true\n        }\n        dirname = isTrue(opts.dirname)\n        // NOTE: This allows SQL injection site, by design, but only available to\n        // users that already have access to the direct database, so it should\n        // be fine:\n        sqlArg = opts.sql\n        whereArg = opts.where\n        orderArg = opts.order\n      }\n    })\n\n    await cli.parse()\n\n    setServiceName(\"list\")\n    await readSystemSettings()\n    await readLibrarySettings()\n\n    const libraryPath = Settings.libraryPath.value\n    if (blank(libraryPath)) {\n      throw new Error(\n        \"No library path set. Set the \" +\n          Settings.libraryPath.key +\n          \" environment variable to the path of your PhotoStructure library.\"\n      )\n    }\n\n    const dataDir = libraryDataDir(libraryPath)\n    if (dataDir == null || (await dataDir.notExists())) {\n      throw new Error(\n        \"The library data directory, \" + dataDir + \", does not exist.\"\n      )\n    }\n\n    const dbFile = pathToDb(dataDir, \"models\")\n\n    const db = new bs(dbFile.nativePath, {\n      fileMustExist: true,\n      readonly: false,\n      timeout: Settings.dbTimeoutMs.valueOrDefault\n    })\n\n    const sql = notBlankOr(sqlArg, () => {\n      const select = dump\n        ? \"SELECT Asset.id as assetId, AssetFile.id as assetFileId, AssetFile.*, Asset.*, AssetFile.shown AS shownFile \"\n        : emitJson\n        ? \"SELECT Asset.id as assetId, AssetFile.id as assetFileId, AssetFile.uri, AssetFile.mountpoint, Asset.shown, Asset.hidden, Asset.favorite, AssetFile.shown AS shownFile\"\n        : \"SELECT AssetFile.id as assetFileId, Asset.id as assetId, AssetFile.uri, AssetFile.mountpoint\"\n      const from = \"FROM AssetFile JOIN Asset on Asset.id = AssetFile.assetId\"\n      const where = \"WHERE \" + notBlankOr(whereArg, \"Asset.shown=1\")\n      const orderBy = mapNotBlankOr(orderArg, ea => \"ORDER BY \" + ea, \"\")\n      return `${select} ${from} ${where} ${orderBy}`\n    })\n\n    mkLogger(\"list\").info(\"Running SQL query...\", {\n      sql,\n      db: dbFile.nativePath\n    })\n\n    const result = db.prepare(sql).iterate()\n\n    for (const o of result) {\n      const p = await PosixFile.forUri(o.uri, o.mountpoint)\n      if (emitJson) {\n        console.log(stringify({ path: p?.nativePath, ...omit(o, \"id\") }))\n      } else {\n        console.log(\n          mapOr(\n            p,\n            ea => (dirname ? ea.dir : ea.nativePath),\n            () => o.uri\n          )\n        )\n      }\n    }\n  } catch (err) {\n    console.log(\"Failed: \" + errorToVerbose(err))\n  } finally {\n    await endEndables()\n  }\n}\n\nvoid run()\n", "/**\n * @return true if obj is both Iterable *and not a string* (because srsly wth)\n */\nexport function isIterable(obj: any): obj is Iterable<any> {\n  return (\n    obj != null &&\n    typeof obj !== \"string\" &&\n    typeof obj[Symbol.iterator] === \"function\"\n  )\n}\n\n// export function max<T>(i: Iterable<T>, f: (t: T) => Comparable): Maybe<T> {\n//   let result = undefined\n//   let m = undefined\n//   for (const ea of i) {\n//     const r = f(ea)\n//     if (m == null || m < r) {\n//       m = r\n//       result = ea\n//     }\n//   }\n//   return result\n// }\n", "/**\n * Similar to `String(a)`, but `undefined` and `null` render as \"\", arrays are\n * comma-separated with no square bracket prefix/suffix\n */\nexport function toS(a?: any | any[]): string {\n  // PERF: unrolled\n  return a == null\n    ? \"\"\n    : typeof a === \"string\"\n    ? a\n    : Array.isArray(a)\n    ? a.map(toS).join(\",\")\n    : a.toString()\n}\n", "import { isEmpty } from \"./Array\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { toS } from \"./toS\"\n\nexport type Primitive = number | string | boolean | Date\nconst primitiveTypes = [\"number\", \"string\", \"boolean\"]\n\nexport interface PrimitiveValued {\n  [key: string]: Primitive\n}\n\nexport interface Primitivable {\n  valueOf(): Primitive\n}\n\nexport interface Primitivables {\n  valueOf(): Primitive[]\n}\n\nexport type Comparable = Primitive | (Primitive | Primitive[])[]\n\nexport function isPrimitive(obj: any): obj is Primitive {\n  return primitiveTypes.indexOf(typeof obj) !== -1 || obj instanceof Date\n}\n\nexport function mapPrimitive<T>(a: any, f: (t: Primitive) => T): Maybe<T> {\n  return isPrimitive(a) ? f(a) : undefined\n}\n\nexport function mapPrimitiveOr<T>(\n  a: any,\n  f: (t: Primitive) => T,\n  defaultValue: () => T\n): Maybe<T> {\n  return isPrimitive(a) ? f(a) : defaultValue()\n}\n\nexport function isPrimitiveArray(obj: any): obj is Primitive[] {\n  return Array.isArray(obj) && (obj as any[]).every(isPrimitive)\n}\n\n// export function cmp<T extends Comparable | Comparable[]>(\n//   a: MaybeNull<T>,\n//   b: MaybeNull<T>\n// ): number {\n//   return tap(_cmp(a, b), result => console.log(\"cmp\", { a, b, result }))\n// }\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\nconst TypeLevel = [\n  \"boolean\",\n  \"number\",\n  \"bigint\",\n  \"symbol\",\n  \"string\",\n  \"object\",\n  \"function\"\n] // typeof array is \"object\"\n\n/**\n * (null || undefined) < false < true < numbers < strings < arrays\n * @return 1 if a > b, -1 if a < b, 0 if a == b.\n */\nexport function cmp<T extends Comparable | Comparable[]>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): number {\n  // undefined == undefined:\n  if (a == null && b == null) return 0\n\n  // undefined should be < defined. We can't use typeof here because typeof null\n  // is \"object\" and typeof undefined = \"undefined\".\n  if (a == null) return -1\n  if (b == null) return 1\n\n  const aType = typeof a\n  const bType = typeof b\n\n  if (\n    (aType === \"string\" || aType === \"symbol\") &&\n    (bType === \"string\" || bType === \"symbol\")\n  ) {\n    // in German, \u00E4 sorts before z, in Swedish, \u00E4 sorts after z\n    return toS(a).localeCompare(toS(b))\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return cmpArr(a as any, b as any) // SITS: TS 4.1 required /as any/\n  }\n  if (aType !== bType) {\n    return TypeLevel.indexOf(aType) - TypeLevel.indexOf(bType)\n  } else {\n    return a > b ? 1 : a < b ? -1 : 0\n  }\n}\n\nexport function lt<T extends Comparable>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): boolean {\n  return cmp(a, b) < 0\n}\n\nexport function lte<T extends Comparable>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): boolean {\n  return cmp(a, b) <= 0\n}\n\nexport function gte<T extends Comparable>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): boolean {\n  return cmp(a, b) >= 0\n}\n\nexport function gt<T extends Comparable>(\n  a: MaybeNull<T>,\n  b: MaybeNull<T>\n): boolean {\n  return cmp(a, b) > 0\n}\n\nexport function cmpArr<T extends Primitive>(a: T[], b: T[]): number {\n  if (isEmpty(a) && isEmpty(b)) return 0\n  const len = Math.min(a.length, b.length)\n  for (let i = 0; i < len; i++) {\n    const c = cmp(a[i], b[i])\n    if (c !== 0) {\n      return c\n    }\n  }\n  return cmp(a.length, b.length)\n}\n", "import { isIterable } from \"./Iterable\"\nimport { Defined } from \"./Maybe\"\nimport { isPrimitive } from \"./Primitive\"\n\n// eslint-disable-next-line no-shadow\nexport enum ObjectType {\n  Empty,\n  Primitive,\n  Symbol,\n  Object,\n  Array,\n  Iterable,\n  Instance,\n  Function,\n  Unknown\n}\n\nexport function isSymbol(obj: any): obj is symbol {\n  return typeof obj === \"symbol\"\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(obj: any): obj is Function {\n  return typeof obj === \"function\"\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isObject(obj: any): obj is Defined<any> {\n  return objectType(obj) === ObjectType.Object\n}\n\nexport function objectType(t: any): ObjectType {\n  if (t == null) {\n    return ObjectType.Empty\n  } else if (isSymbol(t)) {\n    return ObjectType.Symbol\n  } else if (isPrimitive(t)) {\n    return ObjectType.Primitive\n  } else if (Array.isArray(t)) {\n    return ObjectType.Array\n  } else if (isIterable(t)) {\n    return ObjectType.Iterable\n  } else if (isFunction(t)) {\n    return ObjectType.Function\n  } else if (typeof t === \"object\") {\n    // we're in fe, we can't use ?. TODO FIXME\n    return t.constructor != null && t.constructor.name === \"Object\"\n      ? ObjectType.Object\n      : ObjectType.Instance\n  } else {\n    return ObjectType.Unknown\n  }\n}\n", "import { Maybe } from \"./MaybeTypes\"\nimport { isFunction } from \"./ObjectType\"\n\nexport interface Thunk<T> {\n  (): T\n}\n\nexport type ThunkOrT<T> = T | Thunk<T>\n\n/**\n * Convert a ThunkOrT into a T.\n *\n * Caution: Don't have T be a function type!\n */\nexport function tot<T>(t: ThunkOrT<T>): T {\n  return isFunction(t) ? t() : t\n}\n\nexport interface ThunkMaybe<T> {\n  (): Maybe<T>\n}\n\nexport function firstDefinedThunk<T>(iter: Iterable<ThunkMaybe<T>>): Maybe<T> {\n  for (const f of iter) {\n    const result = f()\n    if (result != null) return result\n  }\n  return\n}\n\nexport const NoOp = () => undefined\n", "import { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { toS } from \"./toS\"\n\nexport function map<T, U>(obj: MaybeNull<T>, f: (t: T) => U): Maybe<U> {\n  return obj == null ? undefined : f(obj)\n}\n\nexport function mapTry<T, U>(f: () => MaybeNull<T>, g: (t: T) => U): Maybe<U> {\n  try {\n    return map(f(), g)\n  } catch {\n    return\n  }\n}\n\nexport function map2<T1, T2, U>(\n  t1: MaybeNull<T1>,\n  t2: MaybeNull<T2>,\n  f: (ea1: T1, ea2: T2) => U\n): Maybe<U> {\n  return t1 == null || t2 == null ? undefined : f(t1, t2)\n}\n\nexport function map3<T1, T2, T3, U>(\n  t1: MaybeNull<T1>,\n  t2: MaybeNull<T2>,\n  t3: MaybeNull<T3>,\n  f: (ea1: T1, ea2: T2, ea3: T3) => U\n): Maybe<U> {\n  return t1 == null || t2 == null || t3 == null ? undefined : f(t1, t2, t3)\n}\n\nexport function orElse<T>(obj: MaybeNull<T>, defaultValue: ThunkOrT<T>): T {\n  return obj != null ? obj : tot(defaultValue)\n}\n\nexport function mapOr<T, U>(\n  obj: MaybeNull<T>,\n  f: (t: T) => U,\n  defaultValue: ThunkOrT<U>\n): U {\n  return obj != null ? f(obj) : tot(defaultValue)\n}\n\nexport function map2Or<T1, T2, U>(\n  t1: MaybeNull<T1>,\n  t2: MaybeNull<T2>,\n  f: (ea1: T1, ea2: T2) => U,\n  defaultValue: () => U\n): U {\n  return orElse(map2(t1, t2, f), defaultValue)\n}\n\n// https://www.typescriptlang.org/docs/handbook/advanced-types.html#predefined-conditional-types\n\nexport type Diff<T, U> = T extends U ? never : T\n\nexport type Unpick<T, U> = { [P in keyof T]: P extends U ? never : T[P] }\n\nexport type Defined<T> = Diff<T, null | undefined | void>\n\n/**\n * @return true iff all `objects` are not `null` or `undefined`\n */\nexport function defined<T>(object: T): object is Defined<T> {\n  return object != null\n}\n\nexport function allDefined<T>(arr: T[]): arr is Defined<T>[] {\n  return arr != null && arr.every(defined)\n}\n\nexport function firstDefined<T>(...objects: MaybeNull<T>[]): Maybe<T> {\n  return objects.find(defined)\n}\n\nexport function denull<T>(t: T | undefined | null): T | undefined {\n  return t == null || toS(t) === \"null\" ? undefined : t\n}\n\nexport function nulled<T>(t: T | undefined | null): T | null {\n  return t == null ? null : t\n}\n", "import { Defined, orElse } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { toS } from \"./toS\"\n\nexport function blank(o: any): o is undefined {\n  // PERF: unrolled from Opt\n  if (o == null) return true\n  const s = toS(o)\n  return s.length === 0 || s.trim().length === 0\n}\n\nconst BlankishRE = /^\\s*(?:null|undefined)?\\s*$/i\n\nexport function blankish(s: Maybe<string>): s is undefined {\n  return s == null || BlankishRE.exec(s) != null\n}\n\nexport function notBlank<T>(s: T): s is Defined<T> {\n  return !blank(s)\n}\n\n// aka \"trimToUndefined\"\nexport function ifNotBlank(o: any): Maybe<string> {\n  if (o == null) return\n  const s = toS(o)\n  return s.length === 0 || s.trim().length === 0 ? undefined : s\n}\n\n/**\n * Equivalent to `Opt(s).flatMap(toS).filter(notBlank).getOrElse(() => orElse)`\n */\nexport function notBlankOr(s: any, ifBlank: ThunkOrT<string>): string {\n  if (s == null) return tot(ifBlank)\n  const str = toS(s).trim()\n  return str.length > 0 ? str : tot(ifBlank)\n}\n\nexport function notBlankAnd(s: any, f: (ea: string) => boolean): boolean {\n  return !blank(s) ? f(s) : false\n}\n\nexport function mapNotBlank<T>(arg: any, f: (s: string) => T): Maybe<T> {\n  if (arg === false || arg == null || arg === \"\") {\n    return undefined\n  }\n  const s = toS(arg)\n  return notBlank(s) ? f(s!) : undefined\n}\n\nexport function mapNotBlankOr<T>(\n  arg: any,\n  f: (s: string) => T,\n  defaultValue: T | (() => T)\n): T {\n  return orElse(mapNotBlank(arg, f), defaultValue)\n}\n\nexport function firstNotBlank<T>(...arr: MaybeNull<T>[]): Maybe<T> {\n  // PERF: unrolled\n  for (const ea of arr) {\n    if (notBlank(ea)) return ea\n  }\n  return\n}\n", "import { denull } from \"./Maybe\"\nimport { MaybeNull } from \"./MaybeTypes\"\n\n/**\n * Work-alike to JSON.stringify, except that circular dependencies are replaced\n * with a string reference.\n */\nexport function stringify(\n  ea: any,\n  replacer?: (this: any, key: string, value: any) => any,\n  space?: string | number,\n  cycleReplacer?: (this: any, key: string, value: any) => any\n): string {\n  return JSON.stringify(ea, serializer(replacer, cycleReplacer), denull(space))\n}\n\nfunction serializer(\n  replacer?: MaybeNull<(this: any, key: string, value: any) => any>,\n  cycleReplacer?: MaybeNull<(this: any, key: string, value: any) => any>\n): (this: any, key: string, value: any) => any {\n  const stack: any[] = []\n  const keys: any[] = []\n\n  const cr =\n    cycleReplacer != null\n      ? cycleReplacer\n      : (_key: string, value: any) =>\n          stack[0] === value\n            ? \"[Circular ~]\"\n            : \"[Circular ~.\" +\n              keys.slice(0, stack.indexOf(value)).join(\".\") +\n              \"]\"\n\n  /**\n   * The object in which the key was found is provided as the replacer's `this`\n   * parameter.\n   */\n  return function (this: any, key: string, value: any) {\n    if (stack.length > 0) {\n      const thisPos = stack.indexOf(this)\n      if (thisPos >= 0) {\n        stack.splice(thisPos + 1)\n        keys.splice(thisPos, Infinity, key)\n      } else {\n        stack.push(this)\n        keys.push(key)\n      }\n      if (stack.indexOf(value) >= 0) {\n        value = cr.call(this, key, value)\n      }\n    } else {\n      stack.push(value)\n    }\n    const result = replacer == null ? value : replacer.call(this, key, value)\n    return result\n  }\n}\n", "import { stringify } from \"./JSON\"\n\nexport function eql(a: any, b: any): boolean {\n  return stringify(a) === stringify(b)\n}\n", "import { isFunction } from \"./ObjectType\"\n\nexport interface List<T> {\n  length: number\n  [Symbol.iterator](): IterableIterator<T>\n\n  // we can't add get(), because then List<T> doesn't match T[]:\n  // get(index: number): T | undefined\n\n  push(...items: T[]): number\n  pop(): T | undefined\n\n  unshift(...items: T[]): number\n  shift(): T | undefined\n\n  every(callbackfn: (value: T, index: number) => boolean): boolean\n  some(callbackfn: (value: T, index: number) => boolean): boolean\n\n  forEach(callbackfn: (value: T, index: number) => void): void\n  map<U>(callbackfn: (value: T, index: number) => U): U[]\n\n  reduce<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: number) => U,\n    initialValue: U\n  ): U\n\n  reverse(): this\n\n  slice(start?: number | undefined, end?: number | undefined): T[]\n}\n\nexport function isList(l: any): l is List<any> {\n  return (\n    l != null &&\n    (Array.isArray(l) ||\n      (isFinite(l.length) &&\n        isFunction(l[Symbol.iterator]) &&\n        isFunction(l.push) &&\n        isFunction(l.pop) &&\n        isFunction(l.forEach) &&\n        isFunction(l.some))) // TODO: good enough to be listish?\n  )\n}\n", "export function getOrSet<K, V>(\n  m: Map<K, V> | WeakMap<any, V>,\n  k: K,\n  valueThunk: () => V\n): V {\n  if (k == null) throw new Error(\"null key\")\n  if (m.has(k)) {\n    return m.get(k)!\n  } else {\n    const v = valueThunk()\n    if (v != null) m.set(k, v)\n    return v\n  }\n}\n\nexport function deleteIf<K, V>(\n  m: Map<K, V>,\n  predicate: (key: K, value: V) => boolean\n) {\n  for (const [k, v] of m.entries()) {\n    if (predicate(k, v)) {\n      m.delete(k)\n    }\n  }\n}\n", "import { Maybe, MaybeNull } from \"./MaybeTypes\"\n\n// Scala got a Some things right.\n// HUR HUR I AM HILLLARIOUS\n\n// \"Opt\" instead of \"Option\" due to Option being an html entity already\n\nexport type MaybeOpt<T> = Opt<T> | MaybeNull<T>\n\n/**\n * @see http://www.scala-lang.org/api/current/scala/Option.html\n */\nexport interface Opt<A> {\n  /**\n   * @return true if the option is an instance of Some, false otherwise\n   */\n  isDefined: boolean\n  /**\n   * @return true if the option is None, false otherwise\n   */\n  isEmpty: boolean\n  /**\n   * @return the option's value.\n   */\n  get(): Maybe<A>\n  /**\n   * @return true if this option is nonempty and the predicate `p` returns true\n   * when applied to this Option's value.\n   */\n  exists(p: (a: A) => boolean): boolean\n  /**\n   * @return a `Some` containing the result of applying `f` to this `Option`'s value\n   * if this `Option` is nonempty.\n   */\n  map<B>(f: (a: A) => B): Opt<B>\n  /**\n   * @return the result of applying `f` to this `Option`'s value if this\n   * `Option` is nonempty. By supporting `undefined` or `B`, we make caller's\n   * lives a little easier--we'll wrap the result in an `Option` for you.\n   */\n  flatMap<B>(f: (a: A) => MaybeOpt<B>): Opt<B>\n  /**\n   * @return this `Option` if it is both nonempty\n   * and applying the predicate `p` to this `Option`'s value returns true.\n   */\n  filter(p: (a: A) => boolean): Opt<A>\n  /**\n   * Apply the given procedure `f` to the `Option`'s value\n   * if this `Option` is nonempty.\n   * @return this (for fluent or chaining calls)\n   */\n  forEach(f: (a: A) => void): Opt<A>\n  /**\n   * @return this `Option`'s value if this `Option` is nonempty,\n   * otherwise return the result of evaluating `f`.\n   */\n  getOrElse(f: () => A): A\n  /**\n   * @return this `Option`'s value if this `Option` is nonempty,\n   * otherwise return the result of evaluating `f`.\n   */\n  orElse(f: () => MaybeOpt<A>): Opt<A>\n\n  /**\n   * @param f will only be invoked if both `this` and `b` are defined\n   */\n  zip1<B, T>(b: MaybeOpt<B>, f: (a: A, b: B) => MaybeOpt<T>): Opt<T>\n\n  zip2<B, C, T>(\n    b: MaybeOpt<B>,\n    c: MaybeOpt<C>,\n    f: (a: A, b: B, c: C) => MaybeOpt<T>\n  ): Opt<T>\n\n  zip3<B, C, D, T>(\n    b: MaybeOpt<B>,\n    c: MaybeOpt<C>,\n    d: MaybeOpt<D>,\n    f: (a: A, b: B, c: C, d: D) => MaybeOpt<T>\n  ): Opt<T>\n}\n\nnamespace NoneImpl {\n  export const isDefined = false\n  export const isEmpty = true\n  export const get = () => undefined\n  export const exists = () => false\n  const noop = () => NoneImpl\n  export const map = noop\n  export const flatMap = noop\n  export const filter = noop\n  export const forEach = noop\n  export const getOrElse = <A>(f: () => A): A => f()\n  export const orElse = <A>(f: () => MaybeOpt<A>): Opt<A> => opt(f())\n  export const zip1 = noop\n  export const zip2 = noop\n  export const zip3 = noop\n}\n\nexport const None: Opt<any> = NoneImpl\n\nexport class Some<A> implements Opt<A> {\n  readonly isDefined = true\n  readonly isEmpty = false\n\n  constructor(private readonly a: A) {}\n\n  get(): A {\n    return this.a\n  }\n\n  exists(f: (a: A) => boolean): boolean {\n    return f(this.a)\n  }\n\n  map<B>(f: (a: A) => B): Opt<B> {\n    return new Some(f(this.a))\n  }\n\n  flatMap<B>(f: (a: A) => Opt<B> | MaybeNull<B>): Opt<B> {\n    const b = f(this.a)\n    return isOpt(b) ? b : opt(b)\n  }\n\n  filter(f: (a: A) => boolean): Opt<A> {\n    return opt(f(this.a) ? this.a : undefined)\n  }\n\n  forEach(f: (a: A) => void): this {\n    f(this.a)\n    return this\n  }\n\n  getOrElse(): A {\n    return this.a\n  }\n\n  orElse(): Opt<A> {\n    return this\n  }\n\n  zip1<B, T>(b: MaybeOpt<B>, f: (a: A, b: B) => MaybeOpt<T>): Opt<T> {\n    return opt(b).flatMap(eb => f(this.a, eb))\n  }\n\n  zip2<B, C, T>(\n    b: Opt<B>,\n    c: Opt<C>,\n    f: (a: A, b: B, c: C) => MaybeOpt<T>\n  ): Opt<T> {\n    return opt(b).flatMap(eb => opt(c).flatMap(ec => f(this.a, eb, ec)))\n  }\n\n  zip3<B, C, D, T>(\n    b: MaybeOpt<B>,\n    c: MaybeOpt<C>,\n    d: MaybeOpt<D>,\n    f: (a: A, b: B, c: C, d: D) => MaybeOpt<T>\n  ): Opt<T> {\n    return opt(b).flatMap(eb =>\n      opt(c).flatMap(ec => opt(d).flatMap(ed => f(this.a, eb, ec, ed)))\n    )\n  }\n}\n\nexport function isOpt<A>(a: MaybeOpt<A>): a is Opt<A> {\n  return a instanceof Some || a === None\n}\n\n/**\n * @see http://www.scala-lang.org/api/current/scala/Option.html\n */\nexport function opt<A>(a: MaybeOpt<A>): Opt<A> {\n  return isOpt(a) ? a : a != null ? new Some(a) : None\n}\n", "import { blank } from \"./Blank\"\nimport { orElse } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { isFunction } from \"./ObjectType\"\nimport { opt } from \"./Opt\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { toS } from \"./toS\"\n\nexport function isNumber(o: any): o is number {\n  return typeof o === \"number\" && !isNaN(o) && isFinite(o)\n}\n\nexport function mapFinite<T>(i: Maybe<number>, f: (ea: number) => T): Maybe<T> {\n  return isNumber(i) ? f(i) : undefined\n}\n\nconst mapPredicate = (f: (lhs: number, rhs: number) => boolean) => (\n  lhs: MaybeNull<number>,\n  rhs: MaybeNull<number>\n) => isNumber(lhs) && isNumber(rhs) && f(lhs, rhs)\n\nexport const lt = mapPredicate((i, j) => i < j)\nexport const lte = mapPredicate((i, j) => i <= j)\nexport const gt = mapPredicate((i, j) => i > j)\nexport const gte = mapPredicate((i, j) => i >= j)\n\nexport function finiteOrElse<T>(i: Maybe<number>, defaultValue: T): number | T {\n  return isNumber(i) ? i : defaultValue\n}\n\nexport function diff(i: Maybe<number>, j: Maybe<number>): Maybe<number> {\n  return isNumber(i) && isNumber(j) ? i - j : undefined\n}\n\nexport function absdiff(i: Maybe<number>, j: Maybe<number>): Maybe<number> {\n  return isNumber(i) && isNumber(j) ? Math.abs(i - j) : undefined\n}\n\nexport function safeDivide(numerator: number, denominator: number): number {\n  return numerator / (denominator === 0 ? 1e-8 : denominator)\n}\n\nexport function approximates(\n  a: MaybeNull<number>,\n  b: MaybeNull<number>,\n  ratioGte: number\n): boolean {\n  return a == null || b == null\n    ? false\n    : a === b\n    ? true\n    : gte(a < b ? safeDivide(a, b) : safeDivide(b, a), ratioGte)\n}\n\nexport function closeTo(\n  expected: MaybeNull<number>,\n  actual: MaybeNull<number>,\n  delta: number\n): boolean {\n  return expected == null || actual == null\n    ? false\n    : Math.abs(expected - actual) < delta\n}\n\nexport function trunc(n: Maybe<number>): Maybe<number> {\n  if (!isNumber(n)) return undefined\n  const i = Math.trunc(n)\n  return i === 0 ? Math.abs(i) : i\n}\n\nexport interface ToNumber {\n  toNumber(): number\n}\n\nexport function isToNumber(v: any): v is ToNumber {\n  return isFunction(v[\"toNumber\"])\n}\n\nfunction toNumber(\n  value: MaybeNull<number | string | ToNumber>,\n  opts: {\n    defaultValue: Maybe<number>\n    nton: (n: number) => number\n    ston: (s: string) => Maybe<number>\n  }\n) {\n  if (blank(value)) return opts.defaultValue\n  if (isNumber(value)) return opts.nton(value)\n  if (isToNumber(value)) return opts.nton(value.toNumber())\n  try {\n    const i = opts.ston(toS(value))\n    return isNumber(i) ? opts.nton(i) : opts.defaultValue\n  } catch {\n    return opts.defaultValue\n  }\n}\n\nexport function toInt(\n  value: MaybeNull<number | string | ToNumber>,\n  opts?: { defaultValue?: number }\n): Maybe<number> {\n  return toNumber(value, {\n    defaultValue: undefined,\n    nton: i => trunc(i)!,\n    ston: parseInt,\n    ...opts\n  })\n}\n\nexport function toFloat(\n  value: MaybeNull<number | string>,\n  opts?: { defaultValue?: number }\n): Maybe<number> {\n  return toNumber(value, {\n    defaultValue: undefined,\n    nton: i => i,\n    ston: parseFloat,\n    ...opts\n  })\n}\n\nexport function toGt0(n: any): Maybe<number> {\n  const i = toInt(n)\n  return i != null && i > 0 ? i : undefined\n}\n\nexport function lt0(n: any): n is number {\n  return isNumber(n) && n < 0\n}\n\nexport function gt0(n: any): n is number {\n  return isNumber(n) && n > 0\n}\n\nexport function gtOrElse(\n  n: Maybe<number>,\n  mustBeGreaterThan: number\n): Maybe<number> {\n  return isNumber(n) && isNumber(mustBeGreaterThan) && n > mustBeGreaterThan\n    ? n\n    : undefined\n}\n\nexport function lte0(n: any): n is number {\n  return isNumber(n) && n <= 0\n}\n\nexport function gte0(n: any): n is number {\n  return isNumber(n) && n >= 0\n}\n\nexport function mapInt<T>(o: any, f: (i: number) => T): Maybe<T> {\n  return opt(o)\n    .flatMap(i => toInt(i))\n    .flatMap(f)\n    .get()\n}\n\nexport function mapFloat<T>(o: any, f: (i: number) => T): Maybe<T> {\n  return opt(o)\n    .flatMap(i => toFloat(i))\n    .flatMap(f)\n    .get()\n}\n\n/**\n * @return a stringified `value` iff `value` is a positive integer\n */\nexport function id(value: Maybe<number | string>): Maybe<string> {\n  const i = toInt(value)\n  return gt0(i) ? String(i) : undefined\n}\n\nexport function mapIntOr<T>(o: any, f: (i: number) => T, orElseF: () => T): T {\n  return orElse(mapInt(o, f), orElseF)\n}\n\nexport function mapNumeric<T>(o: any, f: (i: number) => T): Maybe<T> {\n  return isNumber(o) ? f(o) : undefined\n}\n\nexport function map2Numeric<T>(\n  i: any,\n  j: any,\n  f: (ea1: number, ea2: number) => T\n): Maybe<T> {\n  return mapNumeric(i, ea1 => mapNumeric(j, ea2 => f(ea1, ea2)))\n}\n\nexport function mapNumericOr<T>(\n  o: any,\n  f: (i: number) => T,\n  defaultValue: T\n): T {\n  return isNumber(o) ? f(o) : defaultValue\n}\n\nexport function numericOr(o: any, defaultValue: ThunkOrT<number>): number {\n  return isNumber(o) ? o : tot(defaultValue)\n}\n\nexport function round(i: number): number {\n  // Workaround for bug in javascript (Math.round(-1.5) === -1 (!!)):\n  return i < 0 ? -Math.round(-i) : Math.round(i)\n}\n\nexport function toPrecisionMaybe(\n  i: Maybe<number>,\n  decimalPlaces: number\n): Maybe<number> {\n  return mapFinite(i, ea => toPrecision(ea, decimalPlaces))\n}\n\nexport function toFixed(i: Maybe<number>, decimals: number): Maybe<number> {\n  try {\n    return mapNumeric(i, ea => round(ea * 10 ** decimals) / 10 ** decimals)\n  } catch (err) {\n    return\n  }\n}\n\nexport function toPrecision(i: number, decimalPlaces: number): number {\n  if (i == null) return 0\n  // pow should be 1 for decimalPlaces = 0\n  const pow = Math.pow(10, decimalPlaces)\n  return round(i * pow) / pow\n}\n\nexport function sigFigs(i: number, digits: number): number {\n  if (i === 0 || digits === 0) {\n    return 0\n  }\n  const exp = digits - round(Math.ceil(Math.log10(Math.abs(i))))\n  const pow = Math.pow(10, Math.abs(exp))\n  // Prevent 120.000000001:\n  return exp < 0 ? round(i / pow) * pow : round(i * pow) / pow\n}\n\nexport function base2Ceil(i: number): number {\n  return Math.pow(2, Math.ceil(Math.log2(i)))\n}\n\nexport function base10Ceil(i: number): number {\n  return Math.pow(10, Math.ceil(Math.log10(i)))\n}\n\nexport function clamp(min: number, max: number, value: number): number {\n  if (min > max || !isNumber(min) || !isNumber(max))\n    throw new Error(`invalid clamp(${min}, ${max}, ${value})`)\n  if (!isNumber(value)) return round((min + max) / 2)\n  return value < min ? min : value > max ? max : value\n}\n\n/**\n * Accumulate the result of `f`, called `count` times. `f` receives a\n * zero-indexed argument.\n */\nexport function times<T>(count: number, f: (i: number) => T): T[] {\n  if (!gt0(count)) return []\n  const c = Math.round(count)\n  if (c <= 0) return []\n  return [...Array(c)].map((_, i) => f(i))\n}\n", "import { isEmpty, isNotEmpty, mapNotEmpty, range, sum } from \"./Array\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { gt0 } from \"./Number\"\n\n/**\n * @return a random integer between min (included) and max (excluded)\n * Using Math.round() will give you a non-uniform distribution!\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random\n */\nexport function randomInt(\n  min: number,\n  max: number,\n  excluded: number[] = []\n): number {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  if (max < min) return min\n  if (isNotEmpty(excluded) && excluded.length + 10 > max - min) {\n    const included = range(min, max).filter(ea => !excluded.includes(ea))\n    return mapNotEmpty(included, arr => arr[randomInt(0, included.length)])!\n  }\n\n  const result = Math.floor(Math.random() * (max - min)) + min\n  return excluded.includes(result) ? randomInt(min, max, excluded) : result\n}\n\nexport function randomInts(min: number, max: number, size: number): number[] {\n  const result: number[] = []\n  while (result.length < size) {\n    result.push(randomInt(min, max, result))\n  }\n  return result\n}\n\n/**\n * @return a random float between `min` and `max`\n */\nexport function randomFloat(min: number, max: number) {\n  return Math.random() * (max - min) + min\n}\n\n// No upper case to support case-insensitive filesystems. Exported for tests.\n// We could have used GeoRadix.numerals, but that's a possible circular dep.\nexport const RandomChars = \"0123456789abcdefghijkmnopqrstuvwxyz\"\n\nexport function randomChars(\n  count: number,\n  chars: string = RandomChars\n): string {\n  let result = \"\"\n  for (let i = 0; i < count; i++) {\n    result += randomChar(chars)\n  }\n  return result\n}\n\nexport function randomChar(chars: string = RandomChars): string {\n  return chars[randomInt(0, chars.length)]\n}\n\nexport function pickRandom<T>(arr: T[]): Maybe<T> {\n  return arr[randomInt(0, arr.length)]\n}\n\n// fisher-yates\nexport function shuffle<T>(arr: T[]): T[] {\n  const r = [...arr]\n  for (let i = r.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1))\n    if (i !== j) [r[i], r[j]] = [r[j], r[i]]\n  }\n  return r\n}\n\nexport function sample<T>(arr: T[], size: number): T[] {\n  if (size < arr.length / 10) {\n    const result = new Set<number>()\n    while (result.size < size) {\n      result.add(randomInt(0, arr.length))\n    }\n    return [...result.keys()].map(ea => arr[ea])\n  } else {\n    return shuffle([...arr]).slice(0, size)\n  }\n}\n\nexport function pickWeightedRandom<T extends { priority?: number }>(\n  arr: T[]\n): Maybe<T> {\n  if (isEmpty(arr)) return\n  const nonZeroes = arr.filter(ea => gt0(ea.priority))\n  const totalPriority = sum(nonZeroes, ea => ea.priority!)\n  let rand = randomFloat(0, totalPriority)\n  return nonZeroes.find(ea => {\n    rand -= ea.priority!\n    return rand <= 0\n  })\n}\n", "import { flatten } from \"./Array\"\nimport { toS } from \"./toS\"\n\nexport function isString(obj: any): obj is string {\n  return typeof obj === \"string\"\n}\n\nexport function ensurePrefix(s: string, prefix: string): string {\n  s = toS(s)\n  prefix = toS(prefix)\n  return s.startsWith(prefix) ? s : prefix + s\n}\n\nexport function ensureSuffix(s: string, suffix: string): string {\n  s = toS(s)\n  suffix = toS(suffix)\n  return s.endsWith(suffix) ? s : s + suffix\n}\n\nexport function ellipsize(a: any, maxLen: number = 80): string {\n  if (a == null) {\n    return \"\"\n  }\n  const s = toS(a)\n  return s.length <= maxLen ? s : s.slice(0, maxLen - 1) + \"\u2026\"\n}\n\nexport const newlineRe = /\\r?\\n/gm\n\n/**\n * Returns the nearest occurrence of a substring to the left of a given position in the string.\n * @param haystack The string to search against.\n * @param needle The substring to search for.\n * @param position The index at which to begin searching. If omitted, the search begins at the end of the string.\n */\nexport function leftIndexOf(\n  haystack: string,\n  needle: string,\n  position?: number\n) {\n  if (position == null) position = haystack.length\n  for (let i = position; i >= 0; i--) {\n    if (haystack.substr(i).startsWith(needle)) return i\n  }\n  return -1\n}\n\nexport function wrap(\n  s: string,\n  opts = { maxLineLen: 75, prefix: \"\" }\n): string[] {\n  if (s.includes(\"\\n\")) {\n    return flatten(s.split(newlineRe).map(ea => wrap(ea, opts)))\n  }\n  s = ensurePrefix(toS(s), opts.prefix).trim()\n  if (s.length <= opts.maxLineLen) {\n    return [s]\n  }\n  const leftSliceAt = leftIndexOf(s, \" \", opts.maxLineLen)\n\n  if (leftSliceAt > opts.prefix.length) {\n    return [s.slice(0, leftSliceAt), ...wrap(s.slice(leftSliceAt + 1), opts)]\n  } else {\n    const rightSliceAt = s.indexOf(\" \", opts.prefix.length + 1)\n    if (rightSliceAt > 0 && rightSliceAt < s.length - 1) {\n      return [\n        s.slice(0, rightSliceAt),\n        ...wrap(s.slice(rightSliceAt + 1), opts)\n      ]\n    } else {\n      return [s]\n    }\n  }\n\n  // }\n\n  // const index = s\n  //   .slice(0, opts.maxLineLen + 1)\n  //   .replace(/[\\s-]/g, \" \")\n  //   .lastIndexOf(\" \")\n  // const sliceAt =\n  //   index <= 1 ? opts.maxLineLen - (opts.prefix.length + 2) : index\n  // return [s.slice(0, sliceAt + 1).trim(), ...wrap(s.slice(sliceAt + 1), opts)]\n}\n\nexport function eqlStrings(a: string, b: string): boolean {\n  return a == null || b == null ? false : a.normalize() === b.normalize()\n}\n\nexport function replaceAll(\n  s: string,\n  searchValue: string | RegExp,\n  replaceValue: string\n): string {\n  if (searchValue === \"\") return s\n  return s.split(searchValue).join(replaceValue)\n}\n\nexport function compressWhitespace(...s: string[]): string {\n  return s.join(\" \").replace(/\\s+/g, \" \").trim()\n}\n", "import { isIterable } from \"./Iterable\"\nimport { MaybeNull } from \"./MaybeTypes\"\n\nexport type Arrayish<T> = ArrayLike<T> | Iterable<T> | T | Set<T>\n\nexport function toA<T>(arr: MaybeNull<Arrayish<T>>): T[] {\n  return arr == null\n    ? []\n    : Array.isArray(arr)\n    ? (arr as T[])\n    : isIterable(arr)\n    ? Array.from(arr)\n    : [arr as T]\n}\n", "import { blankish } from \"./Blank\"\nimport { eql } from \"./Eql\"\nimport { isIterable } from \"./Iterable\"\nimport { stringify } from \"./JSON\"\nimport { isList, List } from \"./List\"\nimport { getOrSet } from \"./Map\"\nimport { Defined, defined, map } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport {\n  cmp,\n  Comparable,\n  isPrimitive,\n  isPrimitiveArray,\n  lt,\n  Primitivable,\n  Primitivables,\n  Primitive\n} from \"./Primitive\"\nimport { randomInt } from \"./Random\"\nimport { isString } from \"./String\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { toA } from \"./toA\"\nimport { toS } from \"./toS\"\n\n// Added isNotEmpty so I can make the arr is not null assertion:\nexport function isNotEmpty<L extends List<any>>(arr: Maybe<L>): arr is L {\n  return isList(arr) && arr.length > 0 && arr.some(ea => ea != null)\n}\n\nexport function notEmptyOr<L extends List<any>>(\n  arr: Maybe<L>,\n  defaultValue: ThunkOrT<L>\n): L {\n  return isNotEmpty(arr) ? arr : tot(defaultValue)\n}\n\nexport function isEmpty(arr: Maybe<List<any>>): arr is undefined {\n  return !isNotEmpty(arr)\n}\n\nexport function mapArray<T, U>(arr: Maybe<T[]>, f: (t: T[]) => U): Maybe<U> {\n  return Array.isArray(arr) ? f(arr) : undefined\n}\n\nexport function mapNotEmpty<L extends List<any>, R>(\n  arr: Maybe<L>,\n  f: (ea: L) => R\n): Maybe<R> {\n  return isNotEmpty(arr) ? f(arr) : undefined\n}\n\nexport function mapNotEmptyOr<L extends List<any>, R>(\n  arr: Maybe<L>,\n  f: (ea: L) => R,\n  defaultValue: ThunkOrT<R>\n): R {\n  return isNotEmpty(arr) ? f(arr) : tot(defaultValue)\n}\n\nfunction asPrim(\n  a: Primitive | Primitive[] | Primitivable | Primitivables\n): Primitive | Primitive[] {\n  return isPrimitive(a) || isPrimitiveArray(a) ? a : a.valueOf()\n}\n\n/**\n * Compacts and flattens ONE LEVEL\n */\nexport function flatten<T>(\n  arr: (MaybeNull<T> | MaybeNull<T>[])[],\n  result: T[] = []\n): T[] {\n  if (arr == null) return result\n  for (const ea of arr) {\n    if (ea != null) {\n      if (Array.isArray(ea)) {\n        // PERF: UNROLL\n        for (const ea1 of ea) {\n          if (ea1 != null) result.push(ea1)\n        }\n      } else {\n        result.push(ea)\n      }\n    }\n  }\n  return result\n}\n\nexport function sort<\n  T extends Primitive | Primitive[] | Primitivable | Primitivables\n>(arr: Maybe<T>[] | ReadonlyArray<Maybe<T>>): Defined<T>[] {\n  return sortByInPlace(compact(arr), asPrim)\n}\n\nexport function copyArrayTo<T>(source: T[], destination: T[]): T[] {\n  for (let i = 0; i < source.length; i++) {\n    destination[i] = source[i]\n  }\n  destination.length = source.length\n  return destination\n}\n\nexport function sortByInPlace<T>(arr: T[], f: (t: T) => Comparable): T[] {\n  return copyArrayTo(sortBy(arr, f), arr)\n}\n\nexport function sortUniqByInPlace<T>(arr: T[], f: (t: T) => Comparable): T[] {\n  const m = new Map<string, T>()\n  for (const ea of arr) {\n    getOrSet(m, stringify(f(ea)), () => ea)\n  }\n  return copyArrayTo(sortBy(m.values(), f), arr)\n}\n\nexport function sorted(arr: Primitivable[]): boolean {\n  return arr.every((ea, idx) => idx === 0 || ea > arr[idx - 1])\n}\n\nexport function sortedBy<T>(arr: T[], f: (t: T) => Primitive): boolean {\n  return arr.every((ea, idx) => idx === 0 || f(ea) > f(arr[idx - 1]))\n}\n\n/**\n * Returns a copy of arr, stable sorted by the given constraint. Note that false\n * < true, and that `f` may return an array for sort priorities, or undefined if\n * the item should be skipped from the returned result.\n *\n * Note: localeSort() thinks lower case should come before upper case (!!)\n */\nexport function sortBy<T, V extends Comparable>(\n  arr: Iterable<T> | T[],\n  f: (t: T, index: number) => Maybe<V>\n): T[] {\n  return toA(arr)\n    .filter(ea => ea != null)\n    .map((item, idx) => ({\n      item,\n      cmp: map(f(item, idx), ea => [ea, idx])\n    }))\n    .filter(ea => ea.cmp != null)\n    .sort((a, b) => cmp(a.cmp!, b.cmp!))\n    .map(ea => ea.item)\n}\n\nexport function deepSortBy<T, V extends Primitive | Primitive[]>(\n  arr: Iterable<T> | T[],\n  f: (t: T) => Maybe<V>\n): T[] {\n  return sortBy(arr, f).map(ea =>\n    isIterable(ea) ? deepSortBy(ea, f) : ea\n  ) as any // SITS typing\n}\n\nexport function arrayEql<T extends Primitive>(a: T[], b: T[]): boolean {\n  return (\n    a != null &&\n    b != null &&\n    a.length === b.length &&\n    a.every((ea, idx) => ea === b[idx])\n  )\n}\n\n/**\n * @return true if `prefix` == `haystack.slice(0, prefix.length)`.\n */\nexport function startsWith<T extends Primitive>(\n  haystack: T[],\n  prefix: T[]\n): boolean {\n  return arrayEql(haystack.slice(0, prefix.length), prefix)\n}\n\n/**\n * Retain all items from `arr` where the `keepIfTrue` returns `true`.\n * @return true if `arr` was changed.\n */\nexport function filterInPlace<T>(\n  arr: T[],\n  keepIfTrue: (item: T, index: number, ea: T[]) => boolean\n): T[] {\n  for (let i = 0; i < arr.length; ) {\n    if (keepIfTrue(arr[i], i, arr)) {\n      i++\n    } else {\n      arr.splice(i, 1)\n    }\n  }\n  return arr\n}\n\nexport function move<T>(arr: T[], fromIndex: number, toIndex: number): T[] {\n  if (\n    fromIndex === toIndex ||\n    fromIndex < 0 ||\n    toIndex < 0 ||\n    fromIndex >= arr.length ||\n    toIndex >= arr.length\n  ) {\n    return arr\n  }\n  const ea = arr[fromIndex]\n  arr.splice(fromIndex, 1)\n  arr.splice(toIndex, 0, ea)\n  return arr\n}\n\n// ES2016 polyfill that also supports Iterable\nexport function includes(\n  haystack: MaybeNull<any[] | Iterable<any>>,\n  needle: any\n): boolean {\n  if (haystack == null) return false\n  for (const ea of haystack) {\n    if (needle.valueOf() === ea.valueOf()) return true\n  }\n  return false\n}\n\nexport function indexOf<T>(\n  iter: Maybe<Iterable<T>>,\n  f: (t: T, index: number) => boolean\n): Maybe<number> {\n  if (iter == null) return\n  let index = 0\n  for (const ea of iter) {\n    if (f(ea, index)) return index\n    index++\n  }\n  return\n}\n\n/**\n * @returns true iff all `needles` are found in `haystack`\n */\nexport function includesAll(\n  haystack?: Primitive[],\n  needles?: Primitive[]\n): boolean {\n  if (haystack == null || needles == null) return false\n  return needles.every(needle => includes(haystack, needle))\n}\n\nexport function eqlUnordered(a: Primitive[], b: Primitive[]): boolean {\n  if (a == null || b == null || a.length !== b.length) return false\n  const a1 = sortBy(a, asPrim)\n  const b1 = sortBy(b, asPrim)\n  return a1.every((ea, idx) => ea === b1[idx])\n}\n\nexport function pushUniq<T>(arr: T[], ...items: T[]): T[] {\n  for (const item of items) {\n    if (!arr.some(ea => eql(ea, item))) {\n      arr.push(item)\n    }\n  }\n  return arr\n}\n\nexport function pushUniqBy<T>(\n  arr: T[],\n  items: T[],\n  valueOf: (t: T) => Comparable\n): T[] {\n  const vArr = arr.map(valueOf)\n  for (const item of items) {\n    const v = valueOf(item)\n    if (!vArr.includes(v)) {\n      arr.push(item)\n      vArr.push(v)\n    }\n  }\n  return arr\n}\n\nexport function insertAt<T>(arr: T[], index: number, ...items: T[]): T[] {\n  arr.splice(index, 0, ...items)\n  return arr\n}\n\n/**\n * Insert `item` into `arr` only if `item` is not in `arr` (according to `cmp`).\n *\n * Assumes `arr` is ascending-sorted.\n */\nexport function insertUniq<T>(\n  arr: T[],\n  item: T,\n  cmp_: (a: T, b: T) => number\n): T[] {\n  // verify the array is already in proper sort-order\n  for (let i = 0; i < arr.length - 1; i++) {\n    if (cmp_(arr[i], arr[i + 1]) > 0) {\n      throw new Error(\"badly sorted array: \" + arr)\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    const ea = arr[i]\n    const c = cmp_(ea, item)\n    if (c === 0) return arr\n    // if item is greater than ea, insert right before ea\n    if (c > 0) {\n      arr.splice(i, 0, item)\n      return arr\n    }\n  }\n  arr.push(item)\n  return arr\n}\n\nexport function compact<T>(iter: MaybeNull<Iterable<T>>): Defined<T>[] {\n  if (iter == null) return []\n  const arr = toA(iter)\n  return arr.every(defined) ? (arr as Defined<T>[]) : arr.filter(defined)\n}\n\nexport function compactBlankish<T>(iter: MaybeNull<Iterable<T>>): Defined<T>[] {\n  const arr = toA(iter).filter(ea => !blankish(toS(ea)))\n  return (isString(arr[0]) ? arr.map(ea => toS(ea).trim()) : arr) as any\n}\n\nexport function compactBlanks(arr: Maybe<any[]>): string[] {\n  // trim() to fix https://gitlab.com/mceachen/photostructure/issues/58\n  return toA(arr)\n    .map(ea => toS(ea).trim())\n    .filter(ea => ea.length > 0)\n}\n\nexport function uniq<T>(arr: Maybe<Maybe<T>[]>): Defined<T>[] {\n  return uniqBy(compact(arr), ea => stringify(ea))\n}\n\n/**\n * First-one-in-wins\n */\nexport function uniqBy<T, V extends Primitive>(\n  arr: Maybe<T>[],\n  f: (t: T) => Maybe<V> = ea => stringify(ea) as V\n): T[] {\n  if (isEmpty(arr)) return []\n  const m = new Map<V, T>()\n  for (const ea of arr) {\n    if (ea != null) {\n      const v = f(ea)\n      if (v != null) {\n        getOrSet(m, v, () => ea)\n      }\n    }\n  }\n  return [...m.values()]\n}\n\n/**\n * First-one-in-wins\n */\nexport function uniqBy2<T>(\n  arr: Maybe<T>[],\n  equals: (a: T, b: T) => boolean\n): T[] {\n  if (isEmpty(arr)) return []\n  const result: T[] = []\n  for (const a of arr) {\n    if (a != null && result.every(b => !equals(a, b))) {\n      result.push(a)\n    }\n  }\n  return result\n}\n\nexport function clear<T>(arr: T[]): T[] {\n  arr.length = 0\n  return arr\n}\n\n/**\n * Equivalent to filtering all items in an array to a new array and calling\n * length. This method avoids creating the intermediate array.\n *\n * @return the number of elements in `arr` that `predicate` returns `true`.\n */\nexport function count<T>(\n  arr: T[],\n  predicate: (t: T, idx: number) => boolean\n): number {\n  return arr.reduce((acc, ea, idx) => acc + (predicate(ea, idx) ? 1 : 0), 0)\n}\n\n/**\n * Equivalent to mapping all items in an array to a new number array and calling\n * Vector.sum(). This method avoids creating the intermediate array.\n *\n * @return the sum of elements of `f`-transmuted numbers from `arr`.\n */\nexport function sum<T>(\n  arr: T[],\n  f: (t: T, currentIndex: number) => number\n): number {\n  return arr.reduce((acc, ea, idx) => acc + f(ea, idx), 0)\n}\n\nexport function firstMatch(\n  re: RegExp,\n  arr: Maybe<string>[]\n): Maybe<RegExpExecArray> {\n  for (const s of compact(arr)) {\n    const m = re.exec(s)\n    if (m != null) return m\n  }\n  return\n}\n\nexport function commonPrefixLength<T extends Primitive>(\n  a: Maybe<T[] | string>,\n  b: Maybe<T[] | string>\n): number {\n  if (a == null || b == null) return 0\n  if (a === b) return a.length\n  if (typeof a === \"string\") a = (a.split(\"\") as any) as T[]\n  if (typeof b === \"string\") b = (b.split(\"\") as any) as T[]\n  if (arrayEql(a, b)) return a.length\n  let length = 0\n  while (a[length] === b[length]) length++\n  return length\n}\n\n/**\n * Make random perturbations to `array` to minimize the given expense function\n */\nexport function anneal<T>({\n  array,\n  expense,\n  allowedDelta\n}: {\n  array: T[]\n  expense: (arr: T[], fromIndex: number, toIndex: number) => Comparable\n  allowedDelta: number\n}): T[] {\n  const delta = Math.round(allowedDelta)\n  if (delta < 2) return array\n  for (let mid = 0; mid < array.length - 1; mid++) {\n    const newPos = randomInt(\n      Math.max(0, mid - delta),\n      Math.min(array.length, mid + delta),\n      [mid]\n    )\n    if (newPos == null) continue\n    // the range is either [mid - 1, newPos + 1] or [newPos - 1, mid + 1]\n    const i = Math.max(0, Math.min(newPos, mid) - 1)\n    const j = Math.min(array.length, Math.max(newPos, mid) + 1)\n    const currentExpense = expense(array, i, j)\n    move(array, mid, newPos)\n    const newExpense = expense(array, i, j)\n    // undo the move if newExpense isn't better:\n    if (lt(currentExpense, newExpense)) {\n      move(array, newPos, mid)\n    }\n  }\n  return array\n}\n\n/**\n * @param from inclusive\n * @param to exclusive\n * @param f\n */\nexport function range<T = number>(\n  from: number,\n  to: number,\n  f: (i: number) => T = ea => ea as any\n): T[] {\n  return stepRange(from, to, 1, f)\n}\n\n/**\n * @param to return an array up to but not including `to`\n * @see https://docs.python.org/2/library/functions.html#range\n */\nexport function stepRange<T = number>(\n  from: number,\n  to: number,\n  step: number = 1,\n  f: (i: number) => T = ea => ea as any\n): T[] {\n  const r: T[] = []\n  if (from < to) {\n    for (let i = from; i < to; i += step) {\n      r.push(f(i))\n    }\n  } else {\n    for (let i = from; i > to; i -= step) {\n      r.push(f(i))\n    }\n  }\n  return r\n}\n\n/**\n * `minuend - subtrahend`, or the elements in minuend that are not in\n * subtrahend. Only works with Primitives.\n *\n * @param {T[]} minuend (haystack)\n * @param {T[]} subtrahend (needles)\n * @returns {T[]} values in `minuend` that, according to `.valueOf()`, are not\n * in `subtrahend`. Neither arg is mutated.\n */\nexport function diff<T extends Primitive>(minuend: T[], subtrahend: T[]): T[] {\n  const s = new Set(subtrahend)\n  return minuend.filter(ea => !s.has(ea))\n}\n\nexport function last<T>(arr: Maybe<T[]>): Maybe<T> {\n  return arr != null ? arr[arr.length - 1] : undefined\n}\n\nexport function commaList(arr: string[], finalJoin = \"or\"): string {\n  if (arr.length <= 1) return arr.join(\"\")\n  if (arr.length === 2) return arr.join(\" \" + finalJoin + \" \")\n  return (\n    arr.slice(0, -1).join(\", \") + \", \" + finalJoin + \" \" + arr[arr.length - 1]\n  )\n}\n", "import { isEmpty } from \"./Array\"\nimport { eql } from \"./Eql\"\nimport { map } from \"./Maybe\"\nimport { Maybe } from \"./MaybeTypes\"\n\n// USED BY LOG: DON'T DEPEND ON ANYTHING (much)\n\n/**\n * `clear` will only remove any previously-memoized value.\n * `prior` returns the previously-memoized value.\n * `refresh` forces the thunk to be applied\n */\nexport interface MemoizedThunk<T> {\n  (): T\n  set(t: T): T\n  /** @return clear the prior value and return it */\n  clear(): Maybe<T>\n  /**\n   * Clears the prior value but doesn't return it (so we don't have to\n   * explicitly ignore unawaited promises)\n   */\n  unset(): void\n  prior(): Maybe<T>\n  /**\n   * Forces the underlying thunk or later to be applied\n   */\n  refresh(): T\n  ttl(): Maybe<number>\n  setTTL(ttl: number | undefined): void\n  onChange(listener: ChangeListener<T>): void\n  lastSetAgoMs(): number\n}\n\ntype ChangeListener<T> = (newResult: Maybe<T>, priorResult?: Maybe<T>) => any\n\n// HEY, FUTURE ME: yeah, I know you think something here should call\n// onClearCache(), but DON'T DO IT, MAN. lazy is used by lots of instances that\n// we want to be garbage collected, and that would create a huge memory leak.\n\nexport function lazy<T>(thunk: () => T, ttlMs?: number): MemoizedThunk<T> {\n  return new Lazy(thunk, ttlMs).asMemoizedThunk()\n}\n\nexport class Lazy<T> {\n  private lastSet = 0\n  private result: T | undefined\n  private readonly listeners: ChangeListener<T>[] = []\n\n  constructor(readonly thunk: () => T, public ttlMs?: number) {}\n\n  asMemoizedThunk(): MemoizedThunk<T> {\n    // As of 20200624 with node 14, this is better than fat arrows for memory consumption (!!?)\n    const f: any = this.apply.bind(this)\n    f.set = this.set.bind(this)\n    f.clear = this.clear.bind(this)\n    f.unset = this.unset.bind(this)\n    f.prior = this.prior.bind(this)\n    f.refresh = this.refresh.bind(this)\n    f.ttl = this.ttl.bind(this)\n    f.setTTL = this.setTTL.bind(this)\n    f.onChange = this.onChange.bind(this)\n    f.toJSON = this.toJSON.bind(this)\n    f.lastSetAgoMs = this.lastSetAgoMs.bind(this)\n    return f\n  }\n\n  private async onSetResult(priorP: Maybe<T>, currentP: Maybe<T>) {\n    if (isEmpty(this.listeners)) return\n    const prior = await priorP\n    const current = await currentP\n    if (!eql(prior, current)) {\n      for (const ea of this.listeners) ea(current, prior)\n    }\n  }\n\n  setResult(t: T) {\n    this.lastSet = Date.now()\n    void this.onSetResult(this.result, t)\n    return (this.result = t)\n  }\n\n  apply() {\n    if (\n      this.lastSet === 0 ||\n      (this.ttlMs != null && this.lastSet + this.ttlMs <= Date.now())\n    ) {\n      // NO PROMISE AWAITING HERE. Otherwise N calls would go through while we\n      // wait for the promise to resolve.\n      this.setResult(this.thunk())\n    }\n    return this.result!\n  }\n\n  set(t: T) {\n    return this.setResult(t)\n  }\n\n  unset() {\n    this.setResult(undefined as any)\n    this.lastSet = 0\n  }\n\n  clear() {\n    const prior = this.result\n    this.unset()\n    return prior\n  }\n\n  prior() {\n    return this.result\n  }\n\n  refresh() {\n    return this.setResult(this.thunk())\n  }\n\n  ttl() {\n    return this.ttlMs\n  }\n\n  setTTL(ttl: number) {\n    this.ttlMs = ttl\n  }\n\n  onChange(listener: ChangeListener<T>) {\n    this.listeners.push(listener)\n    map(this.result, listener)\n  }\n\n  // We don't support JSON encode/decode:\n  toJSON() {\n    return \"(Lazy)\"\n  }\n\n  lastSetAgoMs() {\n    return Date.now() - this.lastSet\n  }\n}\n", "import { lazy } from \"./Lazy\"\nimport { mapOr, orElse } from \"./Maybe\"\nimport { isNumber } from \"./Number\"\nimport { opt } from \"./Opt\"\n\nexport const secondMs = 1000\nexport const minuteMs = 60 * secondMs\nexport const hourMs = 60 * minuteMs\nexport const dayMs = 24 * hourMs\nexport const weekMs = 7 * dayMs\nexport const yearMs = 365.25 * dayMs\n\nconst dtf = lazy(\n  () =>\n    new Intl.DateTimeFormat(undefined, {\n      weekday: \"short\",\n      year: \"numeric\",\n      month: \"short\",\n      day: \"numeric\",\n      hour: \"numeric\",\n      minute: \"numeric\"\n    })\n)\n\nexport function fmtDateShort(d: Date | number) {\n  return opt(d)\n    .flatMap(ea => (ea instanceof Date ? ea.getTime() : ea))\n    .map(t => dtf().format(t))\n    .get()\n}\n\n/**\n * split an HMS string into a (possibly empty) prefix of zeroes and the remaining suffix.\n */\nexport function splitHMS(hms: string): string[] {\n  return mapOr(\n    /^[0:]{1,4}/.exec(hms),\n    m => [m[0], hms.substr(m[0].length)],\n    () => [\"\", hms]\n  )\n}\n\nexport function isDate(obj: any): obj is Date {\n  return obj instanceof Date\n}\n\n/**\n * @return Date `deltaMs` in the past\n */\nexport function ago(deltaMs: number, from?: Date): Date {\n  return new Date(orElse(from, new Date()).getTime() - deltaMs)\n}\n\n/**\n * @return Date `deltaMs` in the future\n */\nexport function hence(deltaMs: number, from?: Date): Date {\n  return ago(-deltaMs, from)\n}\n\nexport function unixtime(d?: Date | number): number {\n  const ms = isDate(d) ? d.getTime() : isNumber(d) ? d : Date.now()\n  return Math.floor(ms / secondMs)\n}\n\n// NOT FOR GENERAL USE. Only works for positive values.\nfunction pad2(i: number) {\n  const s = String(i)\n  return s.length >= 2 ? s : (\"0\" + s).slice(-2)\n}\n\n/**\n * Appropriate for filenames: yMMddHHmmss\n */\nexport function fmtYMDHMS(arg: Date | number): string {\n  const d = isDate(arg) ? arg : new Date(arg)\n  return (\n    d.getFullYear() +\n    pad2(d.getMonth() + 1) +\n    pad2(d.getDate()) +\n    pad2(d.getHours()) +\n    pad2(d.getMinutes()) +\n    pad2(d.getSeconds())\n  )\n}\n\n/**\n * ISO-formatted datestamp: y-MM-dd\n */\nexport function fmtIsoDate(ts: Date | number): string {\n  const d = isDate(ts) ? ts : new Date(ts)\n  return (\n    d.getFullYear() + \"-\" + pad2(d.getMonth() + 1) + \"-\" + pad2(d.getDate())\n  )\n}\n", "import { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { ThunkOrT, tot } from \"./Thunk\"\n\n// See https://basarat.gitbooks.io/typescript/content/docs/types/literal-types.html\n\nexport type StrEnumType<T extends string> = {\n  [K in T]: K\n}\n\nexport type StrEnumHelpers<T extends string> = {\n  values: T[]\n  length: number\n  has(s: MaybeNull<string>): s is T\n  indexOf(s: MaybeNull<string>): number\n  validOrElse<R>(s: MaybeNull<string>, defaultValue: ThunkOrT<R>): T | R\n  mapValid<R>(s: MaybeNull<string>, f: (t: T) => R): Maybe<R>\n}\n\nexport type StrEnum<T extends string> = StrEnumType<T> & StrEnumHelpers<T>\n\nexport type StrEnumKeys<Type> = Type extends StrEnum<infer X> ? X : never\n\nexport function strEnum<T extends string>(...o: T[]): StrEnum<T> {\n  const values = Object.freeze(o) as T[]\n\n  const dict: StrEnumType<T> = {} as any\n  for (const ea of values) {\n    dict[ea] = ea\n  }\n\n  const has = (s: MaybeNull<string>): s is T =>\n    s != null && values.includes(s as T)\n\n  const indexOf = (s: MaybeNull<string>) =>\n    s == null ? -1 : values.indexOf(s as T)\n\n  const validOrElse = <R>(s: MaybeNull<string>, defaultValue: ThunkOrT<R>) =>\n    has(s) ? s : tot(defaultValue)\n\n  const mapValid = <R>(s: string, f: (t: T) => R) =>\n    has(s) ? f(s as T) : undefined\n\n  return {\n    ...dict,\n    values,\n    length: values.length,\n    has,\n    indexOf,\n    validOrElse,\n    mapValid\n  }\n}\n\n// export const Directions = strEnum(\"North\", \"South\", \"East\", \"West\")\n// export type Direction = StrEnumKeys<typeof Directions>\n", "function chalk(on: number, off: number) {\n  return (msg: string) => `\\u001b[${on}m${msg}\\u001b[${off}m`\n}\n\n// https://en.wikipedia.org/wiki/ANSI_escape_code#3/4_bit\n\nexport const black = chalk(30, 39)\nexport const red = chalk(31, 39)\nexport const green = chalk(32, 39)\nexport const yellow = chalk(33, 39)\nexport const blue = chalk(34, 39)\nexport const magenta = chalk(35, 39)\nexport const cyan = chalk(36, 39)\nexport const lightGrey = chalk(37, 39)\nexport const darkGrey = chalk(90, 39)\nexport const redBright = chalk(91, 39)\nexport const greenBright = chalk(92, 39)\nexport const yellowBright = chalk(93, 39)\nexport const blueBright = chalk(94, 39)\nexport const magentaBright = chalk(95, 39)\nexport const cyanBright = chalk(96, 39)\nexport const white = chalk(97, 39)\nexport const bgBlack = chalk(40, 49)\nexport const bgRed = chalk(41, 49)\nexport const bgGreen = chalk(42, 49)\nexport const bgYellow = chalk(43, 49)\nexport const bgBlue = chalk(44, 49)\nexport const bgMagenta = chalk(45, 49)\nexport const bgCyan = chalk(46, 49)\nexport const bgLightGrey = chalk(47, 49)\nexport const bgDarkGrey = chalk(100, 49)\nexport const bgRedBright = chalk(101, 49)\nexport const bgGreenBright = chalk(102, 49)\nexport const bgYellowBright = chalk(103, 49)\nexport const bgBlueBright = chalk(104, 49)\nexport const bgMagentaBright = chalk(105, 49)\nexport const bgCyanBright = chalk(106, 49)\nexport const bgWhite = chalk(107, 49)\n\n// export function ansiColor(msg: string, rgb: Triplet) {\n//   const [r,g,b] = clampRGB(rgb)\n//   return `\\u001b[38;2;${r};${g};${b}m\"`\n// }\n", "import { env } from \"process\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { firstValueCaseInsensitive } from \"../fe/Object\"\nimport { isTrue } from \"../fe/Boolean\"\n\n/**\n * Case-insensitive search for a given ENV key\n */\nexport function getEnv(key: string): Maybe<string> {\n  return firstValueCaseInsensitive(env, key)\n}\n\nexport function isEnvTrue(key: string): boolean {\n  return isTrue(getEnv(key))\n}\n", "import { compact, isEmpty, isNotEmpty, sortBy, uniq } from \"./Array\"\nimport { blank, notBlank } from \"./Blank\"\nimport { stringify } from \"./JSON\"\nimport { defined, Unpick } from \"./Maybe\"\nimport { Maybe, MaybeValued, ReqValued } from \"./MaybeTypes\"\nimport { isFunction } from \"./ObjectType\"\n\nexport interface Valued<T> {\n  [key: string]: T\n}\n\nexport type KeyOf<T> = string & keyof T\n// export type KeyOf<T> = Extract<keyof T, string>\n\nexport type StringValued = Valued<Maybe<string>>\nexport type StrBoolValued = Valued<Maybe<string | boolean>>\nexport type NativeValued = Valued<Maybe<string | boolean | number>>\n\nexport type Obj = Record<string, any>\n\nexport function tap<T>(o: T, block?: (t: T) => void): T {\n  if (block != null) {\n    block(o)\n  } else {\n    if (typeof o === \"string\") {\n      console.log(o)\n    } else {\n      console.dir(o, { depth: 3 })\n    }\n  }\n  return o\n}\n\nexport function keys<T extends Obj>(obj: Maybe<T>): KeyOf<T>[] {\n  // `typeof null == \"Obj\"` because js wants to blow your mind.\n  if (obj == null || typeof obj !== \"object\") return []\n  return Object.keys(obj).filter(\n    k =>\n      typeof k === \"string\" &&\n      (obj[\"propertyIsEnumerable\"] == null ||\n        obj[\"propertyIsEnumerable\"](k) === true)\n  )\n}\n\nexport function emptyObj(o: Maybe<Obj>) {\n  return isEmpty(keys(o))\n}\n\nexport function notEmptyObj(o: Maybe<Obj>): o is Obj {\n  return o != null && isNotEmpty(keys(o))\n}\n\nexport function mapCompactObj<T>(o: Maybe<Obj>, f: (o: Obj) => T): Maybe<T> {\n  const c = compactValues(o)\n  return notEmptyObj(c) ? f(c) : undefined\n}\n\nexport function values<T extends Obj>(o: T): T[KeyOf<T>][] {\n  return keys(o).map(k => o[k]) as any\n}\n\n// polyfill for Object.entries\nexport function entries<T extends Obj>(obj: T): [KeyOf<T>, T[KeyOf<T>]][] {\n  return keys(obj).map(ea => [ea, obj[ea]])\n}\n\nexport function fromEntries(\n  arr: Maybe<[Maybe<string>, any]>[],\n  obj?: any\n): any {\n  if (typeof obj !== \"object\") obj = {} // don't use Object.create(null), json stringify will break!\n  return compact(arr).reduce(\n    (acc, [k, v]) =>\n      tap(acc, () => {\n        if (k != null && v != null) {\n          acc[k] = v\n        }\n      }),\n    obj\n  )\n}\n\nexport function compactValues<T extends Obj>(\n  t: Maybe<T>\n): Maybe<ReqValued<Partial<T>>> {\n  if (t == null) return undefined\n  const pairs = entries(t).filter(([k, v]) => k != null && v != null)\n  return isEmpty(pairs) ? undefined : fromEntries(pairs)\n}\n\nexport function compactBlankValues<T extends Obj>(\n  t: Maybe<T>\n): Maybe<ReqValued<Partial<T>>> {\n  if (t == null) return undefined\n  const pairs = entries(t).filter(([k, v]) => k != null && notBlank(v))\n  return isEmpty(pairs) ? undefined : fromEntries(pairs)\n}\n\nexport function mapFields(\n  o: Obj,\n  f: (key: string, value: any) => Maybe<[string, Maybe<any>]>,\n  obj = {}\n): Obj {\n  const arr = compact(\n    entries(o)\n      // DON'T DELETE THIS SORT! This makes model upserts have the same prepared\n      // statements:\n      .sort(([k1], [k2]) =>\n        k1.localeCompare(k2, undefined, { sensitivity: \"base\" })\n      )\n      .map(([k, v]) => f(k, v))\n  )\n  return fromEntries(\n    arr.filter(([k, v]) => k != null && v != null),\n    obj\n  )\n}\n\nexport function pick<T, K extends keyof T>(\n  obj: T,\n  ...keyNames: K[]\n): Pick<T, K> {\n  if (obj == null) return obj\n  if (!keyNames.every(ea => typeof ea === \"string\"))\n    throw new Error(\"bad keys: \" + stringify(keyNames))\n  if (isEmpty(keyNames)) return {} as any\n  // PERF: unrolled\n  const result: Pick<T, K> = {} as any\n  for (const ea of keyNames) {\n    const v = obj[ea]\n    if (v != null) result[ea] = v\n  }\n  return result\n}\n\n/**\n * @return the first value in `obj` associated to `keyNames` that `predicate` returns true.\n */\nexport function pickFirst<T, K extends keyof T>(\n  obj: T,\n  keyNames: K[],\n  predicate: (v: T[K]) => boolean = defined\n): Maybe<T[K]> {\n  if (obj == null) return\n  for (const key of keyNames) {\n    if (predicate(obj[key])) return obj[key]\n  }\n  return\n}\n\nexport function omit<T extends Obj, S extends string>(\n  t: Maybe<T>,\n  ...keysToOmit: S[]\n): Unpick<T, S> {\n  if (t == null || keysToOmit.every(ea => blank((t as any)[ea] as any))) {\n    return t as any\n  }\n  const pairs = entries(t).filter(([k]) => !keysToOmit.includes(k as any))\n  return isEmpty(pairs) ? undefined : fromEntries(pairs)\n}\n\nexport function isReqValued<T>(t: MaybeValued<T>): t is ReqValued<T> {\n  return values(t as any).every(ea => ea != null)\n}\n\nexport function reqValuedOrElse<T>(t: MaybeValued<T>): Maybe<ReqValued<T>> {\n  return isReqValued(t) ? t : undefined\n}\n\nexport function mapReqValued<T, U>(\n  t: MaybeValued<T>,\n  f: (ea: ReqValued<T>) => U\n): Maybe<U> {\n  return isReqValued(t) ? f(t) : undefined\n}\n\nexport function onlyReqValued<T>(arr: MaybeValued<T>[]): ReqValued<T>[] {\n  return arr.filter(isReqValued)\n}\n\nexport function sortedKeys<T extends Obj>(obj: T): T {\n  return fromEntries(sortBy(entries(obj), ([k]) => k.toLowerCase()))\n}\n\nexport function filter<T extends Obj, K extends string & keyof T>(\n  obj: T,\n  predicate: (k: K, value: T[K]) => boolean\n): Partial<T> {\n  if (obj == null) return obj\n  return fromEntries(\n    entries(obj).filter(([k, v]) => predicate(k as K, v as T[K]))\n  )\n}\n\n/**\n * As opposed to .keys() which only returns fields directly associated to the\n * given Obj, `allKeys` returns all direct *and inherited* properties (if\n * `obj` is a class instance, for example)\n */\nexport function allKeys(obj: any): string[] {\n  const methods: string[] = keys(obj)\n  while (null != (obj = Reflect.getPrototypeOf(obj))) {\n    methods.push(\n      ...(Reflect.ownKeys(obj).filter(\n        key => typeof key === \"string\"\n      ) as string[])\n    )\n  }\n  return uniq(methods)\n}\n\nexport function maybeCall(o: any, method: string, ...args: any[]) {\n  return o != null && isFunction(o[method])\n    ? o[method].bind(o)(...args)\n    : undefined\n}\n\nexport function firstValueCaseInsensitive(o: any, key: string): any {\n  if (blank(key)) return\n  if (o[key] != null) return o[key]\n  const lckey = key.toLocaleLowerCase().normalize()\n  for (const k of keys(o)) {\n    if (lckey === k.toLocaleLowerCase().normalize() && o[k] != null) return o[k]\n  }\n  return\n}\n", "import { Maybe } from \"../fe/MaybeTypes\"\n\nexport function isBoolean(object: any): object is boolean {\n  return typeof object === \"boolean\"\n}\n\n/**\n * (Fairly) strict coercion to true.\n *\n * @return false unless `o` is `true` or `1` (or stringifies to \"true\" or \"1\")\n */\nexport function isTrue(o: any): boolean {\n  if (typeof o === \"boolean\") return o\n  if (o == null) return false\n  if (o === 1) return true\n  const s = String(o).toLowerCase()\n  return [\"true\", \"1\"].includes(s)\n}\n\n/**\n * (Fairly) strict coercion to boolean. If parsing fails, returns undefined.\n */\nexport function toBoolean(o: any): Maybe<boolean> {\n  return isTrue(o) ? true : isFalse(o) ? false : undefined\n}\n\nexport function boolToInt(o: any) {\n  return isTrue(o) ? 1 : 0\n}\n\n/**\n * (Fairly) strict coercion to false.\n *\n * @return false unless `o` is `false` or `0` (or stringifies to \"false\" or\n * \"0\")\n */\nexport function isFalse(o: any): boolean {\n  if (typeof o === \"boolean\") return !o\n  if (o == null) return false\n  if (o === 0) return true\n  const s = String(o).toLowerCase()\n  return [\"false\", \"0\"].includes(s)\n}\n\nexport function or(arr: any[]): boolean {\n  return arr.some(ea => isTrue(ea))\n}\n\nexport function and(arr: any[]): boolean {\n  return arr.every(ea => isTrue(ea))\n}\n\nexport function mapBoolean<T>(obj: any, f: (b: boolean) => T): Maybe<T> {\n  return isTrue(obj) ? f(true) : isFalse(obj) ? f(false) : undefined\n}\n\nexport function mapTrue<T>(b: any, f: () => T): Maybe<T> {\n  return isTrue(b) ? f() : undefined\n}\n", "import { pid } from \"process\"\nimport { compactBlanks } from \"../fe/Array\"\nimport { blank } from \"../fe/Blank\"\nimport { minuteMs, secondMs } from \"../fe/Date\"\nimport { lazy } from \"../fe/Lazy\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { strEnum, StrEnumKeys } from \"../fe/StrEnum\"\nimport { toS } from \"../fe/toS\"\nimport { AppName } from \"./AppName\"\nimport {\n  bgBlack,\n  blue,\n  blueBright,\n  cyan,\n  green,\n  magenta,\n  red,\n  yellow\n} from \"./Chalk\"\nimport { setupLogger } from \"./Logger\"\nimport { isTest } from \"./NodeEnv\"\n\nexport const ServiceNames = strEnum(\n  \"main\",\n  \"web\",\n  \"sync\",\n  \"sync-file\",\n  \"info\",\n  \"test\",\n  \"logcat\",\n  \"logtail\",\n  \"list\",\n  \"billing\"\n)\n\nexport type ServiceName = StrEnumKeys<typeof ServiceNames>\n\nexport function serviceNameIndex(s: Maybe<ServiceName>): number {\n  const idx = ServiceNames.indexOf(s)\n  return idx < 0 ? ServiceNames.length + 1 : idx\n}\n\nexport const RpcServerServices: ServiceName[] = [\"main\", \"test\"]\n\n/**\n * These are the only services that don't require a library to start up\n */\nexport const WelcomeServices: ServiceName[] = [\"main\", \"web\", \"test\", \"info\"]\nexport const StatsDbServices: ServiceName[] = [\"sync\", \"sync-file\"]\n\nexport function title(service: ServiceName): string {\n  return AppName() + \" \" + service\n}\n\nexport function serviceShutdownTimeoutMs(service: ServiceName): number {\n  switch (service) {\n    case \"main\":\n    case \"web\":\n      return minuteMs // time to vacuum and restore the db to the library\n    case \"sync\":\n    case \"sync-file\":\n    default:\n      return 10 * secondMs // time to finish a given import\n  }\n}\n\nlet _serviceName: ServiceName = \"\" as any\n\nexport function serviceName() {\n  if (blank(_serviceName)) throw Error(\"serviceName() is unset\")\n  return _serviceName\n}\n\nexport function setServiceName(s: ServiceName) {\n  if (!isTest && s !== _serviceName && (_serviceName as any) !== \"\") {\n    throw new Error(\"Cannot set service name twice\")\n  }\n  _serviceName = s\n  processName.unset()\n  setupLogger()\n}\n\nexport function maybeSetServiceName(s: ServiceName) {\n  if (!isTest) throw new Error(\"Only used by tests\")\n  if (blank(_serviceName)) setServiceName(s)\n}\n\nconst procColors = lazy(() => [\n  { re: /sync-file|billing/, f: cyan },\n  { re: /sync/, f: blue },\n  { re: /web/, f: green },\n  { re: /db/, f: magenta },\n  { re: /main/, f: yellow },\n  { re: /info/, f: blueBright },\n  { re: /test/, f: red }\n])\n\nexport const processName = lazy(() =>\n  compactBlanks([_serviceName, toS(pid)]).join(\"-\")\n)\n\nexport function colorProcessName(s: string): string {\n  const pc = procColors().find(ea => s.match(ea.re))\n  return pc != null ? bgBlack(pc.f(s)) : s\n}\n\nexport function isMainService() {\n  // This is called by Library: don't call serviceName(), which throws an error,\n  // because that fails tests. If it's the main service, main service will have\n  // set this properly.\n  return _serviceName === ServiceNames.main\n}\n\nexport function isWebService() {\n  // This is called by Library: don't call serviceName(), which throws an error,\n  // because that fails tests. If it's the main service, main service will have\n  // set this properly.\n  return _serviceName === ServiceNames.web\n}\n\n/**\n * This process should host the RPC event orchestration service and run the\n * Model DB Janitor service.\n */\nexport function isRpcServer(): boolean {\n  return RpcServerServices.includes(serviceName())\n}\n\nexport function isRpcClient(): boolean {\n  return !isRpcServer() && _serviceName !== \"info\"\n}\n\nexport function isSyncService() {\n  // This is called by StdoutWrite: don't call serviceName().\n  return _serviceName === \"sync\"\n}\n\nexport function isSyncFileService() {\n  // This is called by StdoutWrite: don't call serviceName().\n  return _serviceName === \"sync-file\"\n}\n\n/**\n * These are services that can run without a set library.\n */\nexport function isWelcomeService() {\n  return WelcomeServices.includes(serviceName())\n}\n\nexport function isStatsDbClient() {\n  // This is called by StdoutWrite: don't call serviceName().\n  return StatsDbServices.includes(serviceName())\n}\n\n// lazy for tests to .set():\nexport const isStatsDbMigrator = lazy(\n  () => isSyncService() || (isTest && !isSyncFileService())\n)\n", "import { argv, env } from \"process\"\nimport { toS } from \"../fe/toS\"\nimport { isTrue } from \"../fe/Boolean\"\n\nexport function _nodeEnv() {\n  switch (toS(env.NODE_ENV).toLowerCase()) {\n    case \"test\":\n    case \"testing\":\n      return \"test\"\n    case \"dev\":\n    case \"development\":\n      return \"development\"\n    case \"prod\":\n    case \"production\":\n      return \"production\"\n    default:\n      if (argv.some(ea => ea.endsWith(\"mocha\") || ea.endsWith(\".spec.js\"))) {\n        return \"test\"\n      } else {\n        return \"production\"\n      }\n  }\n}\n\nexport const nodeEnv = (() => {\n  const ne = _nodeEnv()\n  // Make sure NODE_ENV gets the final value. If not, stuff like Pug stays in\n  // dev mode: https://pugjs.org/api/express.html\n  env.NODE_ENV = ne\n  return ne\n})()\n\nexport const isDev = nodeEnv === \"development\"\nexport const isTest = nodeEnv === \"test\"\nexport const isProd = nodeEnv === \"production\"\n\nexport function isSingleSpecTests() {\n  return isTest && isTrue(env.SINGLE_SPEC_TESTS)\n}\n\nexport function setSingleSpecTests(b: boolean) {\n  env.SINGLE_SPEC_TESTS = b ? \"true\" : \"false\"\n}\n\nexport const start = Date.now()\n", "import { lazy } from \"../fe/Lazy\"\nimport { isProd, nodeEnv } from \"./NodeEnv\"\n\nexport const SimpleAppName = \"PhotoStructure\"\n\nexport const AppName = lazy(() => SimpleAppName + (isProd ? \"\" : `-${nodeEnv}`))\n", "import { cpus } from \"os\"\nimport { delimiter, join } from \"path\"\nimport { diff, sortBy, uniq } from \"../../fe/Array\"\nimport { blank, mapNotBlankOr, notBlank } from \"../../fe/Blank\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { FitSizeValues } from \"../../fe/ImageSizes\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { entries, values } from \"../../fe/Object\"\nimport { GB, KB } from \"../../fe/Units\"\nimport { defaultCacheDir } from \"../DefaultCacheDir\"\nimport { isEnvTrue } from \"../Env\"\nimport { defaultLogDir } from \"../LogDir\"\nimport { isProd as _isProd } from \"../NodeEnv\"\nimport { channel } from \"../PhotoStructureVersion\"\nimport { defaultPicturesDir } from \"../PicturesDir\"\nimport { isDocker, isElectron, isLinux, isMac, isWin } from \"../Platform\"\nimport { PriorityClasses } from \"../PriorityClass\"\nimport { DefaultLensMakes } from \"../tags/DefaultLensMakes\"\nimport { SidecarExts } from \"../tags/SidecarExts\"\nimport {\n  BooleanSetting,\n  BoundedFloatSetting,\n  BoundedIntegerSetting,\n  FloatSetting,\n  IntegerSetting,\n  LibraryCategories,\n  MaybeStringSetting,\n  SettingCategories,\n  StringArraySetting,\n  StringEnumSetting,\n  StringEnumsSetting,\n  StringSetting,\n  SystemCategories\n} from \"./Setting\"\nimport _p = require(\"process\")\n\nconst DefaultPosixPaths = Object.freeze([\n  // From Ubuntu's /etc/environment:\n  \"/usr/local/sbin\",\n  \"/usr/local/bin\",\n  \"/opt/local/sbin\", // macports\n  \"/opt/local/bin\", // macports\n  \"/usr/sbin\",\n  \"/usr/bin\",\n  \"/sbin\",\n  \"/bin\"\n])\n\n// exposed so tests can pretend we're in production:\nexport const isProd = lazy(() => _isProd)\nconst isTest = () => !isProd()\n\n// Only exported for testing:\nexport const DefaultPaths = Object.freeze(\n  isWin\n    ? [\n        ...mapNotBlankOr(\n          _p.env.SYSTEMROOT,\n          ea => [\n            ea,\n            join(_p.env.SYSTEMROOT!, \"System32\"),\n            join(_p.env.SYSTEMROOT!, \"System32\", \"webm\")\n          ],\n          () => []\n        ),\n        \"C:\\\\cygwin64\\\\bin\"\n      ]\n    : DefaultPosixPaths\n)\n\n// Most all Setting instances have keys that are prefixed with `PS_`, which let\n// them be used in environment variables without colliding with other\n// environment variables. The `PS_` prefix isn't needed otherwise.\n\n// Only Setting instances should be included in this namespace:\nexport const Settings = {\n  copyAssetsToLibrary: new BooleanSetting({\n    category: SettingCategories.Paths,\n    description: `Should PhotoStructure copy photos and videos to your PhotoStructure Library? This setting holds the value for the welcome page's \"May PhotoStructure organize your photos and videos?\" section. Read more about this setting here: <https://photostructure.com/getting-started/automatic-library-organization/>.`,\n    defaultValue: true,\n    advanced: () => false\n  }),\n\n  libraryPath: new MaybeStringSetting({\n    envAliases: [\"PS_LIBRARY\", \"PS_LIBRARY_DIR\"],\n    category: SettingCategories.Paths,\n    description:\n      \"This is the absolute path to your PhotoStructure library. If missing, or set to an empty string, the welcome page will be shown when PhotoStructure launches. Use native file separators (so on windows, use back-slashes).\",\n    exampleValue: () =>\n      isTest()\n        ? \"/home/test/Pictures\"\n        : isDocker()\n        ? \"/ps/library\"\n        : defaultPicturesDir(),\n    defaultValue: () => (isDocker() && !isTest() ? \"/ps/library\" : undefined),\n    advanced: () => false\n  }),\n\n  previewsDir: new StringSetting({\n    category: SettingCategories.Paths,\n    description: `This is the directory that PhotoStructure uses to store preview images. This defaults to the \".photostructure/previews\" directory inside your PhotoStructure library. Absolute paths here are supported, but if you keep your library and previews directory separated, take care when you open your library on different computers, as this setting needs to be adjusted for those computers as well.\\nNOTE: \"originalDirs\" is recommended instead of this setting; If you get \"previewsDir\" wrong, your library won't work. If you get \"originalsDir\" wrong, you just break full-screen zoom and non-transcoded videos.`,\n    defaultValue: () => \".photostructure/previews\"\n  }),\n\n  originalsDir: new StringSetting({\n    category: SettingCategories.Paths,\n    description: `This is the directory that PhotoStructure uses to store original images when \"copyAssetsToLibrary\" is enabled. Absolute paths are supported. Relative paths are evaluated from your libraryPath. This setting defaults to \".\", which is the same as your PhotoStructure library directory.\\nIf you open your PhotoStructure library on a different computer, and that computer doesn't have access to your originals volume, full-screen zoom won't work, and non-transcoded videos will not play.\\nThis system setting needs to be set appropriately on different computers (it won't be set automatically!)\\nIf you have a large library and want to use an SSD, we recommend you set your libraryPath to your SSD, and use this setting to store your originals on a larger volume, rather than using the \"previewsDir\" setting.`,\n    defaultValue: () => \".\"\n  }),\n\n  forceOpen: new BooleanSetting({\n    category: SettingCategories.Paths,\n    description:\n      \"DANGEROUS: if set, all previously-existing library locks will be removed. This should only be necessary if the prior PhotoStructure process was not shut down gracefully.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  scanAllDrives: new BooleanSetting({\n    category: SettingCategories.Paths,\n    description:\n      \"Should PhotoStructure scan all folders on all drives available to this computer for photos and videos?\",\n    defaultValue: true,\n    advanced: () => false\n  }),\n\n  scanMyPictures: new BooleanSetting({\n    category: SettingCategories.Paths,\n    description:\n      \"Deprecated, and will be removed in the next version. If set, PhotoStructure will automatically add your pictures directory to your `scanPaths` setting.\",\n    defaultValue: false,\n    advanced: () => false\n  }),\n\n  scanPaths: new StringArraySetting({\n    category: SettingCategories.Paths,\n    description: `This holds an array of absolute paths to scan for assets. If you are setting this via an environment variable, you may use either standard PATH formatting, like \\`PS_SCAN_PATHS=\"/path/one:/path/two\"\\`, or use JSON encoding, like \\`PS_SCAN_PATHS='[\"/path/one\",\"/path/two\"]'\\`.`,\n    advanced: () => false,\n    exampleValue: () =>\n      isTest() ? [\"/path/one\", \"/path/two\"] : [defaultPicturesDir()]\n  }),\n\n  cacheDir: new StringSetting({\n    category: SettingCategories.Paths,\n    description:\n      \"Where would you like PhotoStructure's scratch file directory? This must be a fast, local disk with several gigabytes free. Note that if PS_FORCE_LOCAL_DB_REPLICA is enabled, the local DB replica will be stored in this directory.\",\n    exampleValue: () => (isTest() ? \"/tmp/ps_cache_dir\" : defaultCacheDir()),\n    defaultValue: () => defaultCacheDir()\n  }),\n\n  neverIgnored: new StringArraySetting({\n    category: SettingCategories.Paths,\n    description:\n      \"Paths to files or directories that should not be ignored, even if they are hidden or have .nomedia files.\"\n  }),\n\n  pidfile: new MaybeStringSetting({\n    envAliases: [\"PIDFILE\"],\n    category: SettingCategories.Paths,\n    description:\n      \"This is the absolute path to the PID file for the main process. This is optional and only used by PhotoStructure for Servers.\",\n    exampleValue: () => \"/var/run/photostructure.pid\"\n  }),\n\n  scanLibraryFirst: new BooleanSetting({\n    category: SettingCategories.Paths,\n    description:\n      \"Should PhotoStructure scan your library before all other paths are synchronized?\",\n    defaultValue: false\n  }),\n\n  scanLibraryLast: new BooleanSetting({\n    category: SettingCategories.Paths,\n    description:\n      \"Should PhotoStructure scan your library after all other paths are synchronized?\",\n    defaultValue: true\n  }),\n\n  //\n  // LOGGING\n  //\n\n  logLevel: new StringSetting({\n    envAliases: [\"PS_LOG\", \"LOG\"],\n    category: SettingCategories.Logging,\n    description:\n      \"Determines which level of log messages are emitted to log files. May be 'debug', 'info', 'warn', 'error', or a log level followed by a context (like 'debug:rpc').\",\n    defaultValue: () => (isProd() ? \"error\" : \"info\")\n  }),\n\n  logDir: new StringSetting({\n    category: SettingCategories.Logging,\n    description: \"Determines the directory that log files will be written to.\",\n    defaultValue: () => defaultLogDir(),\n    exampleValue: () => (isTest() ? \"/var/log/photostructure\" : undefined)\n  }),\n\n  logCompression: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description: \"Should log files be compressed as they are rotated?\",\n    defaultValue: () => isProd() // don't compress in test or dev so logtail is happy\n  }),\n\n  logElapsedMs: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"Prefix log entries by a timestamp (if set to false), or by the number of milliseconds since startup (if set to true).\",\n    defaultValue: () => false\n  }),\n\n  logWebRequests: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description: \"Write an access log for all web requests?\",\n    defaultValue: false\n  }),\n\n  logWebDir: new MaybeStringSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"Determines the directory that log files will be written to. If unset, will use logDir.\"\n  }),\n\n  logStdout: new BooleanSetting({\n    envAliases: [\"LOG_STDOUT\", \"PS_STDOUT\"],\n    category: SettingCategories.Logging,\n    description:\n      \"Log to stdout? This should be false unless you're running a service by hand.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  tailLogs: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"Output all logs from currently running PhotoStructure processes? This should be false unless you're running a service by hand.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  logColor: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"Output all logs with terminal escape codes to colorize output. If NO_COLOR is set, this defaults to false. See <https://no-color.org/>.\",\n    defaultValue: () => blank(_p.env.NO_COLOR)\n  }),\n\n  logSql: new BooleanSetting({\n    category: SettingCategories.Logging,\n    description:\n      \"Log SQL queries to the default log level. *This is really chatty* and impacts performance. Normally these log messages are completely disabled.\",\n    defaultValue: () => false\n  }),\n\n  //\n  // Networking\n  //\n\n  localhost: new StringSetting({\n    category: SettingCategories.Networking,\n    description: `If \"exposeNetworkWithoutAuth\" is false, what value should PhotoStructure use for localhost? (Some firewalls are OK with \"127.0.0.1\", some require \"localhost\"). See <https://letsencrypt.org/docs/certificates-for-localhost/> and <https://photostructure.com/faq/troubleshooting/#windows-firewall-issues>.`,\n    // See https://letsencrypt.org/docs/certificates-for-localhost/\n    // and https://tools.ietf.org/html/draft-ietf-dnsop-let-localhost-be-localhost-02\n    defaultValue: () => \"127.0.0.1\"\n  }),\n\n  httpPort: new IntegerSetting({\n    category: SettingCategories.Networking,\n    description: \"Network port for HTTP access to your PhotoStructure library.\",\n    defaultValue: 1787\n  }),\n\n  trustProxy: new StringSetting({\n    category: SettingCategories.Networking,\n    description: `Support for PhotoStructure instances running behind a reverse proxy. See <http://expressjs.com/en/guide/behind-proxies.html>. This setting should either be \"false\" (don't trust any proxies), \"loopback\", (only trust localhost), a single subnet (like \"127.0.0.0/8\"), or a comma-delimited set of subnets.`,\n    defaultValue: \"false\"\n  }),\n\n  exposeNetworkWithoutAuth: new BooleanSetting({\n    category: SettingCategories.Networking,\n    description:\n      \"Normally the web service is only accessible to the computer running PhotoStructure. Setting this to true will expose your library to all computers on your network. You should own or trust all systems on that network, as there is no auth in PhotoStructure currently. Future versions of PhotoStructure will add authorization mechanisms, at which point this setting will be deleted.\\n**Don't enable this unless you know what you are doing**.\",\n    defaultValue: () => isDocker() && !isTest()\n  }),\n\n  rpcPort: new IntegerSetting({\n    category: SettingCategories.Networking,\n    description: `Network port for rpc access to your PhotoStructure library. Only binds to loopback (even if exposeNetworkWithoutAuth is true).`,\n    defaultValue: 1807\n  }),\n\n  //\n  // Process management\n  //\n\n  exiftoolProcsPerChild: new BoundedIntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"Each PhotoStructure process spins up an ExifTool when needed. Note that the `web`, `sync`, and `sync-file` services all use exiftool, so the total number of exiftool processes can be many times larger than this value.\",\n    min: 1,\n    max: 8,\n    defaultValue: 2\n  }),\n\n  sensitiveEnvRegExp: new StringSetting({\n    category: SettingCategories.Processes,\n    description: `PhotoStructure spawns a number of processes (including \"exiftool\" and \"ffmpeg\"), and passes through environment variables, mostly to ensure locale and TZ settings are correct. To prevent environment values that contain sensitive information, like API access tokens, from either being logged, or being accessed by external tools, all environment variables whose key matches this setting will be removed. This regex is applied case-insensitively.`,\n    defaultValue: \"key|secret|pass|_user|aws_\"\n  }),\n\n  bounceMinutes: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"PhotoStructure will bounce the web and sync processes periodically. Set to 0 to disable.\",\n    defaultValue: 60 * (isTest() ? 5 : isMac ? 2 : 5)\n  }),\n\n  setupTimeoutMs: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description: `To prevent unhealthy services running as zombies, they self-terminate if the setup processes are not complete within this amount of time. Note that only the environment variable value is used for this setting.`,\n    defaultValue: 35 * secondMs\n  }),\n\n  probationMs: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"Normally when subsystems crash, PhotoStructure restarts them after a delay. Unfortunately, if there is a persistent error, this means PhotoStructure keeps trying something that won't ever work; it looks busy, but it's just busy failing. To prevent this situation, PhotoStructure will shut down if there are high error rates within 2 minutes of starting. (2 minutes should be long enough to spin up the web process, sync process, and import at least one pending file). Setting this to 0 will prevent PhotoStructure from exiting due to high error rates.\",\n    defaultValue: 2 * minuteMs\n  }),\n\n  minTimeBetweenServiceRestartsMs: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"If a service (like web, sync, or sync-file) is restarted due to an error, how many ms must elapse before another restart is allowed? This helps prevent system load due to service flapping.\",\n    defaultValue: 7 * secondMs\n  }),\n\n  fatalErrorRatePerMinute: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"If PhotoStructure sees errors at a higher rate per minute than this setting, PhotoStructure will shut down. If this value is too high, PhotoStructure may look busy, but it's just busyfailing. If this value is set too low, temporary errors (due to network flakiness or USB hiccups) might shut down PhotoStructure needlessly.\",\n    defaultValue: 10\n  }),\n\n  minDiskFreeGb: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"PhotoStructure will pause processing if the GB free on the disk that your library is stored on drops below this value. The value provided here will be multiplied by 1000^3. Note that many OSes will corrupt themselves when disks fill up, and SSDs can fail as they approach full capacity. A value of less than 8 may be unsafe (due to hibernation and os update files).\",\n    defaultValue: 6\n  }),\n\n  cpuLoadPercent: new BoundedIntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"PhotoStructure runs many things in parallel during library synchronization. The maximum number of concurrent file imports that PhotoStructure will schedule at a time will be the number of CPUs that this system has multiplied by this percent. A higher value here will allow PhotoStructure to run more tasks in parallel, but may impact your system's responsiveness. 75% should be a reasonable balance between keeping your system responsive and importing your library quickly. Setting this value to 0 will still allow 1 task to run concurrently. System memory will also be taken into account to try to prevent swapping.\",\n    defaultValue: 75,\n    min: 0,\n    max: 200\n  }),\n\n  processPriority: new StringEnumSetting({\n    category: SettingCategories.Processes,\n    description: `By default, PhotoStructure runs child processes with a \"below normal\" priority, so your system remains usable while imports run. Changing this value to \"normal\" or \"above normal\" may speed up imports but cause your system to be unresponsive. Changing this value to \"idle\" may prevent imports from running at all.`,\n    defaultValue: () => PriorityClasses.BelowNormal,\n    validValues: PriorityClasses.values\n  }),\n\n  maxMemoryMb: new BoundedIntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"PhotoStructure will restart services if they use more than this value (measured in megabytes, or 1,000,000 bytes). Note that this is not the allocated memory. See maxRssMemoryMb for total allocated.\",\n    defaultValue: 500,\n    min: 256,\n    max: 8000\n  }),\n\n  maxRssMemoryMb: new BoundedIntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"PhotoStructure will restart services if their' resident set size consumes more than this value (measured in megabytes, or 1,000,000 bytes).\",\n    defaultValue: 1000,\n    min: 250,\n    max: 8000\n  }),\n\n  maxTasksPerProcess: new BoundedIntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"PhotoStructure will recycle sync-file processes after they handle this number of requests. Smaller values may reduce overall memory pressure. Larger values amortize startup costs over fewer restarts.\",\n    defaultValue: () => (isTest() ? 10 : 200),\n    min: 1,\n    max: 5000\n  }),\n\n  pollIntervalMs: new IntegerSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"The number of milliseconds we wait between polling for changes in remote filesystems. This defaults to 1 minute, to minimize remote filesystem load.\",\n    defaultValue: () => (isProd() ? minuteMs : 5 * secondMs)\n  }),\n\n  inspect: new BooleanSetting({\n    category: SettingCategories.Processes,\n    description:\n      \"Should processes run with --inspect? This should only be enabled temporarily, as it impacts both performance and security.\",\n    defaultValue: false,\n    transient: true,\n    advanced: () => true\n  }),\n\n  ignoreUnhealthyVolumes: new BooleanSetting({\n    category: SettingCategories.Volumes,\n    description:\n      \"When true, PhotoStructure ignores volumes that are not healthy (due to needing filesystem checks, or remote filesystems that are not available).\",\n    defaultValue: true\n  }),\n\n  validateMountpoints: new BooleanSetting({\n    category: SettingCategories.Volumes,\n    description:\n      \"When true, PhotoStructure ignores volumes whose mountpoints do not exist.\",\n    defaultValue: true\n  }),\n\n  readVolumeUuidFiles: new BooleanSetting({\n    category: SettingCategories.Volumes,\n    description: `When true, PhotoStructure uses \".uuid\" files found in the root directory of volumes as the volume UUID, which can help with cross-host library portability. Set this to false if you don't want PhotoStructure to read these \".uuid\" files. See https://photostructure.com/faq/what-is-a-volume for more information.`,\n    defaultValue: true\n  }),\n\n  writeVolumeUuidFiles: new BooleanSetting({\n    category: SettingCategories.Volumes,\n    description: `When true, PhotoStructure (tries to) write \".uuid\" files into the root directory of volumes, which enables cross-host library portability. Set this to false if you don't want PhotoStructure to try to write these \".uuid\" files. See https://photostructure.com/faq/what-is-a-volume for more information.`,\n    defaultValue: true\n  }),\n\n  // TODO: (this requires the thumbnails to be built on the fly)\n  // ,skipThumbs: new BooleanPref({\n  //   key: \"PS_SKIP_THUMBS\",\n  //   description:\n  //     \"If set, no thumbnails or websized previews will be created during library imports, which makes library importing much faster. Browsing, however, is much slower, as previews must be created on the fly\",\n  //   defaultValue: false,\n  //   persisted: true\n  // })\n\n  //\n  // DB\n  //\n\n  // Use primary/replica terminology:\n\n  forceLocalDbReplica: new BooleanSetting({\n    category: SettingCategories.Paths, // because it will be specific to the system, not the library.\n    description:\n      \"Libraries on remote filesystems can suffer from bad performance and inconsistent transactions due to slow file I/O and missing file locking mechanics. When opening libraries on remote filesystems, or if this setting is `true`, PhotoStructure will copy the library database to the `cacheDir` and perform I/O against this local replica. Changes made to the local db replica are then periodically copied back to the remote library.\",\n    defaultValue: () => isDocker() && !isTest()\n  }),\n\n  // From https://sqlite.org/pragma.html#pragma_optimize\n\n  // \"Long-running applications might also benefit from setting a timer to run\n  // \"PRAGMA optimize\" every few hours.\"\n\n  dbBackupsCount: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"How many prior backups should PhotoStructure retain? These will typically be 10-500 MB, depending on the size of your library.\",\n    defaultValue: 20\n  }),\n\n  maxBusyDbMs: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"SQLite supports concurrent readers but concurrent writers may collide, causing a LOCKED or BUSY error. PhotoStructure will retry the db operation for maxBusyDbMs milliseconds. This defaults to 2 minutes, which seems like a long time, but hard drives and network filesystems can take 10-20 seconds to spin up if asleep.\",\n    defaultValue: () => 2 * minuteMs\n  }),\n\n  dbTimeoutMs: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"SQLite can time out requests if the db file is unavailable. PhotoStructure will retry those requests (up to `maxBusyDbMs`). A shorter time may help overall throughput, but may require more work done in retry logic. A longer time may be better for slower machines and slower disks. Note that setting this value to be lower than disk I/O latency (~1ms-100ms) will cause all database queries to fail.\",\n    defaultValue: () => secondMs\n  }),\n\n  // We're using a bounded float so we can get fractional minutes for test, and\n  // users don't have to think in milliseconds.\n  dbBackupIntervalMinutes: new BoundedFloatSetting({\n    category: SettingCategories.Db,\n    description:\n      \"How many minutes should elapse between backing of your library database? Note that PhotoStructure vacuums and optimizes the database before a backup is taken. You want this period to be frequent enough such that data loss isn't too painful. Note that backups can cause the webserver to be momentarily unresponsive. Default is every hour.\",\n    min: isTest() ? 0.5 : 1, // < force a backup in the middle of the SyncService and ModelDbUpdater tests to exercise pause-for-vacuum\n    max: 60 * 12,\n    defaultValue: () => (isTest() ? 0.5 : 30)\n  }),\n\n  dbCacheSizeMb: new IntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"PhotoStructure uses SQLite, and the cache_size pragma should ideally be set such that the whole DB can be in memory. See https://sqlite.org/pragma.html#pragma_cache_size for more information.\",\n    defaultValue: 192\n  }),\n\n  dbBatchSelectSize: new BoundedIntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"How many objects can be selected at at time? The default should be fine. (Exposed for performance tests).\",\n    defaultValue: 128,\n    min: 1,\n    max: 900\n  }),\n\n  dbBatchUpsertSize: new BoundedIntegerSetting({\n    category: SettingCategories.Db,\n    description:\n      \"How many objects can be upserted at at time? The default should be fine. (Exposed for performance tests).\",\n    defaultValue: 16,\n    min: 1,\n    max: 500\n  }),\n\n  //\n  // Health checks\n  //\n\n  healthCheckExiftool: new BooleanSetting({\n    category: SettingCategories.HealthChecks,\n    description:\n      \"When true, PhotoStructure verifies ExifTool is available and a valid version.\",\n    defaultValue: true\n  }),\n\n  healthCheckLibraryIsWritable: new BooleanSetting({\n    category: SettingCategories.HealthChecks,\n    description:\n      \"When true, PhotoStructure verifies the library directory exists, and is writable.\",\n    defaultValue: true\n  }),\n\n  healthCheckVolumes: new BooleanSetting({\n    category: SettingCategories.HealthChecks,\n    description:\n      \"When true, PhotoStructure verifies volumes as part of periodic health checks.\",\n    defaultValue: true\n  }),\n\n  healthCheckFreeSpace: new BooleanSetting({\n    category: SettingCategories.HealthChecks,\n    description:\n      \"When true, PhotoStructure verifies that the library and cache volumes have sufficient free space.\",\n    defaultValue: true\n  }),\n\n  healthCheckDb: new BooleanSetting({\n    category: SettingCategories.HealthChecks,\n    description:\n      \"When true, PhotoStructure verifies that the library database can be read from and written to.\",\n    defaultValue: true\n  }),\n\n  //\n  // TOOLS\n  //\n\n  enableSIMD: new BooleanSetting({\n    category: SettingCategories.Tools,\n    description: `Should PhotoStructure enable SIMD extensions when running image operations? This defaults to false on macOS due to instability on that platform.`,\n    // isTest() to make the result consistent across CI:\n    defaultValue: () => (isTest() || isMac ? false : true)\n  }),\n\n  enableVipsCache: new BooleanSetting({\n    category: SettingCategories.Tools,\n    description: `Should PhotoStructure enable VIPS caching, which may help speed up image operations? This defaults to false to reduce memory consumption.`,\n    defaultValue: () => false\n  }),\n\n  showFileInFolderUsesThunar: new BooleanSetting({\n    category: SettingCategories.Tools,\n    description: `If we're on Linux, should we use Thunar (via dbus) to \"show file in folder\"?`,\n    defaultValue: false\n  }),\n\n  showFileInFolderUsesFileUri: new BooleanSetting({\n    category: SettingCategories.Tools,\n    description: `Does the showFileInFolderCommand expect a file: URI to the file? If this is false, the native path will be appended instead.`,\n    exampleValue: () => true,\n    defaultValue: () => isLinux\n  }),\n\n  showFileInFolderCommand: new StringArraySetting({\n    category: SettingCategories.Tools,\n    description: `If set, the first argument will be used as a command (or path to command), and the subsequent arguments (if present) will be used as arguments. The native path to the file or the file: URI will be appended, based on the value given to the \"showFileInFolderUsesFileUri\" setting. If this is set to an empty array, the default tool for your platform will be used instead: \"nautilus -s\" on linux, \"open -R\" on mac, and \"explorer /select\" on Windows.\\nThis is provided to support Linux desktops that don't use Gnome.`,\n    defaultValue: []\n  }),\n\n  dcraw_emuPath: new StringSetting({\n    category: SettingCategories.Tools,\n    description: `This should be the absolute, native path to the \"dcraw_emu\" binary on this system. If this is set to \"dcraw_emu\", PhotoStructure will search your $PATH. See <https://www.libraw.org/docs/Samples-LibRaw.html>.`,\n    defaultValue: \"dcraw_emu\"\n  }),\n\n  ffmpegPath: new StringSetting({\n    category: SettingCategories.Tools,\n    description: `This should be the absolute, native path to the \"ffmpeg\" binary on this system. If this is set to \"ffmpeg\", PhotoStructure will search your $PATH. PhotoStructure prefers using ffmpeg to vlc. See <https://photostructure.com/getting-started/video-support/>.`,\n    defaultValue: \"ffmpeg\"\n  }),\n\n  ffmpegTranscodeArgs: new StringArraySetting({\n    category: SettingCategories.Tools,\n    description: `The following are the default arguments added to transcode requests made to ffmpeg (when ffmpeg is available). The following arguments will proceed the command: \"-loglevel error -threads T -i INPUT_FILE_PATH\" (where T is replaced by ~half the available CPU threads, and INPUT_FILE_PATH is the full native pathname to the source video). The following arguments will follow the arguments in this setting: \"-b:v VIDEO_BITRATE_KBPS OUTPUT_FILE_PATH\".\\nCAUTION: this is an advanced setting. Editing this may cause videos that require transcoding to not be imported, or not be viewable on all browsers and platforms. See <https://forum.photostructure.com/t/hardware-accelerated-encoding-transcoding/166> for more details.`,\n    defaultValue: [\n      \"-c:a\",\n      \"aac\",\n      \"-c:v\",\n      \"libx264\",\n      // pix_fmt and profile are required by firefox (!!)\n      \"-pix_fmt\",\n      \"yuv420p\",\n      \"-profile:v\",\n      \"high\"\n    ]\n  }),\n\n  heifConvertPath: new StringSetting({\n    category: SettingCategories.Tools,\n    description: `This should be the absolute, native path to the \"heif-convert\" binary on this system. If this is set to \"heif-convert\", PhotoStructure will search your $PATH. See <https://photostructure.com/getting-started/heif-support/>.`,\n    defaultValue: \"heif-convert\"\n  }),\n\n  powerShellArgs: new StringArraySetting({\n    category: SettingCategories.Tools,\n    description: `The following are the default arguments added to spin up PowerShell on Windows devices.\\nSee <https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_exe?view=powershell-5.1> for all arguments that PowerShell.exe accepts.\\nSee <https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-5.1> for a description of Bypass.\\nSee <https://forum.photostructure.com/t/eliminate-powershell-profile-and-execution-policy-related-errors/184> for more details about why this needs to be configurable.\\n(Versions prior to v1.0.0 only specified \"-NoLogo\").`,\n    defaultValue: [\"-NoLogo\", \"-NoProfile\", \"-ExecutionPolicy\", \"Bypass\"]\n  }),\n\n  powerShellCulture: new StringSetting({\n    category: SettingCategories.Tools,\n    description:\n      \"If set to a non-blank value, PhotoStructure on Windows machines will set PowerShell's `[System.Threading.Thread]::CurrentThread.CurrentCulture` to this value. This allows PhotoStructure to parse PowerShell output reliably.\",\n    defaultValue: () => \"en-US\"\n  }),\n\n  toolPaths: new StringArraySetting({\n    category: SettingCategories.Tools,\n    description: `These paths are appended to the PATH to ensure PhotoStructure can find and run external tools like ffmpeg. Use your operating system's separator to separate paths (\":\" for mac and linux, \";\" for windows).`,\n    defaultValue: () =>\n      (isEnvTrue(\"SETTINGS_IO_TEST\")\n        ? DefaultPosixPaths\n        : DefaultPaths) as string[]\n  }),\n\n  vlcPath: new StringSetting({\n    category: SettingCategories.Tools,\n    description: `This should be the absolute, native path to the \"vlc\" binary on this system. If this is set to \"vlc\", PhotoStructure will search your $PATH.`,\n    defaultValue: \"vlc\"\n  }),\n\n  //\n  // Electron\n  //\n\n  openAtLogin: new BooleanSetting({\n    category: SettingCategories.Desktops,\n    description:\n      \"Set to true to have PhotoStructure start automatically on login. Only supported on PhotoStructure for Desktops on macOS and Windows 10.\",\n    defaultValue: false,\n    advanced: () => !isElectron\n  }),\n\n  updateChannel: new StringEnumSetting({\n    category: SettingCategories.Desktops,\n    description:\n      'TL:DR; keep this on \"latest.\" This setting only applies to PhotoStructure for Desktops, and controls which builds of PhotoStructure you are eligible to automatically update to. Please note that \"alpha\" builds may not even launch, and \"beta\" builds have not been thoroughly tested. Please only consider changing this if customer support asks you to, and that you have recent backups of your system.',\n    defaultValue: () => channel(),\n    validValues: [\"alpha\", \"beta\", \"latest\"]\n  }),\n\n  updateOnLaunch: new BooleanSetting({\n    category: SettingCategories.Desktops,\n    description:\n      \"If true, PhotoStructure will check for updates automatically on launch.\",\n    defaultValue: true\n  }),\n\n  updateCheckMinutes: new IntegerSetting({\n    category: SettingCategories.Desktops,\n    description:\n      \"While running, PhotoStructure will check periodically for updates. The default is daily.\",\n    defaultValue: 60 * 24\n  }),\n\n  autoHideMenuBar: new BooleanSetting({\n    category: SettingCategories.Desktops,\n    description:\n      \"If true, PhotoStructure for Desktops on Windows and Linux will auto hide the menu bar unless the Alt key is pressed.\",\n    defaultValue: false\n  }),\n\n  email: new MaybeStringSetting({\n    category: SettingCategories.Reporting,\n    description:\n      \"If set, this email will be used for license subscriptions and added to error reports, so we can contact you to help debug the issue. It is not required. Setting a value here does not subscribe you to any marketing emails.\",\n    exampleValue: () => \"email@example.com\",\n    advanced: () => false\n  }),\n\n  reportErrors: new BooleanSetting({\n    category: SettingCategories.Reporting,\n    description:\n      \"If true, PhotoStructure will send crash reports when it encounters errors. Crash reports may include the path to the file that caused an error, system metadata, and recent log messages.\",\n    defaultValue: true,\n    advanced: () => false\n  }),\n\n  maxErrorsPerDay: new IntegerSetting({\n    category: SettingCategories.Reporting,\n    description:\n      \"Set this to zero to remove all bugs in PhotoStructure.\\nHUR HUR #DADJOKE\\nIf your system generates more than this number of errors in the course of a day, the subsequent error reports will not be reported.\",\n    defaultValue: 3\n  }),\n\n  //\n  // WEB\n  //\n\n  minStreamCorrPct: new BoundedIntegerSetting({\n    category: SettingCategories.Web,\n    description: `Streams (shown on the asset page) are coalesced when the dice coefficient of their contents are greater than this value. A value of 100 requires streams to match exactly. A value of ~50 allows streams with a couple differences to be considered the \"same\" stream.`,\n    defaultValue: () => 50,\n    max: 100,\n    min: 1\n  }),\n\n  hiddenHomeTags: new StringArraySetting({\n    category: SettingCategories.Web,\n    description: `The given root tags will be omitted from the home page. (Valid values include \"When\", \"Camera\", \"Lens\", \"Type\", and \"Keyword\").`,\n    defaultValue: () => [\"Type\"]\n  }),\n\n  placeholderThumbs: new BooleanSetting({\n    category: SettingCategories.Web,\n    description:\n      \"Render missing asset previews as placeholder images (only useful for customer support).\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  cspReportOnly: new BooleanSetting({\n    category: SettingCategories.Web,\n    description:\n      \"Only report CSP violations. See <https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP>.\",\n    defaultValue: () => false\n  }),\n\n  cspDirective: new MaybeStringSetting({\n    category: SettingCategories.Web,\n    description:\n      \"If you're seeing CSP errors with older browsers, add your externally-available base URL to this setting, and it will be appended to the CSP directives. See <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src>.\",\n    exampleValue: () => \"https://myphotos.example.com\"\n  }),\n\n  // TODO:\n\n  // sessionTimeoutHours: new BoundedIntegerSetting({\n  //   category: SettingCategories.Web,\n  //   description:\n  //     \"How long should unused HTTP sessions exist before requiring visitors to log back in? This defaults to 180 days, just to maximize convenience.\",\n  //   defaultValue: 24 * 30 * 6,\n  //   max: 24 * 365,\n  //   min: 1\n  // }),\n\n  //\n  // Sync\n  //\n\n  readdirCacheSeconds: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"readdir() can take a long time over slow network shares and when directories are very large. This setting controls how long to cache readdir results that are slow (which take >= .5 seconds). Set to 0 to disable readdir() caching.\",\n    defaultValue: 300\n  }),\n\n  verifyFileCopies: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should PhotoStructure verify all file copies by comparing SHAs of the source and destination? This shouldn't be necessary on most OSes and filesystems, and slows down library imports.`,\n    defaultValue: true\n  }),\n\n  assetSubdirectoryDatestampFormat: new StringSetting({\n    category: SettingCategories.Sync,\n    envAliases: [\"PS_ASSET_SUBDIR_FORMAT\"],\n    description: `If you chose to copy assets into your library, they will be copied into <originals directory>/<result of this pattern>/<original imagename>.\\n- See the originalsDir system setting for what your <originals directory> is (it defaults to your library root directory).\\n- Please encode this path with forward-slashes, even if you're on Windows.\\n- If you want to add a static path, escape the pathname with single quotes (like \"'photos'/y/MM/dd\").\\n- This will always be interpreted as a relative path from your PhotoStructure library.\\n- See <https://moment.github.io/luxon/docs/class/src/datetime.js~DateTime.html#instance-method-toFormat> and <https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens>.`,\n    defaultValue: \"y/y-MM-dd\"\n  }),\n\n  transcodeVideos: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should videos that are not in a browser-supported format be transcoded during import? Note that this is a plus-only feature. FFmpeg or VLC must be installed. Note that this *dramatically* slows down imports, and *dramatically* increases the disk space your library will need to use, but allows you to see videos that aren't directly supported by your browser. If this is set to false, your browser will only render videos directly supported by your OS.`,\n    defaultValue: true\n  }),\n\n  transcodeBitrateQVGA: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"What max bitrate should PhotoStructure encode QVGA (320 \u00D7 240) videos? Videos with resolutions between QVGA and UHD will use an interpolated value between these two settings, and will not exceed the encoded bitrate of the original video. This value is in kilobytes per second.\",\n    defaultValue: 800\n  }),\n\n  transcodeBitrateUHD: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"What max bitrate should PhotoStructure encode UHD (3840\u2009\u00D7\u20092160) videos? Videos with resolutions between QVGA and UHD will use an interpolated value between these two settings, and will not exceed the encoded bitrate of the original video. This value is in kilobytes per second.\",\n    defaultValue: 18_000\n  }),\n\n  doNotTranscodeMimetypes: new StringArraySetting({\n    category: SettingCategories.Sync,\n    description: `Videos are transcoded when the \"transcodeVideos\" is set to true and is not one of the following mimetypes. See https://www.iana.org/assignments/media-types/media-types.xhtml#video for a complete list. If you are setting this via an environment variable, you can separate the values either like a PATH (like \"video/quicktime:video/mp4\") or use JSON encoding (like \"['video/quicktime','video/mp4']\").`,\n    defaultValue: () => [\n      \"video/quicktime\",\n      \"video/mp4\",\n      \"video/mpv\",\n      \"video/mp2t\"\n    ]\n  }),\n\n  doNotTranscodeVideoCodecs: new StringArraySetting({\n    category: SettingCategories.Sync,\n    description: `Videos are transcoded when the \"transcodeVideos\" is set to true and is not one of the following video codecs. The video codec may be stored in the \"VideoCodec\", \"CompressorID\", or \"CompressorName\" tags.`,\n    defaultValue: () => [\"avc1\"] // CompressorID: \"hvc1\" is HEVC.\n  }),\n\n  doNotTranscodeAudioCodecs: new StringArraySetting({\n    category: SettingCategories.Sync,\n    description: `Videos are transcoded when the \"transcodeVideos\" is set to true and is not one of the following audio codecs. The audio codec is stored in the \"AudioCodec\" tag.`,\n    defaultValue: () => [\"mp4a\", \"sowt\"]\n  }),\n\n  statTimeoutSeconds: new BoundedIntegerSetting({\n    category: SettingCategories.Sync,\n    description: `Filesystem traversal can be dangerous business with scratched CDROMs and old busted hard drives. To prevent PhotoStructure from getting \"stuck\" when trying to read these devices, it will timeout directory iteration if reading a directory entry exceeds this value. The default of 30 seconds should cover most issues with spun-down hard drives and NAS/WAN latency.`,\n    defaultValue: 30,\n    min: 1,\n    max: 300\n  }),\n\n  startPaused: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"Should processing be paused by default when PhotoStructure starts? You'll have the manually resume processing via the system tray or nav menu.\",\n    defaultValue: false\n  }),\n\n  syncIntervalHours: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"This value controls both how often the sync process discovers new or changed files for any given volume.\\nNote that this value is the duration between the last completion time and when the next sync should be scheduled.\\nWARNING: Setting this value to a small value will mean PhotoStructure is constantly scanning your disks, which will add wear and tear and possibly reduce the lifespan of your storage media.\\nNote that setting this to a zero or negative value will disable automatic scheduling of the sync process.\",\n    defaultValue: 24\n  }),\n\n  rebuild: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When set, all files in your library will be re-imported (caution: slow!).\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  forceSync: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When set, all files will be visited, even if the asset seems in sync with the filesystem.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  skipModelUpdates: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: \"When set, skip any pending library database updates.\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  exitWhenDone: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"When set, the sync process will exit after jobs are completed (used internally and for tests).\",\n    defaultValue: false,\n    transient: true\n  }),\n\n  matchSidecarsCaseInsensitively: new BooleanSetting({\n    category: SettingCategories.Sidecars,\n    description: `If set to true, PhotoStructure will look for sidecar files that match file basenames (with or without the file extension), regardless of case (for example: \"IMAGE.XMP\" will be a sidecar for \"image.jpg\").\\nIf set to false, sidecars must match case (so only \"image.jpg.xmp\" and \"image.xmp\" will match for \"image.jpg\").\\nThis defaults to false just to be conservative, but true should be fine in normal cases.`,\n    defaultValue: false\n  }),\n\n  defaultSidecarType: new StringEnumSetting({\n    category: SettingCategories.Sidecars,\n    description:\n      \"What type of sidecar file do you want to generate for non-destructive edits?\",\n    defaultValue: \"XMP\",\n    validValues: SidecarExts\n  }),\n\n  writeMetadataToSidecarsIfImage: new BooleanSetting({\n    category: SettingCategories.Sidecars,\n    description: `If set to true, PhotoStructure will write metadata changes made to images into sidecars. If set to false, PhotoStructure will overwrite original images with metadata changes.`,\n    defaultValue: true\n  }),\n\n  writeMetadataToSidecarsIfVideo: new BooleanSetting({\n    category: SettingCategories.Sidecars,\n    description: `If set to true, PhotoStructure will write metadata changes made to videos into sidecars. If set to false, PhotoStructure will overwrite original videos with metadata changes. This defaults to false, as most software does not use sidecars except for images.`,\n    defaultValue: false\n  }),\n\n  overwriteOriginal: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should changes made through the UI, like rotations, captions, and keywords, overwrite the original file? This is potentially dangerous, as your original may be lost if the disk has errors, or there are issues in rewriting the file contents. If this is set to false, the original file will be retained in the same directory. \"image.jpg\" will be stored as \"image_original.jpg\".`,\n    defaultValue: false\n  }),\n\n  fuzzyDateParsing: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `When enabled, PhotoStructure will first attempt to parse datetime strings with strict ISO-compliant parsers, and then use additional, \"fuzzy\" parsers. When disabled, only ISO-compliant parsers are used.`,\n    defaultValue: true\n  }),\n\n  fuzzyYearParsing: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `When enabled, PhotoStructure will use directories starting with a number that looks year-like (four digits, 1826-the present) to infer the captured-at time, if all other date parsers have failed. Note that setting this to true \"forces\" the \"fuzzyDateParsing\" setting to be true.\\nTo elaborate: PhotoStructure first looks for metadata with a date, then looks for an ISO-compliant YMD timestamp in the filename or path, and then, if \"fuzzyDateParsing\" or this setting is enabled, a YMD or YM datestamp, and then finally, if this setting is enabled, it looks for a directory that begins with a number that is between 1826-2020.`,\n    defaultValue: false\n  }),\n\n  minValidYear: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description: `If PhotoStructure encounters a year that is less than this value, it will consider it invalid and look elsewhere for dates. The default value, 1826, is the first year a photograph was captured, as per <https://en.wikipedia.org/wiki/History_of_photography>. If you have paintings or other imagery from before this time, you'll want to make this value less than the earliest image in your library.`,\n    defaultValue: 1826\n  }),\n\n  useStatToInferDates: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `When enabled, and the \"captured-at\" time isn't found in metadata, PhotoStructure will also look for the captured-at datetime encoded in the file \"birthtime\" (on Windows), or the lesser value of \"mtime\" and \"ctime\" (on macOS and Linux). Note that these values are not very reliable, as file transfers and backups frequently don't retain these values correctly.`,\n    defaultValue: true\n  }),\n\n  usePathsToInferDates: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `When enabled, and the \"captured-at\" time isn't found in metadata, PhotoStructure will also look for the captured-at datetime encoded in file paths.`,\n    defaultValue: true\n  }),\n\n  useLibraryPathsToInferDates: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `When enabled, and the \"captured-at\" time isn't found in metadata, PhotoStructure will also look for the captured-at datetime encoded in file paths *for files that are in your PhotoStructure library. This defaults to false, as prior versions of PhotoStructure may have placed files into incorrect datestamped directories.`,\n    defaultValue: false\n  }),\n\n  maxDuplicatePathElements: new IntegerSetting({\n    category: SettingCategories.Sync,\n    description:\n      \"How many times can a given path element exist in a directory before it is considered within an infinite filesystem loop, and should be skipped from import?\",\n    defaultValue: 7\n  }),\n\n  skipAssetFileUpdates: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should outdated AssetFiles be ignored on startup? (Only used for tests).`,\n    defaultValue: false,\n    transient: true\n  }),\n\n  skipAssetUpdates: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should outdated Assets be ignored on startup? (Only used for tests).`,\n    defaultValue: false,\n    transient: true\n  }),\n\n  resyncAssetOnVisit: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should Assets be automatically re-synchronized whenever their info panel is viewed? This can make sure Assets are in-sync with the filesystem, but this can slow down current imports, and add load to slower computers. This defaults to true only if the current machine has >= 8 CPUs.`,\n    defaultValue: () => (isTest() ? true : cpus().length >= 8)\n  }),\n\n  excludeNoMediaAssetsOnRebuild: new BooleanSetting({\n    category: SettingCategories.Sync,\n    description: `Should previously-imported assets that are found to have *any* files in NoMedia directories be excluded from your library?`,\n    defaultValue: () => true\n  }),\n\n  // TODO: noMediaAssetAction (hide in library, exclude from library, trash from filesystem)\n\n  //\n  // Deduping\n  //\n\n  strictDeduping: new BooleanSetting({\n    category: SettingCategories.Deduping,\n    description: `How strict should PhotoStructure de-duplicate files? If this is false, we consider files to be equivalent if sufficient metadata matches (even if the image hash is different). If this is true, we will always compare image hashes. NOTE: This will most likely cause RAW and JPEG pairs to not always merge to the same asset, especially if your camera uses extensive computational imagery. ALSO NOTE: If this is true, \"useImageHashes\" will be forced to true.`,\n    defaultValue: false\n  }),\n\n  useImageHashes: new BooleanSetting({\n    category: SettingCategories.Deduping,\n    description: `Building image hashes slows down imports, but supports more robust asset merging heuristics, and allows for dominant color tagging and browsing. If you set this from false to true, and you'd previously imported new assets, you may want to rebuild your library to re-aggregate your assets.`,\n    defaultValue: true\n  }),\n\n  includeSharpDominantColor: new BooleanSetting({\n    category: SettingCategories.Deduping,\n    description: `PhotoStructure's image library, sharp, computes the dominant color using a 4096-bin 3D histogram. This doubles image hashing time, but the most-dominant color might be more accurate.`,\n    defaultValue: false\n  }),\n\n  minExposureSettingsCoeffPct: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description:\n      \"This is the minimum similarity coefficient between exposure setting values two images must be to be considered equivalent. Many cameras actually report different exposure setting values between JPG and RAW: values within 90% of each other should avoid false-positives.\",\n    defaultValue: () => 90,\n    max: 100,\n    min: 0\n  }),\n\n  minImageCoeffPct: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description:\n      \"This is the minimum image hash similarity coefficient for images to be considered similar, and controls how aggressively images are merged with each other. A higher number requires stronger image similarity. 100 (or 100%) requires exact image correlation, and is not recommended. A value of less than 50% is fairly low image correlation, and can lead to false positives.\",\n    defaultValue: () => 75,\n    max: 100,\n    min: 0\n  }),\n\n  minImageGreyscaleCoeffPct: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description:\n      \"This is the minimum image hash similarity coefficient for greyscale images to be considered similar, and controls how aggressively images are merged with each other. A higher number requires stronger image correlation. 100 (or 100%) requires exact image correlation, and is not recommended. A value of less than 50% is fairly low image correlation, and can lead to false positives.\",\n    defaultValue: () => 93,\n    max: 100,\n    min: 0\n  }),\n\n  minColorCoeffPct: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description:\n      \"This is the minimum similarity coefficient found between dominant image colors, and controls how aggressively images are merged with each other. A higher number requires stronger dominant color correlation. 100 (or 100%) requires exact dominant color correlation. A value of less than 50% indicates fairly low correlation of dominant colors, and can lead to false positives.\",\n    defaultValue: () => 75,\n    max: 100,\n    min: 0\n  }),\n\n  minMeanCoeffPct: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description:\n      \"If the average of image and color similarity coefficients exceeds this score, the image will be considered a match.\",\n    defaultValue: () => 65, // Raw/IMG_20181029_140706.dng needs 65\n    max: 100,\n    min: 0\n  }),\n\n  fuzzyDateImageCoeffWeight: new BoundedFloatSetting({\n    category: SettingCategories.Deduping,\n    description: `Image similar, by default, is somewhat lax to ensure JPG+RAW and downsampled or edited images are matched together. This is OK when dates must match, and the date is exactly correct. When dates are manually set to something \"fuzzy\", with perhaps only the year, month, and day, or is inferred by siblings, we need to be more discriminate with image contents to prevent incorrectly grouping photos from that day into a single asset. This value is multiplied with minImageCorrPct and minColorCorrPct to make them more stringent. For example, by default, the minImageCorrPct is 80%, and when the dates are manually set, and this weight is 1.2, the minImageCorrPct for manually-set-date files will be 90%.`,\n    defaultValue: () => 1.4,\n    max: 2,\n    min: 0.5\n  }),\n\n  greyscaleColorThreshold: new BoundedIntegerSetting({\n    category: SettingCategories.Deduping,\n    description:\n      \"When looking at each pixel in L*a*b* space, a greyscale image is expected to have a* and b* values around 0. If the absolute value of every a* and b* value is under this setting's value, the image will be considered to be greyscale. A value of 0 will force all images to be considered non-greyscale.\",\n    defaultValue: 5,\n    max: 128,\n    min: 0\n  }),\n\n  modeCorrCieDiffWeight: new BoundedFloatSetting({\n    category: SettingCategories.Deduping,\n    description: `Comparing 2 images with N dominant colors requires finding matching color pairs. This weight will be applied to the CIE94 color delta e. Smaller values apply a larger discount to color deltas.`,\n    defaultValue: () => 0.6,\n    max: 2,\n    min: 0\n  }),\n\n  modeCorrIndexDiffWeight: new BoundedFloatSetting({\n    category: SettingCategories.Deduping,\n    description: `Comparing 2 images with N dominant colors requires finding matching color pairs. This weight will be applied to difference between the color indexes. Smaller values apply a larger discount to index differences.`,\n    defaultValue: () => 0.6,\n    max: 2,\n    min: 0\n  }),\n\n  gpsErrorMeters: new IntegerSetting({\n    category: SettingCategories.Deduping,\n    description: `What's the maximum number of meters between GPS fixpoints that should be considered equivalent locations? Note that JPG+RAW pairs from smartphones frequently have different GPS locations due to one being recorded from a rough WiFi fix, and another from aGPS.\\nGPS position error is ~10-100m. Cellular position error is ~500-750m.`,\n    defaultValue: 500\n  }),\n\n  lensMakes: new StringArraySetting({\n    category: SettingCategories.Deduping,\n    description: `Used to match lensId when Google Takeout has stripped metadata.`,\n    defaultValue: () => DefaultLensMakes\n  }),\n\n  variantSortCriteria: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `How should PhotoStructure pick the \"best\" asset file variant for a given asset? You may reorder the default fields. Only \"resolution\", \"fileSize\", \"mtime\", \"schemeIdx\", \"isCover\", \"count\", and \"isBrowserSupported\" are understood: other field names will be ignored. Details about these fields are here: <https://photostructure.com/faq/what-do-you-mean-by-dedupe/#how-does-photostructure-pick-which-file-to-show>.`,\n    defaultValue: [\n      \"resolution\",\n      \"mtime\",\n      \"schemeIdx\",\n      \"isCover\",\n      \"count\",\n      \"isBrowserSupported\",\n      \"fileSize\"\n    ]\n  }),\n\n  variantSortCriteriaPower: new BoundedFloatSetting({\n    category: SettingCategories.Deduping,\n    description: `Larger variant sort criteria, \"resolution\" and \"fileSize\", are scaled to ignore smaller (irrelevant) differences. Scalars are raised to this power to reduce them, so a value of 1 means the criterion is unchanged from the \"raw\" value.`,\n    defaultValue: () => 0.15,\n    max: 1,\n    min: 1e-6\n  }),\n\n  //\n  // Previews\n  //\n\n  jpegQuality: new BoundedIntegerSetting({\n    category: SettingCategories.Previews,\n    description:\n      \"JPEG output quality for previews. Smaller values produce smaller images with lower quality. The default value of 85 strikes a balance that has almost no noticeable compression artifacts, yet still compresses images reasonably well. Values less than ~50-70 can produce noticeable artifacts (depending on the image).\",\n    defaultValue: () => 85,\n    max: 100,\n    min: 10\n  }),\n\n  dcrawEmuArgs: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `What options do you want to pass to dcraw_emu? Note that \"-T -o 1 -j -Z -\" will always be added (as we need TIFF, sRGB, raw pixels send to stdout). The \"-h\" arg will be added if the preview image needed is less than half the resolution of the original.\\nRun \"dcraw_emu\" with no arguments to get usage help.\\n\"-q 1\" sets interpolation quality to \"0\".\\n\"-H 2\" turns on highlight blending.\\n\"-w\" uses the camera-set white balance.\\nNote: changing these values can dramatically (> 10x!) increase the time it takes to render RAW images.`,\n    defaultValue: [\"-q\", \"0\", \"-w\"]\n  }),\n\n  iccProfileMappings: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `Maps an original image profile to a filename stored in the \"icc\" directory. See that directory's _info.md for more information about this settings.`,\n    defaultValue: [\n      \"Display P3:DisplayP3Compat-v2-magic.icc\",\n      \"Adobe RGB:AdobeCompat-v2.icc\"\n    ]\n  }),\n\n  squareThumbStrategy: new StringEnumSetting({\n    category: SettingCategories.Previews,\n    description:\n      'When PhotoStructure crops images and videos to square thumbnails, it needs to crop non-square images to a square. The default, \"attention,\" focuses on faces and higher image energy, but is more expensive than simply cropping to the center of the image (which is faster, but will mean less-nice cropping, where faces are chopped in half). More details are available here: <https://sharp.pixelplumbing.com/api-resize>.',\n    defaultValue: \"attention\",\n    validValues: [\"center\", \"entropy\", \"attention\"]\n  }),\n\n  videoFrameAtSec: new FloatSetting({\n    category: SettingCategories.Previews,\n    description: `When capturing a frame from videos for thumbnails, how many seconds should be passed over before capturing a frame? A value of 0 means capture from the start of the video. Frequently, though, videos start out of focus, so we default to 1 for better frame clarity.\\nNote that if a video is shorter than this value, the frame will be captured from the middle of the video.`,\n    defaultValue: 1.5\n  }),\n\n  // TODO: add this to the settings page:\n  sharpen: new BooleanSetting({\n    category: SettingCategories.Previews,\n    description: `Should previews be sharpened? This can make the images \"pop\" a bit more, but almost doubles the time it takes to make the thumbnails.`,\n    defaultValue: false\n  }),\n\n  progressive: new BooleanSetting({\n    category: SettingCategories.Previews,\n    description: `Should preview JPEGs be progressively encoded? If set, thumbnails will take ~15% longer to generate, but FHD/QHD/UHD previews will be smaller.`,\n    defaultValue: true\n  }),\n\n  // TODO: add this to the settings page:\n  previewResolutions: new StringEnumsSetting({\n    category: SettingCategories.Previews,\n    description:\n      \"This controls the resolutions that PhotoStructure creates for every asset. Note that resolutions will be skipped if there already is a preview value with 2.5x the megapixels, so even though there are a lot of sizes here, you'll only see 3-4 images on your disk per asset.\",\n    defaultValue: diff(FitSizeValues, [\"uhd8k\", \"uhd5k\", \"qqvga\"]),\n    validValues: FitSizeValues\n  }),\n\n  embeddedPreviews: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `For larger source images that are greater than 15MP, what embedded image preview tags should be used when present? Using these embedded images speeds up image preview generation, but if the embedded image doesn't match the full-sized image, the image preview will be incorrect.\\nOrder matters here: the first embedded image with sufficient resolution will be used.\\nSet this to an empty array to disable using embedded previews.`,\n    defaultValue: [\"PreviewImage\", \"PreviewTIFF\", \"JpgFromRaw\"]\n  }),\n\n  embeddedThumbnails: new StringArraySetting({\n    category: SettingCategories.Previews,\n    description: `Should embedded image thumbnails be used when available? This speeds up image hashing, but if the embedded image thumbnail doesn't match the full-sized image, the image hash will be incorrect.\\nOrder matters here: the first embedded image with sufficient resolution will be used.\\nSet this to an empty array to disable using embedded previews.`,\n    defaultValue: [\"ThumbnailImage\", \"ThumbnailTIFF\"]\n  }),\n\n  skipPreviews: new BooleanSetting({\n    category: SettingCategories.Previews,\n    description: `No previews will be built. The UI will be broken if this is set.`,\n    defaultValue: false\n  }),\n\n  //\n  // Filters\n  //\n\n  requireMakeModel: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"Normally PhotoStructure requires images to have EXIF tags for Make and Model. This prevents unwanted preview images from other photo apps and screenshots from being imported. If you have images you want in your library that don't have these tags, set this to false. Note that this is ignored for video files, as those files seldom have Make and Model set (and would prevent most video files from being imported).\",\n    defaultValue: false\n  }),\n\n  minImageDimension: new IntegerSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum number of pixels an image's dimensions must meet or exceed to be imported? Note that this value is applied to both the height and width of the image. The default comes from the VGA standard of 640x480.\",\n    defaultValue: 480\n  }),\n\n  minVideoDimension: new IntegerSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum number of pixels a video's dimensions must meet or exceed to be imported? Note that this value is applied to both the height and width of the video. The default comes from the QVGA standard of 320x240.\",\n    defaultValue: 240\n  }),\n\n  minVideoDurationSec: new FloatSetting({\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum number of seconds for a video to be imported?\",\n    defaultValue: 2\n  }),\n\n  minAssetFileSizeBytes: new IntegerSetting({\n    envAliases: [\n      \"PS_MIN_ASSET_SIZE_BYTES\",\n      \"PS_MIN_ASSET_SIZE\",\n      \"PS_MIN_FILE_SIZE_BYTES\"\n    ],\n    category: SettingCategories.Filters,\n    description:\n      \"What's the minimum photo or video size you want imported into your library? (This can prevent small GIFs and screenshots from being imported).\",\n    defaultValue: 50 * KB\n  }),\n\n  maxAssetFileSizeBytes: new IntegerSetting({\n    envAliases: [\n      \"PS_MAX_ASSET_SIZE_BYTES\",\n      \"PS_MAX_ASSET_SIZE\",\n      \"PS_MAX_FILE_SIZE_BYTES\"\n    ],\n    category: SettingCategories.Filters,\n    description:\n      \"What's the maximum photo or video size you want imported into your library? (This can prevent movies from being pulled into and filling up your library).\",\n    defaultValue: 0.5 * GB\n  }),\n\n  // TODO: add this to the settings page:\n  validateJpegImages: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description: `Should JPEG photos be validated before importing? If a JPEG has any decoding errors, and this setting is true, that file will not be imported into your library. Enabling this feature slows down imports.`,\n    defaultValue: true\n    // advanced: () => false\n  }),\n\n  // TODO: add this to the settings page:\n  validateRawImages: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description: `Should raw-format images (like NEF, CR2, ARW, and ORF) be validated before importing? If an image has any decoding errors, and this setting is true, that file will not be imported into your library. Enabling this feature slows down imports.`,\n    defaultValue: true\n    // advanced: () => false\n  }),\n\n  // TODO: add this to the settings page:\n  validateVideos: new BooleanSetting({\n    category: SettingCategories.Filters,\n    description: `Should videos be validated before importing? If a video has any decoding errors, and this setting is true, that file will not be imported into your library. Enabling this feature slows down imports, as videos must be fully decoded (or \"played\") to be validated. Only ffmpeg currently supports video validation; if you use VLC, this setting is ignored.`,\n    defaultValue: () => (isTest() ? true : false) // < tests want to validate this setting\n    // advanced: () => false\n  }),\n\n  validationErrorBlocklist: new StringArraySetting({\n    category: SettingCategories.Filters,\n    description: `If any of the following patterns match a validation error found in a photo or video, the file will be considered corrupt and not be imported into your library.\\nNote the patterns are case-insensitive, will be converted into a regular expression, and only need to partially match the error message, so, for example, a value of \"caution\" will ignore any error message that contains the string \"caution\".`,\n    defaultValue: () => [\n      \"Cannot determine format of input stream\",\n      \"corrupt\",\n      \"error\",\n      \"failed\",\n      \"invalid\",\n      \"not a .+ file\", // Not a JPEG file\n      \"nothing was written into output file\",\n      \"partial file\",\n      \"Premature end of .+ file\" // Premature end of JPEG file\n    ]\n  }),\n\n  //\n  // Tagging\n  //\n\n  tagCamera: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with cameras' make and model?`,\n    defaultValue: true\n  }),\n\n  tagLens: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with lens' make and model?`,\n    defaultValue: true\n  }),\n\n  tagFullLensModel: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should PhotoStructure tag assets with the full lens model (like \"Canon EF-M 15-45mm f/3.5-6.3 IS STM\") or a just the lens information (\"15-45mm f/3.5-6.3\")? (If you change this value, you'll need to \"Rebuild\" your library to make the setting take effect).`,\n    defaultValue: true\n  }),\n\n  tagYMD: new StringEnumSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with \"When > Year\" (the \"y\" option), or \"When > Year > Month\" (the \"ym\" option), or \"When > Year > Month > Day\" (the \"ymd\" option)? Setting this to \"\" will disable date tagging.`,\n    defaultValue: \"ym\",\n    validValues: [\"y\", \"ym\", \"ymd\", \"\"]\n  }),\n\n  tagDateFromStat: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should PhotoStructure tag assets with a date if the captured at time was only found in filesystem metadata? Filesystem metadata is not as reliable as EXIF metadata, as it can be changed arbitrarily when files are backed up.`,\n    defaultValue: () => (isTest() ? false : true)\n  }),\n\n  tagKeywordsFromPath: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with keywords extracted from file pathnames?`,\n    defaultValue: true\n  }),\n\n  tagKeywordsFromMetadata: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should assets be tagged with keywords extracted from file metadata, as well as sidecar metadata?`,\n    defaultValue: true\n  }),\n\n  keywordDelimiters: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `PhotoStructure splits apart keywords, by default, when they are delimited by a comma or semicolon. For example, \"car, blue, tree\" will be interpreted as having the keywords \"car\", \"blue\", and \"tree\". After changing this value, you must force-resync your library for the changes to take affect.`,\n    defaultValue: \",;\"\n  }),\n\n  keywordPathSeparators: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `PhotoStructure interprets keywords as hierarchical if a path separator character is found in a keyword. This allows for tags like \"Family/Einstein/Albert\", \"Flora|Fruit|Orange\", \"Objects\u2283Tools\u2283Hammer\", or \"Fauna>Oceanic>Pelican\". By default, these separators are the forward-slash, vertical-bar, and greater-than characters. If you don't want to interpret keywords as hierarchical, change this value to an empty string (\"\"). After changing this value, you must force-resync your entire library for the changes to take affect.`,\n    defaultValue: \"/|>\u2283\" // 20200307: thought about and discarded the idea of including \"\u203A\" and \"\u00BB\". \"\u2E27\" isn't in iOS. 20201201: Also deleted \"\u227B\".\n  }),\n\n  tagFileType: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    envAliases: [\"PS_TAG_TYPE\"],\n    description: `Should assets be tagged with their file type (like \"Type/Image/JPEG\")?`,\n    defaultValue: true\n  }),\n\n  tagWhoSynonyms: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List hierarchical tags that PhotoStructure should interpret to be face names. Digicam uses \"People\". This is matched case-insensitively.`,\n    defaultValue: () => [\"People\", \"Face\", \"Faces\"]\n  }),\n\n  tagJsonFaces: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Google Takeout provides .json sidecars that may contain the names of the people (or pets) found in the image. Should PhotoStructure import these tags under \"Who\"?.`,\n    defaultValue: true\n  }),\n\n  tagFaceRegions: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Picasa and other software supports embedding face names within \"RegionInfo\" metadata. If this setting is enabled, PhotoStructure will import these tags under \"Who\".`,\n    defaultValue: true\n  }),\n\n  tagWhoNames: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `This is a list of tags that will be examined for strings or string arrays. All values associated to these fields will be interpreted as names. Note that \"dotted notation\" is supported.\\nSet this value to an empty array to disable scanning for person names.`,\n    defaultValue: [\n      \"People\",\n      \"PersonInImage\",\n      \"PersonInImageWDetails.PersonName\",\n      \"PersonInImageName\"\n    ]\n  }),\n\n  tagNamesFormatter: new StringEnumSetting({\n    category: SettingCategories.Tagging,\n    description: `How should PhotoStructure format the \"Who\" tags for assets whose files are tagged with \"people\" strings?\\n\"as-is\" will tag names directly to \"Who\", so, \"Who/Albert Einstein\".\\n\"family/given\" will tag \"Who/Einstein/Albert\" (for regions that provide given names first). The default is \"as-is,\" because discerning given and family names aren't reliably inferable.\\nSee <https://en.wikipedia.org/wiki/Personal_name#Name_order>.`,\n    defaultValue: \"as-is\",\n    validValues: [\"as-is\", \"family/given\"]\n  }),\n\n  tagNamesDefaultFamily: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `If a name is missing a family name, if this value is not blank, it will be provided as a default. If this value is blank, the name tag will be Who/given. Note that this setting is only used if \"tagNamesFormatter\" is set to \"family/given\".`,\n    defaultValue: \"-\"\n  }),\n\n  tagNamesCapitalizedAsFamily: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Assume uppercased names are family names (this is common practice in geneology).`,\n    defaultValue: true\n  }),\n\n  tagNamesOrder: new StringEnumSetting({\n    category: SettingCategories.Tagging,\n    description: `How should PhotoStructure parse people's names? Note that this setting is only used if \"tagNamesFormatter\" is set to \"family/given\". See <https://en.wikipedia.org/wiki/Personal_name#Name_order>.`,\n    defaultValue: \"western\",\n    validValues: [\"western\", \"eastern\"]\n  }),\n\n  tagNamesSurnamePrefixes: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List all family name prefixes to be considered part of the family name. These are matched case-insensitively. This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: () => [\n      \"A\",\n      \"D\u2019\",\n      \"Da\",\n      \"De la\",\n      \"De las\",\n      \"De\",\n      \"Del\",\n      \"Della\",\n      \"Den\",\n      \"Des\",\n      \"Di\",\n      \"Du\",\n      \"La\",\n      \"Las\",\n      \"Le\",\n      \"Li\",\n      \"Lo\",\n      \"Mc\",\n      \"Mac\",\n      \"op de\",\n      \"ten\",\n      \"ter\",\n      \"Van \u2018t\",\n      \"van der\",\n      \"van\",\n      \"von der\",\n      \"von\",\n      \"z\",\n      \"zu\"\n    ]\n  }),\n\n  tagNamesSurnames: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List all family names you expect in tags that are not single words that are found at the end of a tagged name. Hyphenated family names (like \"Ocasio-Cortez\") do not need to be listed here: only compound family names, and if your language doesn't separate family names with whitespace. In the latter case, either include all family names, or include all givenNames (whatever's easier for you). This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: () => []\n  }),\n\n  tagNamesGiven: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `List all given names you expect in tags that are not single words. Hyphenated given names (like \"Rose-Ann\") do not need to be listed here. If your language doesn't separate family names and given names with whitespace, either include all given names, or include all familyNames (whatever's easier for you). This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: () => []\n  }),\n\n  tagNamesFamilySurrounds: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `This setting contains pairs of characters. When name portions are surrounded by these pairs, the contents will be added as a family name. As an example, if you use the default \"()\", then \"Michelle LaVaughn (Robinson) Obama\" will be name tagged with both \"Who/Robinson/Michelle LaVaughn\" and \"Who/Obama/Michell LaVaugn\". This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: [\"()\"]\n  }),\n\n  tagNamesGivenSurrounds: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `This setting contains pairs of characters. When name portions are surrounded by these pairs, the contents will be added to the end of the given name with the surrounds retained. As an example, if you use the defaults of \"[]\" and double-quotes, then \"Joe \"Joey\" Smith\" will be name tagged with Who/Smith/Joe \"Joey\". This setting is used by the \"tagNamesFormatter\" if it is set to \"family/given\".`,\n    defaultValue: [\"[]\", '\"\"']\n  }),\n\n  tagNamesLexical: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Assume any name with a comma is in \"lexical name order\", which is always \"lastname, given name(s)\". If the given name is found to be \"sr.\", \"senior\", \"jr.\", or \"junior\", the name will be considered to be in western order ($givenNames $familyName, $modifier), and the $modifier will be added to the $givenNames. If this is set to false, commas are ignored.`,\n    defaultValue: true\n  }),\n\n  excludedRootTags: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `Keywords starting with the given roots will be omitted from your PhotoStructure library.`,\n    defaultValue: () => [\"http:\", \"https:\"]\n  }),\n\n  tagDisplayNameFS: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `What should PhotoStructure call the \"root\" tag for browsing by filesystem paths? Note that this value is only for the UI, and will update the \"_displayName\" of the /fs/ tag: this value won't change the URL path from be \"/tag/fs/.../\". Reasonable options that have been suggested include \"Folder\", \"Directory\", \"Drive\", \"File\", \"Path\", \"Volume\", or \"Computer\".`,\n    defaultValue: \"Folder\"\n  }),\n\n  tagAlbums: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `Should PhotoStructure look for $tagJsonAlbumFilename (by default, \"metadata.json\") files in the same directory as asset files for album titles?`,\n    defaultValue: true\n  }),\n\n  tagAlbumFilenames: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `If you have enabled \"tagJsonAlbums\", what's the name of the file that PhotoStructure should look for with album metadata? This can be JSON, XMP, MIE, or EXIF encoded.`,\n    defaultValue: [\"metadata.json\"]\n  }),\n\n  tagAlbumTitle: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `If you have enabled \"tagJsonAlbums\", what's the name of the field encoded in the album file? Object hierarchies are separated with a \".\".`,\n    defaultValue: \"albumData.title\"\n  }),\n\n  tagAlbumTitleHierarchies: new BooleanSetting({\n    category: SettingCategories.Tagging,\n    description: `If true, album titles will be split as hierarchical keywords. If false, album titles will not be split, and all albums will be under the \"Albums\" root tag.`,\n    defaultValue: false\n  }),\n\n  tagAlbumDescription: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `If you have enabled \"tagJsonAlbums\", what's the name of the field encoded in the album file? Object hierarchies are separated with a \".\".`,\n    defaultValue: \"albumData.description\"\n  }),\n\n  tagAlbumDate: new StringSetting({\n    category: SettingCategories.Tagging,\n    description: `If you have enabled \"tagJsonAlbums\", what's the name of the field encoded in the album file? Object hierarchies are separated with a \".\".`,\n    defaultValue: \"albumData.date\"\n  }),\n\n  tagAlbumsExcluded: new StringArraySetting({\n    category: SettingCategories.Tagging,\n    description: `For \"metadata.json\" albums, some are automatically generated. If the title or description includes any given string, it will be ignored.`,\n    defaultValue: [\"Album for automatically uploaded content\"]\n  }),\n\n  // TODO:\n  // tagColor: new BooleanSetting({\n  //   name: \"tagColor\",\n  //   key: \"PS_TAG_COLOR\",\n  //   category: SettingCategories.Tagging,\n  //   description: `Should assets be tagged with their dominant color (like \"Color/Yellow\")?`,\n  //   defaultValue: true,\n  //   persisted: true\n  // }),\n\n  //\n  // Subscriptions\n  //\n\n  pickPlanOnWelcome: new BooleanSetting({\n    category: SettingCategories.Subscriptions,\n    description: `If set to true, the welcome page flow will redirect to https://account.photostructure.com/plans to have you pick between \"plus\" and \"lite\". If set to false, the welcome page will continue directly to the settings page with a \"lite\" license. You can still upgrade to a paid plan later from the main menu or the about page, even if this is false.`,\n    defaultValue: true\n  }),\n\n  autoRefreshLicense: new BooleanSetting({\n    category: SettingCategories.Subscriptions,\n    description: `PhotoStructure uses cryptographically signed licenses to locally store your current plan subscription status. These licenses are only valid for the current subscription period, and must be refreshed when your subscription renews or converts from a free trial to a paid subscription. To minimize the hassle of license renewals, PhotoStructure can automatically renew expired licenses in the background.\\nIf the current license has expired and this value is true, PhotoStructure will make one secure POST request to https://account.photostructure.com/ that contains several lossy one-way hashes of current system metadata. We hash all identifying metadata to only 15 characters to alleviate any privacy concerns. If your plan subscription is active, a new license will be added to your library.\\nSet this to false and set the \"reportErrors\" setting to false if you don't want PhotoStructure \"phoning home\" for any reason.\\nNote that if this is disabled, license renewals will require manual intervention: click \"Upgrade\" from the main menu, pick your plan, authenticate, and the license will automatically refresh.`,\n    defaultValue: true\n  }),\n\n  license: new MaybeStringSetting({\n    category: SettingCategories.Subscriptions,\n    description: `Subscription licenses are normally saved automatically into both your library and system configuration directories. This setting just provides users with an alternative way to provide a license, if it's more convenient. Any value provided to this setting will be considered in addition to existing license files when PhotoStructure is trying to find the \"best\" license available.`\n  })\n}\n\nfor (const [k, v] of entries(Settings)) {\n  v._setName(k)\n}\n\n/**\n * Force the given path-separated paths to be the suggested values on the\n * welcome page.\n */\nexport const SuggestedDirsEnvKey = \"SUGGESTED_DIRS\"\n\n// Only exported for testing:\nexport function withDefaultPaths(paths: Maybe<string>): string {\n  const p = (blank(paths) ? \"\" : paths).split(delimiter)\n  if (isWin && blank(_p.env.SYSTEMROOT)) {\n    throw new Error(\"%SYSTEMROOT% is not set\")\n  }\n  p.push(...Settings.toolPaths.valueOrDefault)\n  return uniq(p).filter(notBlank).join(delimiter)\n}\n\nexport const pathWithDefaults = lazy(() => withDefaultPaths(_p.env.PATH))\n\nexport const persistedSettings = lazy(() => {\n  const arr = values(Settings).filter(ea => !ea.transient)\n  return sortBy(arr, s => [\n    s.categoryType === \"system\" ? 0 : 1,\n    SettingCategories.indexOf(s.category),\n    s.advanced,\n    s.name\n  ])\n})\n\nexport const persistedSystemSettings = lazy(() =>\n  persistedSettings().filter(ea => SystemCategories.includes(ea.category))\n)\n\nexport const persistedLibrarySettings = lazy(() =>\n  persistedSettings().filter(ea => LibraryCategories.includes(ea.category))\n)\n", "import { strEnum, StrEnumKeys } from \"./StrEnum\"\n\nexport const FitSizes = strEnum(\n  \"uhd8k\",\n  \"uhd5k\",\n  \"uhd4k\",\n  \"qhd\",\n  \"fhd\",\n  \"hd\",\n  \"wvga\",\n  \"qvga\",\n  \"qqvga\"\n)\nexport type FitSize = StrEnumKeys<typeof FitSizes>\nexport const FitSizeValues = FitSizes.values\n\nexport const SqSizes = strEnum(\"s480\", \"s240\", \"s120\", \"s60\")\nexport type SqSize = StrEnumKeys<typeof SqSizes>\n\nexport const SqWidths = [60, 120, 240, 480]\n\nexport type ImageSizeName = FitSize | SqSize\n", "import { mapNotBlank } from \"./Blank\"\nimport { lazy } from \"./Lazy\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { isNumber, sigFigs, toInt } from \"./Number\"\nimport { strEnum, StrEnumKeys } from \"./StrEnum\"\nimport { replaceAll } from \"./String\"\n\n// these instances are expensive to create, and can be reused for a given\n// locale.\nconst numberFormat = lazy(() => new Intl.NumberFormat())\n\nexport const thousandsSep = lazy(() =>\n  replaceAll(numberFormat().format(1111), \"1\", \"\").charAt(0)\n)\n\nexport const decimalSep = lazy(() =>\n  replaceAll(numberFormat().format(1.1), \"1\", \"\").charAt(0)\n)\n\nexport function fmt(i: number): string {\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat\n  return numberFormat().format(i)\n}\n\n/**\n * Like `Number.toInt`, but accepts `fmt`ed strings by stripping thousands\n * separators before parsing.\n */\nexport function fmtToInt(s: Maybe<string>): Maybe<number> {\n  return mapNotBlank(s, ea => toInt(replaceAll(ea, thousandsSep(), \"\")))\n}\n\n// See https://en.wikipedia.org/wiki/Mebibyte\nexport const KB = 1000\nexport const MB = KB * 1000\nexport const GB = MB * 1000\nexport const TB = GB * 1000\n\nexport const KiB = 1024\nexport const MiB = KiB * 1024\nexport const GiB = MiB * 1024\nexport const TiB = GiB * 1024\n\nconst byteUnits = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\"]\nconst mebiUnits = [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\"]\n\nexport function fmtBytes(bytes: number, sigfigs = 3): string {\n  if (bytes === 0) return \"0\"\n  if (!isNumber(bytes)) return \"-\"\n  const l = Math.floor(Math.log10(bytes))\n  const mag = Math.floor(l / 3)\n  const val = Math.pow(10, mag * 3)\n  const name = byteUnits[mag]\n  return sigFigs(bytes / val, sigfigs) + \" \" + name\n}\n\nexport function fmtMebi(bytes: number, sigfigs = 3): string {\n  const l = Math.floor(Math.log2(bytes))\n  const mag = Math.floor(l / 10)\n  const val = Math.pow(2, mag * 10)\n  const name = mebiUnits[mag]\n  return sigFigs(bytes / val, sigfigs) + \" \" + name\n}\n\nexport const MP = 1e6\n\nexport function megapixels(pixels: number): number {\n  return sigFigs(pixels / MP, 2)\n}\n\nexport const SizeDescriptions = strEnum(\n  \"tiny\",\n  \"small\",\n  \"medium\",\n  \"large\",\n  \"original\"\n)\nexport type SizeDescription = StrEnumKeys<typeof SizeDescriptions>\n\nexport function pixels2size(pixels: number): SizeDescription {\n  return pixels < 320 * 240 // qvga\n    ? \"tiny\"\n    : pixels < 720 * 480 // wvga\n    ? \"small\"\n    : pixels < 1920 * 1080 // fhd\n    ? \"medium\"\n    : \"large\"\n}\n\nexport function plur(\n  i: number,\n  singular: string,\n  plural: string = singular + \"s\"\n) {\n  return fmt(i) + \" \" + (i === 1 ? singular : plural)\n}\n\nexport interface Metric {\n  count: string\n  desc: string\n}\n\nexport function plurMetric(\n  i: number,\n  singular: string,\n  plural: string = singular + \"s\"\n) {\n  return { count: fmt(i), desc: i === 1 ? singular : plural }\n}\n", "import fs from \"fs\"\nimport fse from \"fs-extra\"\nimport _p from \"path\"\nimport { createGzip } from \"zlib\"\nimport { blank, mapNotBlankOr, notBlank } from \"../../fe/Blank\"\nimport { map, mapOr, orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toInt } from \"../../fe/Number\"\nimport { toS } from \"../../fe/toS\"\nimport { first } from \"../Array\"\nimport { resolvedWithin, thenMapOr } from \"../async/Promise\"\nimport { thenOrTimeout } from \"../async/thenOrTimeout\"\nimport { isPosix, isWin } from \"../Platform\"\nimport {\n  ensureSuffix,\n  equalsIgnoreCase,\n  leftPad,\n  spliceCapture,\n  stripPrefix\n} from \"../String\"\nimport { MountpointsTtlMs } from \"../volumes/VolumeTtls\"\nimport { SimpleFile } from \"./SimpleFile\"\nimport { StatTimeoutMs } from \"./StatTimeout\"\nimport { pipelineAsync } from \"./Streams\"\n\nconst posix = _p.posix\n\nexport function posix2native(posixPath: string, hostname?: string): string {\n  if (blank(posixPath)) return posixPath\n  if (_p.sep === posix.sep) return posixPath\n  const prefix = notBlank(hostname) ? _p.sep + _p.sep + hostname + _p.sep : \"\"\n  const split = posixPath.split(posix.sep)\n  if (equalsIgnoreCase(split[0], hostname)) split.unshift()\n  return prefix + split.join(_p.sep)\n}\n\nexport function native2posix(nativePath: string): string {\n  if (blank(nativePath)) return nativePath\n  if (_p.sep === posix.sep) return nativePath\n  return posix.sep === _p.sep\n    ? nativePath\n    : nativePath.split(_p.sep).join(posix.sep)\n}\n\nconst driveRe = /^([A-Z]:)[\\\\/]?(.*)$/i\n\nfunction upcaseDriveLetters(path: string): string {\n  const match = driveRe.exec(path)\n  return match != null ? match[1].toUpperCase() + \"\\\\\" + match[2] : path\n}\n\nexport function resolveSimpleFile(path: string | SimpleFile) {\n  return orElse(path[\"nativePath\"], () => resolve(path.toString()))\n}\n\nexport function resolve(...paths: string[]): string {\n  const path = _p.join(...paths)\n  return _p.resolve(isWin ? upcaseDriveLetters(path) : path)\n}\n\nexport interface ParsedFile {\n  /** \"/home/user/dir\" of \"/home/user/dir/file.txt\" */\n  readonly dir: string\n  /** \"file.txt\" of \"/home/user/dir/file.txt\" */\n  readonly base: string\n  /** \"file\" of \"/home/user/dir/file.txt\" */\n  readonly name: string\n  /** \".txt\" or \".log.gz\" of \"/home/user/dir/file.txt\" */\n  readonly ext: string\n}\n\nexport function parsePosixPath(posixPath: string): ParsedFile {\n  return parseNativePath(posix2native(posixPath))\n}\n\n/** @return \".txt\" or \".log.gz\" of \"/home/user/dir/file.txt\" */\nexport function extname(nativePath: string): string {\n  return parseNativePath(nativePath).ext\n}\n\nconst CompressedExtRE = /(\\.(?:gz|z|7z|xz|bz2))$/i\n\n/**\n * Supports hidden files and extracting \".log.gz\" as the `ext` for \"file.log.gz\"\n */\nexport function parseNativePath(nativePath: string): ParsedFile {\n  const r = spliceCapture(nativePath, CompressedExtRE)\n  const p = _p.parse(orElse(r?.uncaptured, nativePath))\n  return {\n    ...p,\n    ...(r == null\n      ? {}\n      : {\n          ext: p.ext + r.captured,\n          base: p.base + r.captured\n        })\n  }\n}\n\nexport function containedBy(\n  childPosixPath: Maybe<string>,\n  parentPosixPath: Maybe<string>\n): boolean {\n  return (\n    notBlank(childPosixPath) &&\n    notBlank(parentPosixPath) &&\n    (childPosixPath === parentPosixPath ||\n      childPosixPath.startsWith(ensureSuffix(parentPosixPath, posix.sep)))\n  )\n}\n\nexport function containedByNativePath(\n  childNativePath: Maybe<string>,\n  parentNativePath: Maybe<string>\n): boolean {\n  return (\n    notBlank(childNativePath) &&\n    notBlank(parentNativePath) &&\n    (childNativePath === parentNativePath ||\n      childNativePath.startsWith(ensureSuffix(parentNativePath, _p.sep)))\n  )\n}\n\nexport function pathnames(nativePath: string) {\n  return stripPrefix(nativePath, _p.sep).split(_p.sep)\n}\n\nexport type NativePathed = Pick<SimpleFile, \"nativePath\">\n\nexport function posixPathFrom(\n  parent: NativePathed,\n  child: NativePathed\n): string {\n  return parent.nativePath === child.nativePath\n    ? \"\"\n    : // The ensureSuffix handles windows drive letters properly:\n      stripPrefix(\n        native2posix(child.nativePath),\n        ensureSuffix(native2posix(parent.nativePath), \"/\")\n      )\n}\n\nexport function posixPathFromGrandparent(nativePath: string): string {\n  return pathnames(nativePath).slice(-3).join(\"/\")\n}\n\nconst countRE = /(.*?)(?:-(\\d{1,4})|\\((\\d{1,4})\\))$/\nexport function nameWithoutCount(name: string): string {\n  return mapOr(\n    toS(name).match(countRE),\n    m => m[1],\n    () => name\n  )\n    .toLowerCase()\n    .normalize()\n}\n\nexport function countFromName(name: string): Maybe<number> {\n  return map(toS(name).match(countRE), m => first([m[2], m[3]], toInt))\n}\n\nexport function addNameSuffix(basename_: string, suffix: string): string {\n  const p = parseNativePath(basename_)\n  return `${p.base}${suffix}${p.ext}`\n}\n\nexport function isDirectorySync(nativePath: Maybe<string>) {\n  if (blank(nativePath)) return false\n  try {\n    return fs.statSync(nativePath).isDirectory()\n  } catch {\n    return false\n  }\n}\n\nexport async function stat(nativePath: Maybe<string>) {\n  if (blank(nativePath)) return\n  try {\n    return await thenOrTimeout(fse.stat(nativePath), MountpointsTtlMs)\n  } catch {\n    return\n  }\n}\n\nexport async function notExists(nativePath: string) {\n  return null == (await stat(nativePath))\n}\n\nexport async function isEmpty(nativePath: string) {\n  const s = await stat(nativePath)\n  return s == null || (s.isFile() && s.size === 0)\n}\n\nexport async function isDirectory(nativePath: Maybe<string>): Promise<boolean> {\n  return thenMapOr(\n    stat(nativePath),\n    ea => ea.isDirectory(),\n    () => false\n  )\n}\n\nexport function firstExistingDirectory(paths: Maybe<string>[]): Maybe<string> {\n  for (const ea of paths) {\n    if (notBlank(ea)) {\n      const d = resolve(ea)\n      if (isDirectorySync(d)) return d\n    }\n  }\n  return undefined\n}\n\nexport function posixPathExistsSync(posixPath: Maybe<string>) {\n  return mapNotBlankOr(\n    posixPath,\n    ea => nativePathExistsSync(posix2native(ea)),\n    false\n  )\n}\n\nexport async function nativePathExists(\n  nativePath: Maybe<string>\n): Promise<boolean> {\n  if (blank(nativePath)) return false\n  try {\n    return null != (await stat(nativePath))\n  } catch {\n    return false\n  }\n}\n\nexport function nativePathExistsSync(nativePath: Maybe<string>) {\n  if (blank(nativePath)) return false\n  try {\n    return fs.existsSync(nativePath)\n  } catch {\n    return false\n  }\n}\n\nexport async function nativePathIsReadableDirectory(\n  nativePath: Maybe<string>,\n  timeoutMs = StatTimeoutMs\n) {\n  if (blank(nativePath)) return false\n  try {\n    const s = await thenOrTimeout(stat(nativePath), timeoutMs)\n    if (s == null || !s.isDirectory()) return false\n    return await resolvedWithin(\n      fse.access(\n        nativePath,\n        fs.constants.R_OK | (isWin ? 0 : fs.constants.X_OK)\n      ),\n      timeoutMs\n    )\n  } catch {\n    return false\n  }\n}\n\nexport function isUNC(nativePath: string) {\n  return nativePath.startsWith(\"\\\\\\\\\")\n}\n\nexport function isAbsolute(nativePath: string) {\n  return (\n    (isPosix && nativePath.startsWith(\"/\")) ||\n    (isWin && (isUNC(nativePath) || nativePath.match(driveRe) != null))\n  )\n}\n\nexport interface EnsureNewOptions {\n  nativePath: string\n  emptyIsNew?: boolean\n  maxVersions?: number\n  requireNumber?: boolean\n  leftPad?: number\n  startIndex?: number\n}\n\nexport const DefaultEnsureNewOptions: Omit<\n  Required<EnsureNewOptions>,\n  \"nativePath\"\n> = Object.freeze({\n  emptyIsNew: true,\n  maxVersions: 512,\n  requireNumber: false,\n  leftPad: 1,\n  startIndex: 1\n})\n\nfunction isEmptyFile(s: fs.Stats) {\n  return s == null || (s.isFile() && s.size === 0)\n}\n\nexport async function ensureNewNativePath_(\n  options: EnsureNewOptions\n): Promise<string> {\n  const opts: Required<EnsureNewOptions> = {\n    ...DefaultEnsureNewOptions,\n    ...options\n  }\n\n  const p = parseNativePath(opts.nativePath)\n\n  await fse.mkdirp(p.dir)\n\n  {\n    const s = await stat(opts.nativePath)\n    if (\n      !opts.requireNumber &&\n      (s == null || (opts.emptyIsNew && isEmptyFile(s)))\n    )\n      return opts.nativePath\n  }\n  for (let i = opts.startIndex; i <= opts.maxVersions; i++) {\n    const f = _p.join(\n      p.dir,\n      `${p.name}-${leftPad(i, opts.leftPad, \"0\")}${p.ext}`\n    )\n    const s = await stat(f)\n    if (s == null || (opts.emptyIsNew && isEmptyFile(s))) {\n      return f\n    }\n  }\n  throw new Error(\n    \"There are already more than \" + opts.maxVersions + \" of \" + opts.nativePath\n  )\n}\n\nexport async function gzip_(nativePath: string): Promise<string> {\n  if (nativePath.endsWith(\".gz\")) return nativePath\n  const out = nativePath + \".gz\"\n  await pipelineAsync([\n    fs.createReadStream(nativePath),\n    createGzip(),\n    fs.createWriteStream(out)\n  ])\n  await fse.unlink(nativePath)\n  return out\n}\n", "import { inspect } from \"util\"\nimport {\n  compact,\n  copyArrayTo,\n  filterInPlace,\n  isEmpty,\n  isNotEmpty,\n  sort,\n  stepRange,\n  uniqBy\n} from \"../fe/Array\"\nimport { notBlank } from \"../fe/Blank\"\nimport { stringify } from \"../fe/JSON\"\nimport { Defined, defined, map, mapOr } from \"../fe/Maybe\"\nimport { Maybe, MaybeNull, PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { times } from \"../fe/Number\"\nimport { tap } from \"../fe/Object\"\nimport { isFunction } from \"../fe/ObjectType\"\nimport { SyncOrAsync } from \"../fe/OptAsync\"\nimport {\n  Comparable,\n  gt,\n  isPrimitive,\n  lt,\n  Primitivable,\n  Primitive\n} from \"../fe/Primitive\"\nimport { Thunk } from \"../fe/Thunk\"\nimport { toA } from \"../fe/toA\"\nimport { eql } from \"./Eql\"\n\n// Extract the element type of an array:\nexport type ElementType<T extends readonly unknown[]> = T[number]\n// type T = ElementType<SomeArrayType[]>\n\n/**\n * @return true iff all `objects` are neither `undefined` nor `null`. Note\n * that `[]` returns true.\n */\nexport function allDefined<T>(\n  arr: MaybeNull<MaybeNull<T>[]>\n): arr is Defined<T>[] {\n  return defined(arr) && arr.every(defined)\n}\n\nexport function mapAllDefined<T, U>(\n  arr: MaybeNull<MaybeNull<T>[]>,\n  f: (t: T[]) => U\n): Maybe<U> {\n  return allDefined(arr) ? f(arr) : undefined\n}\n\nexport function mapAll<T, V>(\n  arr: MaybeNull<MaybeNull<T>[]>,\n  f: (ea: T[]) => V\n): Maybe<V> {\n  return allDefined(arr) ? f(arr) : undefined\n}\n\n/**\n * @return true iff all `objects` are `undefined` or `null`\n */\nexport function allNotDefined(objects: any[]): boolean {\n  return objects == null || objects.every(ea => ea == null)\n}\n\nexport function allNotBlank(...arr: MaybeNull<any>[]): boolean {\n  return arr != null && arr.every(notBlank)\n}\n\n/**\n * @return true iff any `objects` are `undefined` or `null`. Note that `[]`\n * returns false (as there aren't not-defined instances).\n */\nexport function anyNotDefined(objects: any[]): boolean {\n  return objects == null || objects.some(ea => ea == null)\n}\n\nexport function anyDefined(objects: any[]): boolean {\n  return objects != null && objects.some(ea => ea != null)\n}\n\n/**\n * @return the first non-`null` result of `f`, or if `f` is omitted, the first\n * non-null value in `arr`.\n */\nexport function first<T, R>(\n  arr: Maybe<Maybe<T>[]>,\n  f: (t: T) => MaybeNull<R>\n): Maybe<R> {\n  if (arr != null) {\n    for (const t of compact(arr)) {\n      const r = f(t)\n      if (r != null) {\n        return r\n      }\n    }\n  }\n  return\n}\n\n/**\n * Return the first result from `f` that is defined.\n * @see Array#first\n * @see Later#firstDefinedLater\n */\nexport async function firstAsync<T, R>(\n  arr: Maybe<Maybe<T>[]>,\n  f: (t: T, index: number) => SyncOrAsync<MaybeNull<R>>\n): PromiseMaybe<R> {\n  if (arr != null) {\n    let index = -1\n    for (const t of arr) {\n      index++\n      try {\n        if (t == null) continue\n        const r = await f(t, index)\n        if (r != null) {\n          return r\n        }\n      } catch (err) {\n        //\n      }\n    }\n  }\n  return undefined\n}\n\n/**\n * @see Later#firstDefinedLater\n */\nexport function firstNonEmptyThunk<T>(\n  ...thunks: Thunk<Maybe<T[]>>[]\n): Maybe<T[]> {\n  for (const t of thunks) {\n    const arr = t()\n    if (isNotEmpty(arr)) {\n      return arr\n    }\n  }\n  return\n}\n\n/**\n * @return the last value in the array that satisfies the predicate\n */\nexport function findLast<T>(arr: T[], predicate: (t: T) => boolean): Maybe<T> {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) return arr[i]\n  }\n  return\n}\n\n/**\n * @return the last index in the array that satisfies the predicate\n */\nexport function findLastIndex<T>(\n  arr: T[],\n  predicate: (t: T) => boolean\n): number {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) return i\n  }\n  return -1\n}\n\nexport function concat<T>(...arrs: (MaybeNull<T> | MaybeNull<T>[])[]): T[] {\n  const arr: T[] = []\n  for (const ea of arrs) {\n    if (Array.isArray(ea)) {\n      for (const elem of ea) {\n        if (elem != null) arr.push(elem)\n      }\n    } else if (ea != null) {\n      arr.push(ea)\n    }\n  }\n  return arr\n}\n\n// Can't call this delete, as that's a javascript keyword\nexport function remove<T>(arr: T[], ...element: T[]): boolean {\n  const before = arr.length\n  filterInPlace(arr, ea => element.every(ea2 => !eql(ea, ea2)))\n  return before !== arr.length\n}\n\nexport function moveToEnd<T>(arr: T[], element: T): T[] {\n  remove(arr, element)\n  arr.push(element)\n  return arr\n}\n\nexport function moveIndexToEnd<T>(arr: T[], index: number): T[] {\n  const moved = arr[index]\n  if (moved == null) return arr\n  arr.push(moved)\n  for (let i = index; i < arr.length - 1; i++) {\n    arr[i] = arr[i + 1]\n  }\n  arr.length = arr.length - 1\n  return arr\n}\n\nconst primitiveValueOfOrElse = (a: any) => {\n  if (isPrimitive(a)) {\n    return a\n  }\n  // [].valueOf() is worthless, so use json\n  if (Array.isArray(a)) {\n    return stringify(a)\n  }\n  if (isFunction(a.valueOf)) {\n    return a.valueOf()\n  } else {\n    throw new Error(\"Cannot get primitive value for \" + inspect(a))\n  }\n}\n\n/**\n * `minuend - subtrahend`.\n *\n * @template T must have a .valueOf() implementation\n * @param {T[]} minuend (haystack)\n * @param {T[]} subtrahend (needles)\n * @returns {T[]} values in `minuend` that, according to `.valueOf()`, are\n * not in `subtrahend`. Neither arg is mutated.\n */\nexport function diff<T>(\n  minuend: T[],\n  subtrahend: T[],\n  valueOf: (t: T) => Primitive = primitiveValueOfOrElse\n): T[] {\n  const s = new Set(subtrahend.map(valueOf))\n  return minuend.filter(ea => !s.has(valueOf(ea)))\n}\n\n/**\n * @template T must have a .valueOf() implementation\n * @return the values in both `a` and `b`\n */\nexport function intersection<T>(\n  a: T[],\n  b: T[],\n  valueOf: (t: T) => Primitive = primitiveValueOfOrElse\n): T[] {\n  const s = new Set(b.map(valueOf))\n  return a.filter(ea => s.has(valueOf(ea)))\n}\n\nexport function diceCoeff<T>(\n  a: T[],\n  b: T[],\n  valueOf: (t: T) => Primitive = primitiveValueOfOrElse\n): number {\n  if (isEmpty(a) && isEmpty(b)) return 1\n  return (intersection(a, b, valueOf).length * 2) / (a.length + b.length)\n}\n\n/**\n * @return true iff all elements in `a` are in `b` and all elements in `b` are\n * in `a`. Order is ignored. Elements must be sortable, however.\n */\nexport function eqlContents(a: any[], b: any[]): boolean {\n  return zip(sort(a), sort(b)).every(([x, y]) => x === y)\n}\n\n/**\n * Remove the first item from `arr` where the `predicate` returns `true`.\n * @return the element removed from `arr`\n */\nexport function removeFirst<T>(\n  arr: T[],\n  predicate: (item: T, index: number, sourceArray: T[]) => boolean\n): Maybe<T> {\n  const idx = arr.findIndex(predicate)\n  return idx >= 0 ? arr.splice(idx, 1)[0] : undefined\n}\n\nexport function uniqInPlace<T>(\n  arr: T[],\n  f: (t: T) => Maybe<Primitive> = ea => stringify(ea)\n): void {\n  copyArrayTo(uniqBy(arr, f), arr)\n}\n\nexport function partition<T>(\n  arr: T[],\n  filter: (t: T, index: number) => boolean\n): [T[], T[]] {\n  const accept: T[] = []\n  const reject: T[] = []\n  arr.forEach((ea, i) => (filter(ea, i) ? accept : reject).push(ea))\n  return [accept, reject]\n}\n\n/**\n * `Uniq -c`: return unique strings and their count\n */\nexport function uniqCount<T extends Primitive>(\n  arr: T[]\n): { t: T; count: number }[] {\n  return _uniqCount(arr.sort())\n}\n\nfunction _uniqCount<T extends Primitive>(\n  sortedArr: T[]\n): { t: T; count: number }[] {\n  if (sortedArr == null || sortedArr.length === 0) return []\n  const t = sortedArr[0]\n  const lastElem = sortedArr.lastIndexOf(t)\n  return [\n    { t, count: lastElem + 1 },\n    ..._uniqCount(sortedArr.slice(lastElem + 1))\n  ]\n}\n\nexport function mapCompact<T, R>(\n  arr: MaybeNull<T>[],\n  f: (t: T) => Maybe<R>\n): R[] {\n  return compact(compact(arr).map(f))\n}\n\nexport function toMapEntries<T, K, V>(\n  arr: T[],\n  f: (t: T) => MaybeNull<[K, V]>\n): Map<K, V> {\n  return new Map<K, V>(arr.map(f).filter(defined) as [K, V][])\n}\n\nexport function flatMap<T, U>(arr: T[], f: (t: T) => Maybe<Maybe<U>[]>): U[] {\n  return arr.reduce(\n    (prev: U[], curr: T) => prev.concat(...compact(f(curr))),\n    []\n  )\n}\n\nexport function retainLastN<T>(arr: T[], length: number): T[] {\n  if (arr.length > length) {\n    arr.splice(0, arr.length - length)\n  }\n  return arr\n}\n\nexport function retainFirstN<T>(arr: T[], length: number): T[] {\n  arr.length = Math.min(arr.length, length)\n  return arr\n}\n\nexport interface Surrounding<T> {\n  before: T[]\n  after: T[]\n}\n\nexport function contextAround<T>(\n  arr: T[],\n  limitBefore: number,\n  limitAfter: number,\n  predicate: (t: T) => boolean\n): Maybe<Surrounding<T>> {\n  const idx = arr.findIndex(predicate)\n  if (idx === -1) {\n    return\n  } else {\n    const before =\n      idx === 0 ? [] : arr.slice(Math.max(0, idx - limitBefore), idx)\n    const after =\n      idx === arr.length - 1\n        ? []\n        : arr.slice(idx + 1, Math.min(idx + 1 + limitAfter, arr.length))\n    return { before, after }\n  }\n}\n\nexport function zip<T1, T2>(arr1: T1[], arr2: T2[]): [T1, T2][]\nexport function zip<T1, T2, T3>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[]\n): [T1, T2, T3][]\nexport function zip<T1, T2, T3, T4>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[]\n): [T1, T2, T3, T4][]\nexport function zip<T1, T2, T3, T4, T5>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[],\n  arr5: T5[]\n): [T1, T2, T3, T4, T5][]\nexport function zip<T1, T2, T3, T4, T5, T6>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[],\n  arr5: T5[],\n  arr6: T6[]\n): [T1, T2, T3, T4, T5, T6][]\nexport function zip<T1, T2, T3, T4, T5, T6, T7>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[],\n  arr5: T5[],\n  arr6: T6[],\n  arr7: T7[]\n): [T1, T2, T3, T4, T5, T6, T7][]\nexport function zip<T1, T2, T3, T4, T5, T6, T7, T8>(\n  arr1: T1[],\n  arr2: T2[],\n  arr3: T3[],\n  arr4: T4[],\n  arr5: T5[],\n  arr6: T6[],\n  arr7: T7[],\n  arr8: T8[]\n): [T1, T2, T3, T4, T5, T6, T7, T8][]\nexport function zip<T>(...arrarr: T[][]): T[][] {\n  const len = Math.max(...arrarr.map(ea => ea.length))\n  return times(len, i => arrarr.map(ea => ea[i]))\n}\n\nexport function flatZip<T>(...arrarr: T[][]): T[] {\n  const len = Math.max(...arrarr.map(ea => ea.length))\n  const r: T[] = []\n  times(len, i => arrarr.map(ea => r.push(ea[i])))\n  return r\n}\n\nexport function unzip<T1, T2>(arr: [T1, T2][]): [T1[], T2[]] {\n  return [arr.map(([t1]) => t1), arr.map(([, t2]) => t2)]\n}\n\n/**\n * Given [A,B,C], return [A], [A,B], [A,B,C]\n */\nexport function ancestry<T>(arr: T[]): T[][] {\n  return times(arr.length, i => arr.slice(0, i + 1))\n}\n\nexport function min<T extends Primitivable>(arr: MaybeNull<T>[]): Maybe<T> {\n  return arr[leastIndex(arr)] as Maybe<T>\n}\n\n/**\n * Return the first index into `arr` holding the least value (using `valueOf`\n * of T)\n */\nexport function leastIndex<T extends Primitivable>(\n  arr: MaybeNull<T>[]\n): number {\n  return leastIndexBy(arr, ea => ea.valueOf())\n}\n\nexport function max<T extends Primitivable>(arr: MaybeNull<T>[]): Maybe<T> {\n  return arr[greatestIndex(arr)] as Maybe<T>\n}\n\n/**\n * Return the first index into `arr` holding the largest value (using `valueOf`\n * of T)\n */\nexport function greatestIndex<T extends Primitivable>(\n  arr: MaybeNull<T>[]\n): number {\n  return greatestIndexBy(arr, ea => ea.valueOf())\n}\n\nexport function leastIndexBy<T>(\n  arr: MaybeNull<T>[],\n  valueOf: (t: T) => Maybe<Comparable>\n): number {\n  return estIndex(arr, valueOf, (a, b) => lt(a, b))\n}\n\nexport function greatestIndexBy<T>(\n  arr: MaybeNull<T>[],\n  valueOf: (t: T) => Maybe<Comparable>\n): number {\n  return estIndex(arr, valueOf, (a, b) => gt(a, b))\n}\n\nexport function leastBy<T>(\n  arr: MaybeNull<T>[],\n  valueOf: (t: T) => Maybe<Comparable>\n): Maybe<T> {\n  return arr[leastIndexBy(arr, valueOf)] as Maybe<T>\n}\n\nexport function greatestBy<T>(\n  arr: MaybeNull<T>[],\n  valueOf: (t: T) => Maybe<Comparable>\n): Maybe<T> {\n  return arr[greatestIndexBy(arr, valueOf)] as Maybe<T>\n}\n\nfunction estIndex<T>(\n  arr: MaybeNull<T>[],\n  valueOf: (t: T) => Maybe<Comparable>,\n  predicate: (a: Comparable, b: Comparable) => boolean\n): number {\n  if (isEmpty(arr)) return -1\n\n  let result = -1\n  let prior: Maybe<Comparable>\n\n  for (let i = 0; i < arr.length; i++) {\n    const ea = arr[i]\n    if (ea != null) {\n      const v = valueOf(ea)\n      if (v != null) {\n        if (prior == null || predicate(v, prior) === true) {\n          result = i\n          prior = v\n        }\n      }\n    }\n  }\n  return result\n}\n\nexport interface ArrayLike<T> {\n  length: number\n  [index: number]: Maybe<T>\n}\n\nexport function reverse<T extends ArrayLike<any>>(arr: T): T {\n  const r = []\n  for (let i = arr.length - 1; i >= 0; i--) {\n    r.push(arr[i])\n  }\n  return r as any\n}\n\nexport function batches<T>(arr: T[], batchsize: number): T[][] {\n  if (batchsize <= 0) batchsize = 1\n  return stepRange(0, arr.length, batchsize, i => arr.slice(i, i + batchsize))\n}\n\nexport function collectBatched<T1, T2>(\n  arr: T1[],\n  batchSize: number,\n  f: (arr: T1[]) => Maybe<Maybe<T2>[]>\n): T2[] {\n  const result: T2[] = []\n  for (const batchArr of batches(toA(arr), batchSize)) {\n    result.push(...compact(f(compact(batchArr))))\n  }\n  return result\n}\n\nexport function contextFilter<T>(\n  arr: T[],\n  predicate: (t: T, idx: number, lastPass: Maybe<T>) => boolean\n): T[] {\n  let lastPass: Maybe<T>\n  return arr.filter((ea, idx) =>\n    tap(predicate(ea, idx, lastPass), result => {\n      if (result) lastPass = ea\n    })\n  )\n}\n\nexport async function clusterStrictAsync<T>(\n  arr: T[],\n  cmp: (a: T, b: T) => SyncOrAsync<boolean>\n): Promise<T[][]> {\n  return clusterAsync(arr, cmp, true)\n}\n\nexport async function clusterAsync<T>(\n  arr: T[],\n  cmp: (a: T, b: T) => SyncOrAsync<boolean>,\n  strict: boolean = false\n): Promise<T[][]> {\n  const result: T[][] = []\n  outer: for (const ea of arr) {\n    for (const resultArr of result) {\n      if (strict) {\n        if (await everyAsync(resultArr, prior => cmp(ea, prior))) {\n          resultArr.push(ea)\n          continue outer\n        }\n      } else {\n        if (await someAsync(resultArr, prior => cmp(ea, prior))) {\n          resultArr.push(ea)\n          continue outer\n        }\n      }\n    }\n    result.push([ea])\n  }\n  return result\n}\n\n/**\n * Return if any `f` returns true.\n * @see Array#some\n */\nexport async function someAsync<T>(\n  arr: T[],\n  f: (t: T, index: number) => SyncOrAsync<boolean>\n): Promise<boolean> {\n  if (arr != null) {\n    for (let i = 0; i < arr.length; i++) {\n      if (await f(arr[i], i)) return true\n    }\n  }\n  return false\n}\n\n/**\n * Return if every `f` returns true.\n * @see Array#every\n */\nexport async function everyAsync<T>(\n  arr: T[],\n  f: (t: T, index: number) => SyncOrAsync<boolean>\n): Promise<boolean> {\n  return isEmpty(arr) || (await Promise.all(arr.map(f))).every(ea => ea)\n}\n\nexport function firstIndexNearest<T>({\n  arr,\n  fromIndex,\n  pred,\n  maxDelta\n}: {\n  arr: T[]\n  fromIndex: number\n  pred: (t: T, index: number) => boolean\n  maxDelta: number\n}): Maybe<number> {\n  for (let i = 1; i < Math.min(maxDelta + 1, arr.length); i++) {\n    {\n      const before = fromIndex - i\n      if (before >= 0 && true === map(arr[before], ea => pred(ea, before))) {\n        return before\n      }\n    }\n    {\n      const after = fromIndex + i\n      if (after < arr.length && pred(arr[after]!, after)) return after\n    }\n  }\n  return\n}\n\nexport function dupes<T extends Primitive>(arr: Maybe<T>[]) {\n  const mm = new Map<T, number>()\n  for (const ea of arr) {\n    if (ea != null)\n      mm.set(\n        ea,\n        mapOr(mm.get(ea), i => i + 1, 1)\n      )\n  }\n  return toA(mm.entries()).filter(([, v]) => v > 1)\n}\n\nexport function leftPadArray<T>(arr: T[], minLength: number, pad: T) {\n  if (arr.length < minLength) {\n    arr.unshift(...times(minLength - arr.length, () => pad))\n  }\n  return arr\n}\n", "import { map2Or } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { pick } from \"../fe/Object\"\nimport { MaybeSyncOrAsync } from \"../fe/OptAsync\"\n\nconst de = require(\"deep-eql\")\n\nexport function eql<T>(a: Maybe<T>, b: Maybe<T>): boolean {\n  return de(a, b)\n}\n\nexport function definedAndEql<T>(a: Maybe<T>, b: Maybe<T>): boolean {\n  return a == null || b == null ? false : eql(a, b)\n}\n\nexport function definedAndNotEql<T>(a: Maybe<T>, b: Maybe<T>): boolean {\n  return a != null && b != null && !eql(a, b)\n}\n\nexport async function eqlAsync<T>(\n  a: MaybeSyncOrAsync<T>,\n  b: MaybeSyncOrAsync<T>\n): Promise<boolean> {\n  return map2Or(await a, await b, eql, () => false)\n}\n\nexport async function eqlAsyncPicked<T, K extends keyof T>(\n  a: MaybeSyncOrAsync<T>,\n  b: MaybeSyncOrAsync<T>,\n  ...keys: K[]\n): Promise<boolean> {\n  return map2Or(\n    await a,\n    await b,\n    (a1, a2) => eql(pick(a1, ...keys), pick(a2, ...keys)),\n    () => false\n  )\n}\n", "import { gt0 } from \"./Number\"\nimport { isFunction } from \"./ObjectType\"\n\nexport function unrefDelay(millis: number) {\n  return _delay(millis, true)\n}\n\nexport function delay(millis: number) {\n  return _delay(millis, false)\n}\n\nexport function delayUntil(date: Date | number) {\n  const t = gt0(date) ? date : date.getTime()\n  const delayMs = t - Date.now()\n  if (delayMs < 0) {\n    if (delayMs > -500) {\n      // meh close enough\n      return\n    } else {\n      throw new Error(\n        \"Mr. Fusion not found, cannot time travel back \" + -delayMs + \"ms\"\n      )\n    }\n  }\n  return delay(delayMs).then(() => delayMs)\n}\n\nfunction _delay(millis: number, unref: boolean): Promise<void> {\n  // On windows at least, setTimeout() only ensures N-1 millis have passed.\n  return new Promise<void>(resolve => {\n    if (millis <= 0) {\n      resolve()\n    } else {\n      // ceil(+0.5) to make sure we wait enough time:\n\n      // SITS: any casting shenanigans to make this work on the frontend and\n      // backend:\n      const t: any = setTimeout(() => resolve(), Math.ceil(millis + 0.5))\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      if (unref && t.unref != null && isFunction(t.unref)) t.unref()\n    }\n  })\n}\n\nexport function later(f: () => any, delayMs: number = 1) {\n  return setTimeout(f, Math.max(1, Math.ceil(delayMs)))\n}\n", "import { PromiseMaybe } from \"./MaybeTypes\"\nimport { MaybeNullSyncOrAsync, MaybeSyncOrAsync, SyncOrAsync } from \"./OptAsync\"\nimport { toA } from \"./toA\"\n\n/**\n * Safe calls for Optional promises:\n */\nexport async function thenMap<T1, T2>(\n  objP: MaybeNullSyncOrAsync<T1>,\n  f: (t: T1) => MaybeSyncOrAsync<T2>\n): PromiseMaybe<T2> {\n  const obj = await objP\n  return obj == null ? undefined : f(obj)\n}\n\n/**\n * Serialized promise gathering and compaction\n * @see ../core/async/Promise#tuples\n */\nexport async function thenCollect<T1, T2>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T1>[]>,\n  f: (t: T1) => MaybeSyncOrAsync<T2>\n): Promise<T2[]> {\n  const result: T2[] = []\n  for (const eaP of toA(await arr)) {\n    if (eaP != null) {\n      const ea = await eaP\n      if (ea != null) {\n        const r = await f(ea)\n        if (r != null) result.push(r)\n      }\n    }\n  }\n  return result\n}\n\nexport async function thenTap<T>(\n  p: SyncOrAsync<T>,\n  f: (t: T) => any = console.dir.bind(console)\n): Promise<T> {\n  const result = await p\n  // We await f so if it raises errors, thenTap will propagate the error:\n  await f(result)\n  return result\n}\n\nexport function isPromise(o: any): o is Promise<any> {\n  return (\n    o != null &&\n    typeof o[\"then\"] === \"function\" &&\n    typeof o[\"catch\"] === \"function\"\n  )\n}\n", "import { compactBlanks, isEmpty, sortBy, uniqBy2 } from \"../fe/Array\"\nimport { blank, notBlank } from \"../fe/Blank\"\nimport { map, orElse } from \"../fe/Maybe\"\nimport { Maybe, MaybeNull } from \"../fe/MaybeTypes\"\nimport { times, toFloat } from \"../fe/Number\"\nimport { cmp } from \"../fe/Primitive\"\nimport { toA } from \"../fe/toA\"\nimport { toS } from \"../fe/toS\"\nimport { greatestBy } from \"./Array\"\n\nconst he = require(\"he\")\n\n// TODO: inline\nexport {\n  ellipsize,\n  ensurePrefix,\n  ensureSuffix,\n  isString,\n  newlineRe,\n  wrap\n} from \"../fe/String\"\n\nconst pads = {}\n\nexport function padding(char: string, length: number): string {\n  if (length < 1) return \"\"\n  if (pads[char] == null) pads[char] = char\n  while (length > pads[char].length) {\n    pads[char] += char\n  }\n  return pads[char].substring(0, length)\n}\n\n// first added for irony, then used nonironically:\nexport function leftPad(s: any, minLength: number, padChar: string): string {\n  if (padChar.length === 0) throw new Error(\"leftPad() given empty pad\")\n  if (typeof s === \"number\" && s < 0) {\n    return \"-\" + leftPad(String(-s), minLength - 1, padChar)\n  }\n  const str = String(s)\n  return padding(padChar, minLength - str.length) + str\n}\n\nexport function rightPad(s: any, minLength: number, padChar: string): string {\n  if (padChar.length === 0) throw new Error(\"rightPad() given empty pad\")\n  const str = String(s)\n  return str + padding(padChar, minLength - str.length)\n}\n\n/**\n * Left-zero-pad\n */\nexport function pad2(s: any): string {\n  return leftPad(s, 2, \"0\")\n}\n\nexport function padReplace(\n  s: string,\n  fromIdx: number,\n  length: number,\n  padChar: string\n) {\n  return (\n    s.substr(0, fromIdx) + padding(padChar, length) + s.substr(fromIdx + length)\n  )\n}\n\nexport function contains(\n  haystack: string,\n  needle: string,\n  fromPosition?: number\n): boolean {\n  return toS(haystack).indexOf(toS(needle), fromPosition) > -1\n}\n\nexport function count(\n  haystack: string,\n  needle: string,\n  fromPosition = 0\n): number {\n  if (needle == null || needle.length === 0) return 0\n  const idx = haystack.indexOf(needle, fromPosition)\n  return idx === -1 ? 0 : 1 + count(haystack, needle, idx + needle.length)\n}\n\nexport function maybeToS(a?: any): Maybe<string> {\n  return a == null ? undefined : String(a)\n}\n\nexport function trim(arr: any[]): string[] {\n  return arr.map(toS).filter(ea => notBlank(ea))\n}\n\nexport function splitFirst(\n  s: string,\n  pattern: string\n): [string, string] | [string] {\n  const indexOf = s.indexOf(pattern)\n  return indexOf === -1\n    ? [s]\n    : [s.slice(0, indexOf), s.slice(indexOf + pattern.length)]\n}\n\nexport function splitEvery(s: string, n: number, maxSplits?: number): string[] {\n  const sliceTimes =\n    Math.min(\n      Math.ceil(s.length / n),\n      orElse(maxSplits, () => s.length)\n    ) - 1\n  if (sliceTimes <= 0) return [s]\n  return [\n    ...times(sliceTimes, i => s.slice(i * n, (i + 1) * n)),\n    s.slice(sliceTimes * n)\n  ]\n}\n\n/**\n * Removes the first capture group defined by `re` found in `s`.\n */\nexport function spliceCapture(s: string, re: RegExp) {\n  const m = re.exec(s)\n  if (m == null || m[1] == null) return\n  const matchedIndex = m[0].indexOf(m[1]) + m.index\n  return {\n    captured: m[1],\n    uncaptured:\n      s.substring(0, matchedIndex) + s.substring(matchedIndex + m[1].length),\n    unmatched: s.substring(0, m.index) + s.substring(m.index + m[0].length),\n    matchedIndex\n  }\n}\n\nexport function stripPrefix(s: string, prefix: string): string {\n  const str = toS(s)\n  const pfx = toS(prefix)\n  return pfx.length > 0 && str.startsWith(pfx) ? str.slice(pfx.length) : str\n}\n\nexport function stripPrefixIgnoreCase(s: string, prefix: string): string {\n  s = toS(s)\n  prefix = toS(prefix)\n  return startsWithIgnoreCase(s, prefix) ? s.slice(prefix.length) : s\n}\n\nexport function stripSuffix(s: string, suffix: string): string {\n  if (suffix == null) return s\n  const str = toS(s)\n  const sfx = toS(suffix)\n  return sfx.length > 0 && str.endsWith(sfx) ? str.slice(0, -sfx.length) : str\n}\n\n/**\n * Only strip the prefix and suffix if they both exist.\n */\nexport function stripPreSuff(s: string, prefix: string, suffix: string) {\n  if (prefix == null) return stripSuffix(s, suffix)\n  s = toS(s)\n  return s.endsWith(suffix) && s.startsWith(prefix)\n    ? s.slice(prefix.length, -suffix.length)\n    : s\n}\n\nexport function gist(a: string, maxPre = 80, maxPost = 80): string {\n  const s = toS(a)\n  const charsOmitted = s.length - (maxPre + maxPost)\n  return charsOmitted <= 0\n    ? s\n    : s.slice(0, maxPre).trim() +\n        \" \u2026(+\" +\n        charsOmitted +\n        \" chars)\u2026\" +\n        s.slice(-maxPost).trim()\n}\n\nexport function capitalize(s: Maybe<string>): string {\n  s = toS(s)\n  const arr = s.normalize().split(\"\")\n  return blank(s) ? s : arr[0].toLocaleUpperCase() + arr.slice(1).join(\"\")\n}\n\nexport function compareIgnoreCase(a: string, b: string) {\n  return a.localeCompare(b, undefined, { sensitivity: \"base\" })\n}\n\nexport function equalsIgnoreCase(\n  a: MaybeNull<string | Buffer>,\n  b: MaybeNull<string | Buffer>\n): boolean {\n  if (a == null || b == null) return false\n  const as = toS(a)\n  const bs = toS(b)\n  if (as.length !== bs.length) return false\n  if (as === bs) return true\n  // cheap, but false is sometimes wrong (like in Turkish):\n  if (as.toLowerCase() === bs.toLowerCase()) return true\n  return (\n    as.localeCompare(bs, undefined, {\n      sensitivity: \"base\"\n    }) === 0 ||\n    // .normalize is expensive():\n    0 === compareIgnoreCase(as.normalize(), bs.normalize())\n  )\n}\n\nexport function uniqIgnoreCase(arr: string[]): string[] {\n  return uniqBy2(arr, equalsIgnoreCase)\n}\n\nexport function sortIgnoreCase(arr: string[]): string[] {\n  return arr.sort(compareIgnoreCase)\n}\n\nexport function sortByCaseInsensitive<T>(\n  arr: Iterable<T> | T[],\n  f: (t: T, index: number) => Maybe<string>\n): T[] {\n  return toA(arr)\n    .filter(ea => ea != null)\n    .map((item, idx) => ({\n      item,\n      cmp: map(f(item, idx), ea => [ea, idx]) as [string, number]\n    }))\n    .filter(ea => ea.cmp != null)\n    .sort((a, b) => {\n      const ea = compareIgnoreCase(a.cmp[0], b.cmp[0])\n      return ea !== 0 ? ea : cmp(a.cmp[1], b.cmp[1])\n    })\n    .map(ea => ea.item)\n}\n\n/** TODO DELETE IF UNUSED\n * @return true iff `haystack` starts with `needle`\n */\nexport function startsWithIgnoreCase(\n  haystack: string,\n  needle: string\n): boolean {\n  return haystack == null ||\n    needle == null ||\n    needle.length === 0 ||\n    haystack.length === 0\n    ? false\n    : equalsIgnoreCase(haystack.substring(0, needle.length), needle)\n}\n\n/**\n * @return the first item in `haystack` that is a case-insensitive substring of\n * `needle`.\n */\nexport function firstSubstringIgnoreCase(\n  haystack: string[],\n  needle: string\n): Maybe<{ index: number; match: string }> {\n  if (isEmpty(haystack) || blank(needle)) return\n  for (const ea of haystack) {\n    if (equalsIgnoreCase(ea, needle)) return { index: 0, match: ea }\n  }\n  for (const ea of haystack) {\n    const index = needle.indexOf(ea)\n    if (index >= 0) return { index, match: ea }\n  }\n  const nn = needle.normalize()\n  for (const ea of haystack) {\n    {\n      const index = nn.indexOf(ea)\n      if (index >= 0) return { index, match: ea }\n    }\n    const hn = ea.normalize()\n    {\n      const index = nn.indexOf(hn)\n      if (index >= 0) return { index, match: hn }\n    }\n    {\n      const nl = nn.toLocaleLowerCase()\n      const hl = hn.toLocaleLowerCase()\n      const index = nl.indexOf(hl)\n      if (index >= 0) return { index, match: hl }\n    }\n  }\n  return\n}\n\n/**\n * Is any item in `haystack` included in `needle`?\n */\nexport function hasAnyIgnoreCase(haystack: string[], needle: string): boolean {\n  return isEmpty(haystack) || blank(needle)\n    ? false\n    : haystack.some(ea => equalsIgnoreCase(needle, ea))\n}\n\nexport function reverse(s: string): string {\n  return s == null ? s : s.split(\"\").reverse().join(\"\")\n}\n\nexport type Stringable = { valueOf(): string }\n\n/**\n * Return the longest-matching prefix pattern from `patterns` that needle\n * startsWith.\n */\nexport function longestPrefix(\n  needle: string,\n  patterns: string[]\n): Maybe<string> {\n  return greatestBy(\n    patterns.filter(ea => needle.startsWith(ea)),\n    ea => ea.length\n  )\n}\n\n// \\u001b[90m\nexport function stripAnsiEsc(s: string): string {\n  // eslint-disable-next-line no-control-regex\n  return toS(s).replace(/\\u001b\\[[0-9;]+[a-z]/gi, \"\")\n}\n\nconst Smart2Dumb: [RegExp, string][] = [\n  [/[\u2018\u2019]/g, `'`],\n  [/[\u201C\u201D\u201E\u00AB\u00BB\u201D\u3003]/g, `\"`]\n]\n\nexport function dumbquote(s: string): string {\n  return Smart2Dumb.reduce(\n    (acc, [smart, dumb]) => acc.replace(smart, dumb),\n    s\n  ).normalize()\n}\n\nconst quoted = /^(['\"]).+\\1$/\n\nexport function stripQuotes(s: string): string {\n  if (blank(s)) return s\n  // Some Vivitar cameras have numeric models (!!) so we need to toS().\n  s = toS(s).trim()\n  if (quoted.exec(dumbquote(s)) != null) {\n    s = s.slice(1, -1).trim()\n  }\n  return s\n}\n\nexport function wbrPath(s: string): string {\n  return s\n    .split(/(?<=[\\\\/_,:=-]+)/)\n    .map(ea => he.escape(ea.normalize()) as string)\n    .join(\"<wbr>\")\n}\n\nexport function zipStrings(...arr: string[]): string {\n  let s = \"\"\n  const cb = compactBlanks(arr)\n  const maxLen = Math.max(...cb.map(ea => ea.length))\n  for (let j = 0; j < maxLen; j++) {\n    for (let i = 0; i < cb.length; i++) {\n      map(cb[i], str => map(str[j], ea => (s += ea)))\n    }\n  }\n  return s\n}\n\nexport function joinEng(arr: string[]): string {\n  arr = compactBlanks(arr)\n  return arr.length < 2\n    ? arr.join(\"\")\n    : arr.slice(0, -1).join(\", \") + \" or \" + arr[arr.length - 1]\n}\n\nexport function splitKeep(s: string, re: RegExp): string[] {\n  const result: string[] = []\n  let pos = 0\n  let m: RegExpExecArray | null\n  while ((m = re.exec(s)) != null) {\n    // This is necessary to avoid infinite loops with zero-width matches\n    if (m.index === re.lastIndex) {\n      re.lastIndex++\n    } else {\n      re.lastIndex = m[0].length + m.index\n      result.push(s.substring(pos, m.index))\n      result.push(s.substring(m.index, re.lastIndex))\n      pos = re.lastIndex\n    }\n  }\n  if (pos < s.length) {\n    result.push(s.substring(pos))\n  }\n  return result.filter(ea => ea.length > 0)\n}\n\nexport function sortNaturalBy(line: string) {\n  return splitKeep(toS(line), /\\d+(?:\\.\\d*)?/g).map(ea =>\n    orElse<number | string>(toFloat(ea.trim()), ea)\n  )\n}\n\nexport function sortNatural(lines: string[]): string[] {\n  return sortBy(lines, line => sortNaturalBy(line))\n}\n\nexport function stripDiacritics(s: string): string {\n  // see https://stackoverflow.com/a/37511463/1268016\n  return toS(s)\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\")\n}\n\nexport function stripEmoji(s: string): string {\n  // see https://stackoverflow.com/a/38987183/1268016\n  return toS(s).replace(\n    /\\ud83c[\\udf00-\\udfff]|\\ud83d[\\udc00-\\ude4f]|\\ud83d[\\ude80-\\udeff]/g,\n    \"\"\n  )\n}\n\nexport function uniqSubstr(arr: string[]): string[] {\n  const rev = sortIgnoreCase(compactBlanks(arr))\n  const result = rev.filter(\n    (ea, idx) => !startsWithIgnoreCase(rev[idx + 1], ea)\n  )\n  return sortBy(result, ea => arr.indexOf(ea))\n}\n", "import { compact } from \"../fe/Array\"\nimport { blank } from \"../fe/Blank\"\nimport { isDate } from \"../fe/Date\"\nimport { defined, map } from \"../fe/Maybe\"\nimport { Maybe, MaybeNull } from \"../fe/MaybeTypes\"\nimport { entries, keys, Obj } from \"../fe/Object\"\nimport { isPrimitive, Primitive } from \"../fe/Primitive\"\nimport { Thunk } from \"../fe/Thunk\"\nimport { first } from \"./Array\"\nimport { eql } from \"./Eql\"\nimport { equalsIgnoreCase } from \"./String\"\n\n// TODO: INLINE\nexport type Pojo = Obj\n\n// \"{ new(): T }\"\n// is from https://www.typescriptlang.org/docs/handbook/generics.html#using-class-types-in-generics\nexport interface Constructor<M> {\n  new (...args: any[]): M\n}\n\nexport function definedThunks(...thunks: Thunk<any>[]): boolean {\n  return thunks.every(ea => defined(ea()))\n}\n\nexport function firstThunk<T>(...thunks: Thunk<Maybe<T>>[]): Maybe<T> {\n  for (const t of thunks) {\n    const r = t()\n    if (r != null) {\n      return r\n    }\n  }\n  return\n}\n\nexport function firstTrueThunk<T>(\n  thunks: Thunk<Maybe<T>>[],\n  predicate?: (t: T) => boolean\n): Maybe<T> {\n  for (const t of thunks) {\n    const r = t()\n    if (r != null && (predicate == null || predicate(r))) {\n      return r\n    }\n  }\n  return\n}\n\nexport function firstDefined<T>(...objects: MaybeNull<T>[]): Maybe<T> {\n  return objects.find(defined)\n}\n\nexport function firstDefinedField<T, K extends keyof T>(\n  obj: T,\n  ...fieldNames: K[]\n): Maybe<T[K]> {\n  return map(\n    fieldNames.find(field => null != obj[field]),\n    fieldName => obj[fieldName]\n  )\n}\n\nexport function firstFieldLike<T extends Pojo, K extends keyof T>(\n  obj: T,\n  predicate: (key: K, value: T[K]) => boolean\n): Maybe<T[K]> {\n  return first(\n    keys(obj) as K[], // SITS: why is this cast needed?\n    key => (predicate(key, obj[key]) ? obj[key] : undefined)\n  )\n}\n\n// knex interprets undefined parameters as runtime mistakes, so use null:\nexport function ornull<T>(a?: T): T | null {\n  return a === undefined ? null : a\n}\n\nexport function mapAnd<T>(obj: MaybeNull<T>, f: (t: T) => boolean): boolean {\n  return obj != null ? f(obj) : false\n}\n\nexport function mapOrThrow<T, R>(\n  obj: MaybeNull<T>,\n  f: (t: T) => R,\n  errIfMissing: string\n): R {\n  if (obj != null) {\n    return f(obj)\n  } else {\n    throw new Error(errIfMissing)\n  }\n}\n\nexport function Try<T>(\n  f: () => T,\n  onError?: (error: Error) => Maybe<T>\n): Maybe<T> {\n  try {\n    return f()\n  } catch (err) {\n    return onError != null ? onError(err) : undefined\n  }\n}\n\nexport function tryEach<T>(iter: Iterable<T>, f: (t: T) => any): void {\n  ;[...iter].forEach(ea => Try(() => f(ea)))\n}\n\nexport function identity<T>(t: T) {\n  return t\n}\n\nexport function ctor(obj: any): Maybe<string> {\n  return map(obj.constructor, ea => ea.name)\n}\n\nexport function hasKeys(obj: any): boolean {\n  return Object.keys(obj).some(\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions, no-prototype-builtins\n    k => typeof k === \"string\" && obj.propertyIsEnumerable(k)\n  )\n}\n\n/**\n * primitive and Dates\n */\nexport function primitiveEntries(o: Pojo): [string, Primitive][] {\n  return keys(o)\n    .filter(k => isPrimitive(o[k]) || isDate(o[k]))\n    .map(k => [k, o[k]] as [string, Primitive])\n}\n\nexport function spread<T extends Pojo>(\n  defaults: T,\n  ...sources: MaybeNull<Partial<T>>[]\n): T {\n  return Object.assign({} as T, defaults, ...compact(sources))\n}\n\nexport function assignMissingPrimitives<T>(dest: T, src: Maybe<Partial<T>>): T {\n  if (src == null) {\n    return dest\n  }\n  for (const [k, v] of primitiveEntries(src)) {\n    if (dest[k] == null) {\n      dest[k] = v\n    }\n  }\n  return dest\n}\n\nexport function assignFields<T>(dest: T, src: Maybe<Pick<T, any>>): T {\n  if (src == null) {\n    return dest\n  }\n  for (const [k, v] of entries(src)) {\n    if (v != null) (dest as any)[k] = v\n  }\n  return dest\n}\n\nexport function pickMap<K extends string, V, U>(\n  obj: Record<K, V>,\n  keysToRetain: K[],\n  f: (key: K, value: V) => U\n): Record<K, U> {\n  const r = {} as Record<K, U>\n  for (const k of keysToRetain) {\n    r[k] = f(k, obj[k])\n  }\n  return r\n}\n\nexport function mapEntries<T extends Pojo, U>(\n  obj: T,\n  f: (key: keyof T & string, value: T[keyof T]) => Maybe<U>\n): Record<keyof T, U> {\n  const r = {} as Record<keyof T, U>\n  for (const k of keys(obj)) {\n    // PERF: UNROLL\n    const v = f(k, obj[k])\n    if (v != null) r[k] = v\n  }\n  return r\n}\n\n/**\n * Do all fields in `a` match `b`?\n */\nexport function eqlSubset<T>(a: Maybe<Pick<T, any>>, b: T): boolean {\n  return a == null ? false : keys(a).every(ea => eql(a[ea], b[ea]))\n}\n\n/**\n * For a given field name, what's o[fieldpath]?\n *\n * If fieldpath includes \".\", those will be used to find sub-objects.\n */\nexport function valpath(o: any, ciFieldPath: string): any {\n  if (ciFieldPath == null || o == null || blank(ciFieldPath)) return o\n  if (Array.isArray(o)) return compact(o.map(ea => valpath(ea, ciFieldPath)))\n  const nextDot = ciFieldPath.indexOf(\".\")\n  const field = nextDot < 0 ? ciFieldPath : ciFieldPath.slice(0, nextDot)\n  const fieldRemains = nextDot < 0 ? undefined : ciFieldPath.slice(nextDot + 1)\n  const k = keys(o)\n  if (k.includes(field)) return valpath(o[field], fieldRemains!)\n  const ciField = k.find(ea => equalsIgnoreCase(ea, field))\n  if (ciField != null) {\n    return valpath(o[ciField], fieldRemains!)\n  }\n  return\n}\n", "import { PromiseState } from \"./PromiseState\"\n\n// This is used by logging, so it can't have any dependencies.\n\n/**\n * Simple one-count concurrent barrier\n */\nexport class Latch implements PromiseLike<void> {\n  // Expose `promise` so we can have a honest-to-goodness Promise\n  readonly promise: Promise<void>\n  private _state: PromiseState = \"pending\"\n  private _resolve!: () => void\n  private _reject!: (err?: Error) => void\n\n  constructor(readonly id?: any) {\n    this.promise = new Promise<void>((resolve, reject) => {\n      this._resolve = resolve\n      this._reject = reject\n    })\n  }\n\n  resolve(): Latch {\n    if (this.pending) {\n      this._resolve()\n      this._state = \"resolved\"\n    }\n    return this\n  }\n\n  reject(err?: Error): Latch {\n    if (this.pending) {\n      this._reject(err)\n      this._state = \"rejected\"\n    }\n    return this\n  }\n\n  finally(f: () => any): this {\n    this.promise.finally(f)\n    return this\n  }\n\n  observe(p: Promise<any>): this {\n    p.then(\n      () => this.resolve(),\n      err => this.reject(err)\n    )\n    return this\n  }\n\n  observeQuietly(p: Promise<any>): this {\n    p.then(\n      () => this.resolve(),\n      () => this.resolve()\n    )\n    return this\n  }\n\n  get pending(): boolean {\n    return this._state === \"pending\"\n  }\n\n  get settled() {\n    return !this.pending\n  }\n\n  get resolved() {\n    return this._state === \"resolved\"\n  }\n\n  get rejected() {\n    return this._state === \"rejected\"\n  }\n\n  get state(): PromiseState {\n    return this._state\n  }\n\n  then<T1, T2>(\n    onfulfilled?: ((v: void) => T1 | PromiseLike<T1>) | undefined | null,\n    onrejected?: ((reason: any) => T2 | PromiseLike<T2>) | undefined | null\n  ): Promise<T1 | T2> {\n    return this.promise.then(onfulfilled, onrejected)\n  }\n}\n", "import { inspect } from \"util\"\nimport { flatten, mapNotEmpty } from \"../../fe/Array\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { sigFigs } from \"../../fe/Number\"\nimport { tap } from \"../../fe/Object\"\nimport { zip } from \"../Array\"\nimport { BoundedList } from \"../BoundedList\"\nimport { CountingSet } from \"../CountingSet\"\nimport { mapGt0 } from \"../Number\"\nimport { avg, slope, stdDev, weightedAvg } from \"./Vector\"\n\nexport interface AverageStats {\n  k: number\n  mean?: number\n  mode?: number\n  sd?: number\n  max?: number\n  min?: number\n  sum?: number\n}\n\nexport function averageStats(vec: number[]) {\n  return new Average().pushAll(vec).stats()\n}\n\nexport class Average {\n  static merge(a: Average, b: Average): Average {\n    if (a.n === 0 && b.n === 0) {\n      return new Average(Math.max(a.maxSamples, b.maxSamples))\n    } else if (a.n === 0) {\n      return b.clone()\n    } else if (b.n === 0) {\n      return a.clone()\n    } else if (a.n <= a.maxSamples) {\n      const r = b.clone()\n      r.pushAll(a.samples)\n      return r\n    } else if (b.n <= b.maxSamples) {\n      const r = a.clone()\n      r.pushAll(b.samples)\n      return r\n    } else {\n      const r = new Average(Math.max(a.maxSamples, b.maxSamples))\n      r._n = a.n + b.n\n      r._avg = (a._avg! * a.n) / r.n + (b._avg! * b.n) / r.n\n      r._min = Math.min(a._min!, b._min!)\n      r._max = Math.max(a._max!, b._max!)\n      r._m = (a._m! * a.n) / r.n + (b._m! * b.n) / r.n\n      r._s = (a._s! * a.n) / r.n + (b._s! * b.n) / r.n\n      const samples = flatten(zip(a.samples, b.samples))\n      r._samples.push(...samples)\n      r._weightedTotalAvg = weightedAvg([r._avg, ...samples])\n      return r\n    }\n  }\n\n  protected _n: number\n  protected _avg?: number\n  protected _min?: number\n  protected _max?: number\n  protected _m?: number\n  protected _s?: number\n  protected _weightedTotalAvg?: number\n  protected readonly _samples: BoundedList<number>\n\n  constructor(readonly maxSamples: number = 20) {\n    this._n = 0\n    this._samples = new BoundedList(maxSamples)\n  }\n\n  [inspect.custom]() {\n    return this.stats()\n  }\n\n  push(x: number): number {\n    if (!isFinite(x)) throw new Error(\"Average.push(\" + x + \"): not a number\")\n    this._n++\n    this._samples.push(x)\n    this._min = this._min == null ? x : Math.min(x, this._min)\n    this._max = this._max == null ? x : Math.max(x, this._max)\n\n    // https://math.stackexchange.com/a/116344\n    // https://www.johndcook.com/blog/standard_deviation/\n    if (\n      this._n === 1 ||\n      this._m == null ||\n      this._s == null ||\n      this._avg == null ||\n      this._weightedTotalAvg == null\n    ) {\n      this._m = x\n      this._s = 0\n      this._avg = x\n      this._weightedTotalAvg = x\n    } else {\n      const priorM = this._m\n      this._m += (x - this._m) / this._n\n      this._s += (x - priorM) * (x - this._m)\n      this._avg = (this._avg * (this._n - 1)) / this._n + x / this._n\n      this._weightedTotalAvg = (this._weightedTotalAvg + x) / 2\n    }\n    return x\n  }\n\n  clone(): Average {\n    return tap(new Average(this.maxSamples), ea => {\n      ea._n = this._n\n      ea._avg = this._avg\n      ea._min = this._min\n      ea._max = this._max\n      ea._m = this._m\n      ea._s = this._s\n      ea._weightedTotalAvg = this._weightedTotalAvg\n      ea._samples.push(...this._samples)\n    })\n  }\n\n  pushAll(arr: number[]): this {\n    arr.forEach(ea => this.push(ea))\n    return this\n  }\n\n  stats(sigfigs = 2): AverageStats {\n    const sf = (i?: number) => map(i, (ea: number) => sigFigs(ea, sigfigs))\n    const o: AverageStats = {} as any\n    if (!this.empty) {\n      o.sum = sf(this.sum)\n      o.mean = sf(this.avg)\n      // o.mode = sf(this.sampleMode)\n      o.sd = sf(this.stdDev)\n      // o.max = sf(this.max)\n      // o.min = sf(this.min)\n    }\n    o.k = sigFigs(this.n, sigfigs)\n    return o\n  }\n\n  get empty(): boolean {\n    return this._n === 0\n  }\n\n  /**\n   * @return the total number of samples provided to `push()`\n   */\n  get n(): number {\n    return this._n\n  }\n\n  get avg(): Maybe<number> {\n    return this.empty ? undefined : sigFigs(this._avg!, 4)\n  }\n\n  get sum(): number {\n    return this._avg == null || this.empty ? 0 : this._avg! * this._n\n  }\n\n  get max(): Maybe<number> {\n    return this._max\n  }\n\n  get min(): Maybe<number> {\n    return this._min\n  }\n\n  /**\n   * @return mean + 1 SD\n   */\n  get p84(): Maybe<number> {\n    return mapGt0(this.avg, ea => mapGt0(this.stdDev, sd => ea + sd))\n  }\n\n  get variance(): Maybe<number> {\n    return this._n <= 1 ? undefined : this._s! / (this._n - 1)\n  }\n\n  get stdDev(): Maybe<number> {\n    return map(this.variance, Math.sqrt)\n  }\n\n  get sampleMode(): Maybe<number> {\n    return map(this.sampleModes(1), ea => ea[0])\n  }\n\n  sampleModes(n: number): Maybe<number[]> {\n    if (this.empty) return\n    const c = new CountingSet<number>()\n    this._samples.forEach(ea => c.incr(ea))\n    return c.topKeys(n)\n  }\n\n  get sampleStdDev(): Maybe<number> {\n    return mapNotEmpty(this._samples, stdDev)\n  }\n\n  get sampleAvg(): Maybe<number> {\n    return mapNotEmpty(this._samples, avg)\n  }\n\n  get sampleSlope(): number {\n    return orElse(mapNotEmpty(this._samples, slope), 0)\n  }\n\n  get samples(): number[] {\n    return [...this._samples]\n  }\n\n  p(percentile: number): number {\n    if (this._samples.length === 0) return 0 // NaN instead?\n    const arr = [...this._samples].sort((a, b) => a - b)\n    const idx = Math.floor(arr.length * (percentile / 100))\n    return arr[idx]\n  }\n\n  /**\n   * weighted average of the last `sampleCount` values\n   */\n  get weightedSampleAvg(): Maybe<number> {\n    return mapNotEmpty(this._samples, arr => sigFigs(weightedAvg(arr), 4))\n  }\n\n  /**\n   * weighted average of all values\n   */\n  get weightedTotalAvg(): Maybe<number> {\n    return this._weightedTotalAvg\n  }\n\n  clear(): void {\n    this._avg = 0\n    this._n = 0\n    this._weightedTotalAvg = 0\n    this._samples.length = 0\n  }\n}\n", "import { List } from \"../fe/List\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { clamp, times } from \"../fe/Number\"\n\nexport class BoundedList<T> implements Iterable<T>, List<T> {\n  // round-robin implementation:\n  private readonly store: T[]\n  private _length = 0\n  private _firstIndex = 0\n  constructor(readonly maxLength: number) {\n    if (maxLength > 1000)\n      throw new Error(\"BoundedList.maxLength of \" + maxLength)\n    this.store = new Array<T>(...(times(maxLength, () => null) as any))\n  }\n\n  /**\n   * @param index follows https://github.com/tc39/proposal-item-method\n   */\n  private mapIndex<U>(index: number, f: (storeIndex: number) => U): Maybe<U> {\n    index = Math.trunc(index) ?? 0\n    if (index < 0) {\n      index += this._length\n    }\n    return index < 0 || index > this._length - 1\n      ? undefined\n      : f((index + this._firstIndex + this.maxLength) % this.maxLength)\n  }\n\n  // [i: number]: T {\n  //   return this.get(i) as any\n  // }\n\n  /**\n   * @see https://github.com/tc39/proposal-item-method\n   */\n  item(n: number): T {\n    return this.mapIndex(n, idx => this.store[idx]) as T\n  }\n\n  set(n: number, value: T) {\n    return this.mapIndex(n, idx => (this.store[idx] = value))\n  }\n\n  get length(): number {\n    return this._length\n  }\n\n  set length(l: number) {\n    this._length = clamp(0, this._length, l)\n  }\n\n  clear() {\n    this.length = 0\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<T> {\n      for (let i = 0; i < self.length; i++) {\n        yield self.mapIndex(i, ea => self.store[ea])!\n      }\n    }\n    return iter()\n  }\n\n  push(...items: T[]): number {\n    // Don't bother pushing more than the last maxLength items:\n    for (const item of items.slice(-this.maxLength)) {\n      if (this._length < this.maxLength) {\n        this._length++\n      } else {\n        // push 1 entry off the head:\n        this._firstIndex++\n        this._firstIndex = this._firstIndex % this.maxLength\n      }\n      this.mapIndex(this._length - 1, idx => {\n        this.store[idx] = item\n      })\n    }\n    return this._length\n  }\n\n  pop(): T | undefined {\n    return this.mapIndex(this._length - 1, idx => {\n      this._length--\n      return this.store[idx]\n    })\n  }\n\n  unshift(...items: T[]): number {\n    for (const item of items.reverse()) {\n      if (this._length < this.maxLength) {\n        this._length++\n      }\n      // push 1 entry off the head:\n      this._firstIndex--\n      this.mapIndex(0, idx => {\n        this.store[idx] = item\n        this._firstIndex = idx\n      })\n    }\n    return this._length\n  }\n\n  shift(): T | undefined {\n    return this.mapIndex(0, idx => {\n      this._firstIndex++\n      this._length--\n      return this.store[idx]\n    })\n  }\n\n  shiftOrFirst() {\n    return this.length > 1 ? this.shift() : this.item(0)\n  }\n\n  every(callbackfn: (value: T, index: number) => boolean): boolean {\n    for (let i = 0; i < this._length; i++) {\n      if (!callbackfn(this.item(i), i)) return false\n    }\n    return true\n  }\n\n  some(callbackfn: (value: T, index: number) => boolean): boolean {\n    for (let i = 0; i < this._length; i++) {\n      if (callbackfn(this.item(i), i)) return true\n    }\n    return false\n  }\n\n  forEach(callbackfn: (value: T, index: number) => void): void {\n    for (let i = 0; i < this._length; i++) {\n      callbackfn(this.item(i), i)\n    }\n  }\n\n  map<U>(callbackfn: (value: T, index: number) => U): U[] {\n    const arr = []\n    for (let i = 0; i < this._length; i++) {\n      arr.push(callbackfn(this.item(i), i))\n    }\n    return arr\n  }\n\n  reduce<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: number) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue\n    for (let i = 0; i < this._length; i++) {\n      acc = callbackfn(acc, this.item(i), i)\n    }\n    return acc\n  }\n\n  reverse(): this {\n    for (let i = 0; i < Math.floor(this._length / 2); i++) {\n      this.mapIndex(i, from => {\n        this.mapIndex(this._length - 1 - i, to => {\n          const swap = this.store[to]\n          this.store[to] = this.store[from]\n          this.store[from] = swap\n        })\n      })\n    }\n    return this\n  }\n\n  toA(): T[] {\n    return [...this]\n  }\n\n  slice(start?: number | undefined, end?: number | undefined): T[] {\n    return [...this].slice(start, end)\n  }\n\n  // sort(compareFn?: ((a: T, b: T) => number) | undefined): this {\n  //   throw new Error(\"Method not implemented.\")\n  // }\n  // indexOf(searchElement: T, fromIndex?: number | undefined): number {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // lastIndexOf(searchElement: T, fromIndex?: number | undefined): number {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];\n  // filter(callbackfn: (value: T, index: number, array: T[]) => , thisArg?: any): T[];\n  // filter(callbackfn: any, thisArg?: any) {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n  // reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n  // reduce(callbackfn: any, initialValue?: any) {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n  // reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n  // reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n  // reduceRight(callbackfn: any, initialValue?: any) {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // find<S extends T>(predicate: (this: void, value: T, index: number, obj: T[]) => value is S, thisArg?: any): S | undefined;\n  // find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined;\n  // find(predicate: any, thisArg?: any) {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // fill(value: T, start?: number | undefined, end?: number | undefined): this {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // copyWithin(target: number, start: number, end?: number | undefined): this {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // entries(): IterableIterator<[number, T]> {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // keys(): IterableIterator<number> {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // values(): IterableIterator<T> {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // [Symbol.unscopables](): { copyWithin: boolean; entries: boolean; fill: boolean; find: boolean; findIndex: boolean; keys: boolean; values: boolean; } {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n  // includes(searchElement: T, fromIndex?: number | undefined): boolean {\n  //   throw new Error(\"Method not implemented.\");\n  // }\n}\n", "import { sort, sortBy } from \"../fe/Array\"\nimport { orElse } from \"../fe/Maybe\"\nimport { isNumber, mapNumericOr } from \"../fe/Number\"\nimport { tap } from \"../fe/Object\"\nimport { Average } from \"./math/Average\"\n\nexport class CountingSet<K extends number | string> {\n  private readonly m = new Map<K, number>()\n\n  incr(key: K, count: number = 1): this {\n    const v = this.get(key) + count\n    if (v === 0) this.m.delete(key)\n    else this.m.set(key, v)\n    return this\n  }\n\n  get(key: K): number {\n    return orElse(this.m.get(key), () => 0)\n  }\n\n  has(key: K): boolean {\n    return this.m.has(key)\n  }\n\n  /**\n   * Return the number of non-zero `incr`emented keys\n   */\n  get size(): number {\n    return this.m.size\n  }\n\n  keys(): IterableIterator<K> {\n    return this.m.keys()\n  }\n\n  keyAvg() {\n    const avg = new Average(0)\n    for (const k of this.keys()) {\n      if (isNumber(k)) {\n        avg.push(k)\n      } else {\n        return\n      }\n    }\n    return avg.avg\n  }\n\n  entries(): IterableIterator<[K, number]> {\n    return this.m.entries()\n  }\n\n  /** Multimodal ties are solved by proximity to mean */\n  entriesByCountDesc(): [K, number][] {\n    const keyAvg = this.keyAvg()\n    return sortBy([...this.entries()], ([k, v]) => [\n      -v,\n      mapNumericOr(keyAvg, ea => Math.abs((k as number) - ea), 0)\n    ])\n  }\n\n  top(n = 1): [K, number][] {\n    return this.entriesByCountDesc().slice(0, n)\n  }\n\n  topKeys(n = 1): K[] {\n    return this.top(n).map(ea => ea[0])\n  }\n\n  get averageCounts(): Average {\n    return tap(new Average(this.size), a =>\n      [...this.m.values()].forEach(ea => a.push(ea))\n    )\n  }\n\n  forEach(callbackfn: (count: number, key: K) => void): void {\n    this.m.forEach(callbackfn)\n  }\n\n  clear(): void {\n    this.m.clear()\n  }\n\n  get toS() {\n    return sort([...this.keys()])\n      .map(key => key + \" \" + this.get(key))\n      .join(\"\\n\")\n  }\n}\n", "import { count, flatten, isEmpty } from \"../fe/Array\"\nimport { blank } from \"../fe/Blank\"\nimport { map, orElse } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport {\n  clamp,\n  gt0,\n  gte,\n  isNumber,\n  lte,\n  map2Numeric,\n  mapInt,\n  mapNumeric,\n  toFloat,\n  toInt\n} from \"../fe/Number\"\nimport { toS } from \"../fe/toS\"\nimport { leftPad } from \"./String\"\n\nexport function firstGt0(...objects: any[]): Maybe<number> {\n  return objects.find(gt0)\n}\n\n/**\n * @return the first element in `objects` that can be parsed into a number and is\n * greater than zero.\n */\nexport function firstNonZero(...objects: any[]): Maybe<number> {\n  for (const ea of flatten(objects)) {\n    const f = toFloat(ea)\n    if (f != null && f !== 0) return f\n  }\n  return undefined\n}\n\nexport function mapGte0<T>(n: any, f: (i: number) => T): Maybe<T> {\n  return mapInt(n, i => (i >= 0 ? f(i) : undefined))\n}\n\nexport function mapGte0Or<T>(\n  n: any,\n  f: (i: number) => T,\n  defaultValue: T | (() => T)\n): T {\n  return orElse(mapGte0(n, f), defaultValue)\n}\n\nexport function mapGte0f<T>(n: any, f: (i: number) => T): Maybe<T> {\n  return mapNumeric(n, i => (i >= 0 ? f(i) : undefined))\n}\n\nexport function mapGt0<T>(n: any, f: (i: number) => T): Maybe<T> {\n  return mapInt(n, i => (i > 0 ? f(i) : undefined))\n}\n\nexport function mapGt0f<T>(n: any, f: (i: number) => T): Maybe<T> {\n  return mapNumeric(n, i => (i > 0 ? f(i) : undefined))\n}\n\nexport function mapGt0Or<T>(\n  n: any,\n  f: (i: number) => T,\n  defaultValue: T | (() => T)\n): T {\n  return orElse(mapGt0(n, f), defaultValue)\n}\n\n/**\n * @param min inclusive\n * @param max inclusive\n */\nexport function within(min: number, max: number, n: any): n is number {\n  if (n == null || !isNumber(n)) return false\n  ;[min, max] = [Math.min(min, max), Math.max(min, max)]\n  return gte(n, min) && lte(n, max)\n}\n\n// WAT WAT WAAAAAT? (this is the simplest regex I could come up with that\n// supported both \"-123\", \"+123.\", \"-123.456\" and \"-.789\") \\\n\n// I could do this:\n// const validFloatRe = /((?:[+-]?[0-9]+(?:\\.[0-9]*)?)|(?:[+-]?[0-9]*(?:\\.[0-9]+)))/\n\n// but that sort of rigor isn't necessary. parseFloat is fine with parsing\n// \"-123.456GUACAMOLE\".\nconst numstartRe = /[+-]?[0-9\\,\\.]+/\n\n/**\n * Pull out the first float from `value`.\n *\n * This method ignores any non-numeric characters that prefix or suffix the\n * first number (as opposed to `toFloat`, which ignores only non-numeric\n * suffixes)\n */\nexport function extractFloat(value: any): Maybe<number> {\n  if (isNumber(value)) return value\n  if (blank(value)) return undefined\n  const s = String(value)\n  return map(numstartRe.exec(s), m => toFloat(s.substr(m.index)))\n}\n\n/**\n * Pull out the first integer from `value`.\n *\n * This method ignores any non-numeric characters that prefix or suffix the\n * first number (as opposed to `toInt`, which ignores only non-numeric suffixes)\n */\nexport function extractInt(value: any): Maybe<number> {\n  return toInt(extractFloat(value))\n}\n\nexport function extractFraction(value: any): Maybe<number> {\n  if (isNumber(value)) return value\n  const s = toS(value)\n  if (s.includes(\"/\")) {\n    const arr = s.split(\"/\", 2)\n    return map2Numeric(extractInt(arr[0]), extractInt(arr[1]), (i, j) => i / j)\n  } else {\n    return extractFloat(s)\n  }\n}\n\nexport function assertPositive(name: string, value?: number) {\n  if (value == null || value <= 0) {\n    throw new Error(name + \" must be positive\")\n  }\n}\n\nexport class Array2D {\n  private readonly store: number[] = []\n  constructor(readonly columns: number) {}\n  get(row: number, col: number): number {\n    return row < 0 || col < 0\n      ? 0\n      : orElse(this.store[row * this.columns + col], () => 0)\n  }\n  set(row: number, col: number, value: number) {\n    this.store[row * this.columns + col] = value\n  }\n}\n\nfunction prepHammBigInts(\n  a: number | BigInt,\n  b: number | BigInt\n): Maybe<[string, string]> {\n  if (a == null || b == null) return\n  const arr = [a, b].map(ea => ea.toString(2))\n  const maxLen = Math.max(...arr.map(ea => ea.length))\n  return arr.map(ea => leftPad(ea, maxLen, \"0\")) as [string, string]\n}\n\n/**\n * @return the number of bits not matching between a and b\n */\nexport function hammingDistanceBigInt(\n  a: number | BigInt,\n  b: number | BigInt\n): Maybe<number> {\n  return map(prepHammBigInts(a, b), ([s1, s2]) =>\n    count(s1.split(\"\"), (ea, idx) => ea !== s2.charAt(idx))\n  )\n}\n\n/**\n * @return `matching bits / total bits`. 1 == complete match.\n */\nexport function hammRatioBigInt(\n  a: Maybe<number | BigInt>,\n  b: Maybe<number | BigInt>\n): Maybe<number> {\n  if (a == null || b == null) return 0\n  return map(prepHammBigInts(a, b), ([i, j]) => hammRatioBinaryString(i, j))\n}\n\nexport function hammRatioBinaryString(a: string, b: string) {\n  if (a === b) return 1\n  if (a.length !== b.length)\n    throw new Error(`hammRatioBinaryString(${a}, ${b}): invalid lengths`)\n  let matching = 0\n  // console.log(\"hammRatioBinaryString a\")\n  // console.log(splitEvery(a, 24).join(\"\\n\"))\n  // console.log(\"hammRatioBinaryString b\")\n  // console.log(splitEvery(b, 24).join(\"\\n\"))\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === b[i]) matching++\n  }\n  // console.log(\"matching: \" + matching)\n  // 50% match is random. Scale that to 0.\n  return clamp(0, 1, (2 * matching) / a.length - 1)\n}\n\nexport function valuesToBigInt(arr: number[], bitsPerValue: number): BigInt {\n  if (isEmpty(arr)) return BigInt(0)\n  return BigInt(\n    \"0b0\" +\n      arr.map(ea => leftPad(ea.toString(2), bitsPerValue - 1, \"0\")).join(\"\")\n  )\n}\n", "import { Maybe } from \"../fe/MaybeTypes\"\nimport { Primitive } from \"../fe/Primitive\"\nimport { toA } from \"../fe/toA\"\n\nexport function asSet<T>(s: Maybe<Iterable<T>>): Set<T> {\n  return s instanceof Set ? s : new Set(toA(s))\n}\n\nexport function setEql<T>(a: Set<T>, b: Set<T>): boolean {\n  return (\n    toA(a.keys()).every(ea => b.has(ea)) && toA(b.keys()).every(ea => a.has(ea))\n  )\n}\n\nexport function getOrAdd<K, V>(s: Set<K>, k: K, onAdd: () => V): Maybe<V> {\n  if (k == null) throw new Error(\"null key\")\n  if (s.has(k)) {\n    return undefined\n  } else {\n    s.add(k)\n    return onAdd()\n  }\n}\n\n//\n// These only support primitives, as comparison is done with ==\n//\n\n/**\n * @return unique elements in a or b\n */\nexport function union<T extends Primitive>(\n  a: Iterable<T>,\n  b: Iterable<T>\n): Set<T> {\n  return new Set([...a, ...b])\n}\n\n/**\n * @return elements in a that are also in b\n */\nexport function intersection<T extends Primitive>(\n  a: Iterable<T>,\n  b: Iterable<T>\n): Set<T> {\n  const s = asSet(b)\n  return new Set([...a].filter(ea => s.has(ea)))\n}\n\n/**\n * @return elements in `a` that are not in `b`\n */\nexport function diff<T extends Primitive>(\n  a: Iterable<T>,\n  b: Iterable<T>\n): Set<T> {\n  const s = asSet(b)\n  return new Set([...a].filter(ea => !s.has(ea)))\n}\n", "import { compact, isEmpty } from \"../../fe/Array\"\nimport { List } from \"../../fe/List\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { finiteOrElse, isNumber, mapFinite, times } from \"../../fe/Number\"\nimport { Arrayish, toA } from \"../../fe/toA\"\nimport { CountingSet } from \"../CountingSet\"\nimport { mapGt0Or } from \"../Number\"\nimport { intersection, union } from \"../Set\"\n\nexport type NumericList =\n  | List<number>\n  | number[]\n  | Float32Array\n  | Uint32Array\n  | Int32Array\n\nexport type Numberlist = Arrayish<number>\n\nexport function min<T>(vec: List<Maybe<T>>) {\n  let result\n  for (const ea of vec) {\n    if (ea != null) {\n      if (result == null || ea < result) {\n        result = ea\n      }\n    }\n  }\n  return result\n}\n\nexport function max<T>(vec: List<Maybe<T>>) {\n  let result\n  for (const ea of vec) {\n    if (ea != null) {\n      if (result == null || ea > result) {\n        result = ea\n      }\n    }\n  }\n  return result\n}\n\n/**\n * @return `[arr[1] - arr[0], arr[2] - arr[1], ...]`\n */\nexport function deltas(vec: Numberlist): number[] {\n  const l = toA(vec)\n  if (vec == null || l.length <= 1) return []\n  return l.slice(1).map((ea, idx) => ea - vec[idx])\n}\n\nexport function modes(vec: Numberlist, topN: number): number[] {\n  const cs = new CountingSet<number>()\n  toA(vec).forEach(i => mapFinite(i, ea => cs.incr(ea)))\n  return cs.topKeys(topN)\n}\n\nexport function mode(vec: number[]): Maybe<number> {\n  return modes(vec, 1)[0]\n}\n\nexport function sum(vec: Numberlist): number {\n  return toA(vec).reduce((acc, ea) => (isNumber(ea) ? acc + ea : acc), 0)\n}\n\nexport function avg(vec: Arrayish<Maybe<number>>): Maybe<number> {\n  const l = compact(toA(vec))\n  return isEmpty(l)\n    ? undefined\n    : l.reduce(\n        (mean, ea, idx) =>\n          // Prevent overflow:\n          idx === 0 ? ea : (mean * idx) / (idx + 1) + ea / (idx + 1),\n        0\n      )\n}\n\n/**\n * @param strength how strong should the normalization be applied. [0,1]\n */\nexport function normalize({\n  x,\n  strength = 1,\n  normMin,\n  normMax\n}: {\n  x: number[]\n  strength?: number\n  normMin: number\n  normMax: number\n}): number[] {\n  const xMin = min(x)!\n  const xRange = max(x)! - xMin\n  const normRange = normMax - normMin\n  return x.map(\n    ea =>\n      (1 - strength) * ea +\n      strength * (normMin + (normRange * (ea - xMin)) / xRange)\n  )\n}\n\nexport function slope(vec: Numberlist): Maybe<number> {\n  const l = toA(vec)\n  return map(avg(l), x_mean => {\n    const y_mean = (l.length - 1) / 2\n    const num = sum(l.map((x, y) => (x - x_mean) * (y - y_mean)))\n    const denom = sum(l.map(x => (x - x_mean) ** 2))\n    return denom === 0 ? 0 : num / denom\n  })\n}\n\nexport function avgMaybe(...m: Maybe<number>[]): Maybe<number> {\n  const arr = compact(m)\n  return isEmpty(arr) ? undefined : sum(arr) / arr.length\n}\n\nexport function variance(arr: List<number>): Maybe<number> {\n  return map(avg(arr), mean => avg(arr.map(i => Math.pow(i - mean, 2))))\n}\n\nexport function stdDev(arr: List<number>): Maybe<number> {\n  return map(variance(arr), ea => Math.sqrt(ea))\n}\n\nexport function weightedAvg(arr: List<number> | Iterable<number>): number {\n  let acc\n  for (const ea of arr) {\n    acc = acc == null ? ea : (acc + ea) / 2\n  }\n  return acc == null ? NaN : acc\n}\n\nexport function avgWeighted(arr: List<number>, weights: List<number>): number {\n  let wSum = 0\n  return (\n    arr.reduce((agg, ea, idx) => {\n      const w = mapGt0Or(weights[idx], identity => identity, 1)\n      wSum += w\n      return agg + ea * w\n    }, 0) / wSum\n  )\n}\n\nexport function euclidean<T extends NumericList>(x: T, y: T): number {\n  return Math.sqrt(\n    toA(x).reduce((sum_, ea, idx) => sum_ + Math.pow(ea - y[idx], 2), 0)\n  )\n}\n\nexport function centroid(vectors: NumericList[]): Maybe<number>[] {\n  return times(vectors[0].length, dim => avg(vectors.map(arr => arr[dim])))\n}\n\n/**\n * Euclidean norm, or L2 norm, of a given vector\n * @see https://en.wikipedia.org/wiki/Norm_(mathematics)\n */\nexport function l2norm(vec: List<number>): number {\n  return Math.sqrt(vec.reduce((sum_, ea) => sum_ + ea * ea, 0))\n}\n\n/**\n * @see https://en.wikipedia.org/wiki/Euclidean_vector#Dot_product\n */\nexport function dot(x: number[], y: number[]): number {\n  return x.reduce((sum_, ea, i) => sum_ + ea * y[i], 0)\n}\n\n/**\n * Ranges between -1 (anticorrelation) to 1 (correlation)\n * @see https://en.wikipedia.org/wiki/Cosine_similarity\n */\nexport function cosineSimilarity(x: number[], y: number[]): Maybe<number> {\n  return finiteOrElse(dot(x, y) / (l2norm(x) * l2norm(y)), undefined)\n}\n\n/**\n * Ranges between 0 (no overlap) to 1 (complete overlap)\n */\nexport function jaccard(x: number[], y: number[]): Maybe<number> {\n  return isEmpty(x) && isEmpty(y)\n    ? 0\n    : finiteOrElse(intersection(x, y).size / union(x, y).size, undefined)\n}\n", "import { cpus, freemem, totalmem } from \"os\"\nimport { later } from \"../../fe/Delay\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { clamp } from \"../../fe/Number\"\nimport { GB, MB } from \"../../fe/Units\"\nimport { onClearCache } from \"../event/EventEmitter\"\nimport { Settings } from \"../settings/Settings\"\n\nvoid later(() => {\n  onClearCache(() => {\n    estimatedFreeMem.unset()\n    totalCpus.unset()\n    maxCpus.unset()\n    sharpThreadsPerSystem.unset()\n    maxSyncFileJobs.unset()\n    sharpThreadsPerJob.unset()\n    maxPendingSyncFileJobs.unset()\n  })\n})\n\n// lazy for testing\nexport const estimatedFreeMem = lazy(() => (freemem() * 2 + totalmem()) / 3)\n\nexport const totalCpus = lazy(() => cpus().length)\n\nexport const maxCpus = lazy(() => {\n  // they may bloat, but they'll recycle if they get too big.\n  const worstCaseMemPerProc = 1 * GB\n  // We don't want to over-subscribe system memory, but we need to run at\n  // least one:\n  const maxProcs = Math.max(\n    1,\n    Math.floor(estimatedFreeMem() / worstCaseMemPerProc)\n  )\n  const cpuCount = (Settings.cpuLoadPercent.valueOrDefault / 100) * totalCpus()\n  return clamp(1, maxProcs, Math.floor(cpuCount))\n})\n\nexport const sharpThreadsPerSystem = lazy(() => {\n  const worstCasePerSharpThread = 500 * MB\n  const maxThreadsForMem = Math.floor(\n    estimatedFreeMem() / worstCasePerSharpThread\n  )\n  const maxThreads = Math.max(\n    1,\n    Math.floor(\n      1.5 * totalCpus() * (Settings.cpuLoadPercent.valueOrDefault / 100)\n    )\n  )\n  return clamp(1, maxThreads, maxThreadsForMem)\n})\n\nexport const maxSyncFileJobs = lazy(() => {\n  // We can host 2-6 sharp threads per sync-file. It's better for concurrency to\n  // have > 1 sync-file than > 1 sharp thread, but that uses more memory.\n  return clamp(1, 24, maxCpus())\n})\n\n// Now that we've decided how many sync-file jobs we can run, we can decide how\n// many sharp threads we use per sync-file:\nexport const sharpThreadsPerJob = lazy(() =>\n  // Even if we've got tons of RAM, we don't get a huge performance win with >\n  // 8 graphics threads. 6 is fine.\n  clamp(1, 6, Math.ceil(sharpThreadsPerSystem() / maxSyncFileJobs()))\n)\n\n// 20200929 don't enqueue too many jobs so we don't get timeouts, and  UI sync\n// jobs can be processed in a timely fashion\nexport const maxPendingSyncFileJobs = maxSyncFileJobs\n", "import { EventEmitter } from \"events\"\nimport { mkLogger } from \"../Logger\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { SimpleEventEmitter } from \"./SimpleEventEmitter\"\nimport { TestEventEmitter } from \"./TestEventEmitter\"\n\n// THIS CANNOT IMPORT ANY CORE CODE. It's used everywhere.\n\nconst _testEventEmitter = lazy(() => new TestEventEmitter())\nconst _prodEventEmitter = lazy(() => {\n  const ee = new EventEmitter()\n  ee.setMaxListeners(50) // because of onClearCache()\n  return ee\n})\n\nexport let eventEmitter: SimpleEventEmitter = _prodEventEmitter()\n\nexport function useTestEventEmitter() {\n  return (eventEmitter = _testEventEmitter())\n}\nexport function useProductionEventEmitter() {\n  return (eventEmitter = _prodEventEmitter())\n}\n\nexport function emitClearCache() {\n  mkLogger(\"EventEmitter\").info(\"emitClearCache()\")\n  eventEmitter.emit(\"clearCache\")\n}\n\nexport function onClearCache(thunk: () => any) {\n  eventEmitter.on(\"clearCache\", thunk)\n}\n\nexport function emitIdle() {\n  eventEmitter.emit(\"idle\")\n}\n\nexport function onIdle(listener: () => any) {\n  eventEmitter.on(\"idle\", listener)\n}\n\nexport function emitMigration(migrationName: string) {\n  eventEmitter.emit(\"migration\", migrationName)\n}\n\nexport function onMigration(listener: (migrationName: string) => any) {\n  eventEmitter.on(\"migration\", listener)\n}\n\nexport function emitPause() {\n  eventEmitter.emit(\"pause\")\n}\n\nexport function onPause(listener: () => any) {\n  eventEmitter.on(\"pause\", listener)\n}\n\nexport function emitResume() {\n  eventEmitter.emit(\"resume\")\n}\n\nexport function onResume(listener: () => any) {\n  eventEmitter.on(\"resume\", listener)\n}\n\nexport function emitFileChanged(nativePath?: string) {\n  eventEmitter.emit(\"fileChanged\", nativePath)\n}\n\nexport function onFileCopied(\n  listener: (srcNativePath: string, destNativePath: string) => any\n) {\n  eventEmitter.on(\"fileCopied\", listener)\n}\n\nexport function emitFileCopied(\n  srcNativePath?: string,\n  destNativePath?: string\n) {\n  eventEmitter.emit(\"fileCopied\", srcNativePath, destNativePath)\n}\n\nexport function onFileChanged(listener: (nativePath?: string) => any) {\n  eventEmitter.on(\"fileChanged\", listener)\n}\n\nexport function emitFocus(argv: string[], cwd: string) {\n  eventEmitter.emit(\"focus\", argv, cwd)\n}\n\nexport function onFocus(listener: (argv: string[], cwd: string) => any) {\n  eventEmitter.on(\"focus\", listener)\n}\n\n// NOTE: no emitFatal or emitNonFatal: use onError instead.\n\nexport function onFatal(listener: (message: string, error?: Error) => any) {\n  eventEmitter.on(\"fatal\", ({ message, error }) => listener(message, error))\n}\n\nexport function onNonFatal(listener: (message: string, error?: Error) => any) {\n  eventEmitter.on(\"nonFatal\", ({ message, error }) => listener(message, error))\n}\n\nexport function emitRpcServerChange() {\n  eventEmitter.emit(\"rpcServerChange\")\n}\n\nexport function onRpcServerChange(listener: () => any) {\n  eventEmitter.on(\"rpcServerChange\", listener)\n}\n\nexport let readyToUpdate = false\n\nexport function emitReadyToUpdate() {\n  readyToUpdate = true\n  eventEmitter.emit(\"readyToUpdate\")\n}\n\nexport function onReadyToUpdate(listener: () => any) {\n  eventEmitter.on(\"readyToUpdate\", listener)\n}\n\nexport function emitVolumesChanged() {\n  eventEmitter.emit(\"volumesChanged\")\n}\n\nexport function onVolumesChanged(listener: () => any) {\n  eventEmitter.on(\"volumesChanged\", listener)\n}\n\nexport function emitSettingsChanged() {\n  eventEmitter.emit(\"settingsChanged\")\n}\n\nexport function onSettingsChanged(listener: () => any) {\n  eventEmitter.on(\"settingsChanged\", listener)\n}\n\nexport function emitVacuuming() {\n  eventEmitter.emit(\"settingsChanged\")\n}\n\nexport function onVacuuming(listener: (isVacuuming: boolean) => any) {\n  eventEmitter.on(\"vacuuming\", listener)\n}\n\nexport function emitWriteRecentLogEntries() {\n  eventEmitter.emit(\"writeRecentLogEntries\")\n}\n\nexport function onWriteRecentLogEntries(listener: () => any) {\n  eventEmitter.on(\"writeRecentLogEntries\", listener)\n}\n", "import { EventEmitter } from \"events\"\n\nimport { Event } from \"./Event\"\n\nexport class TestEventEmitter extends EventEmitter {\n  readonly events: Event[] = []\n  emit(name: string | symbol, ...args: any[]): boolean {\n    super.emit(name, ...args)\n    this.events.push({ name, args })\n    return true\n  }\n  clear() {\n    this.events.length = 0\n  }\n}\n", "import { clearTimeout } from \"timers\"\nimport { inspect } from \"util\"\nimport { asError } from \"../../fe/Error\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { PromiseState, PromiseStates } from \"../../fe/PromiseState\"\nimport { isIgnorableError } from \"../error/ErrorTypes\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { Pojo } from \"../Object\"\nimport { isString } from \"../String\"\nimport { setUnrefTimeout } from \"./Timers\"\n\n/**\n * Deferred resolution of a promise with synchronous state\n */\nexport class Deferred<T> implements PromiseLike<T> {\n  private readonly logger: Logger\n  readonly start = Date.now()\n  private end?: number\n  private state: PromiseState = PromiseStates.pending\n  private _value?: T\n  readonly promise: Promise<T>\n  private _resolve!: (value: T) => void\n  private _reject!: (reason?: any) => void\n  private _error: Maybe<Error>\n  private priorTimeout: Maybe<NodeJS.Timeout>\n\n  /**\n   * @param name can be either a string or a data payload to associate with the\n   * promise.\n   */\n  constructor(readonly name: string | Pojo) {\n    this.promise = new Promise<T>((resolve, reject) => {\n      this._resolve = resolve\n      this._reject = reject\n    })\n    this.logger = mkLogger(\"Deferred(\" + this.toString() + \")\")\n  }\n\n  toString() {\n    return isString(this.name) ? this.name : stringify(this.name)\n  }\n\n  [inspect.custom]() {\n    return {\n      ctor: \"Deferred\",\n      name: this.toString(),\n      start: this.start,\n      end: this.end,\n      state: this.state\n    }\n  }\n\n  observeQuietly(p: Promise<T>): Deferred<Maybe<T>> {\n    p.then(resolution => {\n      this.resolve(resolution)\n    }).catch(err => {\n      this.logger.warn(\"observeQuietly.reject()\", err)\n      this.resolve(undefined as any)\n    })\n    return this as any\n  }\n\n  observe(p: Promise<T>): this {\n    p.then(resolution => {\n      this.maybeResolve(resolution)\n    }).catch(err => {\n      this.maybeReject(err)\n    })\n    return this\n  }\n\n  /**\n   * Reject the promise if it hasn't been resolved or rejected within\n   * `timeoutMs`\n   */\n  setTimeout(timeoutMs: number): this {\n    map(this.priorTimeout, clearTimeout)\n    // unref so it doesn't prevent node from exiting:\n    this.priorTimeout = setUnrefTimeout(() => {\n      if (this.pending) {\n        const msg =\n          \"TIMEOUT: \" + this.name + \" after \" + (Date.now() - this.start) + \"ms\"\n        this.reject(msg)\n      }\n    }, timeoutMs)\n    return this\n  }\n\n  get stateStr(): string {\n    return this.pending ? \"pending\" : this.resolved ? \"resolved\" : \"rejected\"\n  }\n\n  get pending() {\n    return this.state === PromiseStates.pending\n  }\n\n  /**\n   * @return the resolved value for this Deferred, or `undefined` if this\n   * is either still pending or rejected.\n   */\n  get value(): Maybe<T> {\n    return this.resolved ? this._value : undefined\n  }\n\n  get error(): Maybe<Error> {\n    return this._error\n  }\n\n  /**\n   * true iff either resolved or rejected.\n   */\n  get settled() {\n    return this.state !== PromiseStates.pending\n  }\n\n  get resolved() {\n    return this.state === PromiseStates.resolved\n  }\n\n  get rejected() {\n    return this.state === PromiseStates.rejected\n  }\n\n  get settledMs(): number | undefined {\n    return this.end == null ? undefined : this.end - this.start\n  }\n\n  /**\n   * Resolves the internal promise. Cannot be invoked more than once.\n   */\n  resolve(value: T): this {\n    return this.settle(() => {\n      this.state = PromiseStates.resolved\n      this._value = value\n      this._resolve(value)\n    })\n  }\n\n  maybeResolve(value: T): this {\n    return this.pending ? this.resolve(value) : this\n  }\n\n  reject(reason?: any): this {\n    this.logger.log(\n      isIgnorableError(reason) ? \"info\" : \"warn\",\n      \".reject()\",\n      reason\n    )\n    const err = asError(reason)\n    return this.settle(() => {\n      this._error = err\n      this.state = PromiseStates.rejected\n      this._reject(err)\n    })\n  }\n\n  maybeReject(reason?: any): this {\n    return this.pending ? this.reject(reason) : this\n  }\n\n  finally(f: () => any): this {\n    this.promise.finally(f)\n    return this\n  }\n\n  /**\n   * @param f will be called with the resolved value\n   */\n  then<U>(f: (value: T) => U | PromiseLike<U>): Promise<U> {\n    return this.promise.then(f)\n  }\n\n  catch<U>(onrejected: (reason: any) => U | PromiseLike<U>): Promise<T | U> {\n    return this.promise.catch(err => onrejected(err))\n  }\n\n  private settle(firstback: () => void): this {\n    if (this.state === PromiseStates.pending) {\n      map(this.priorTimeout, clearTimeout)\n      firstback()\n      this.end = Date.now()\n      const ms = this.settledMs!\n      if (this.resolved && ms > 5000) {\n        const level = ms > 5000 ? \"info\" : \"debug\"\n        this.logger.log(level, \"Completed in \" + ms + \"ms\")\n      }\n    } else {\n      this.logger.warn(\n        \"settled multiple times (already \" + this.stateStr + \")\",\n        { value: this._value }\n      )\n    }\n    return this\n  }\n}\n", "import { compactBlankish, uniq } from \"./Array\"\nimport { blank, blankish, mapNotBlank, notBlank } from \"./Blank\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { ellipsize } from \"./String\"\nimport { toA } from \"./toA\"\nimport { toS } from \"./toS\"\n\nexport function errorToS(err: any): string {\n  if (blankish(err)) return \"\"\n  const result =\n    err instanceof Error\n      ? uniq(\n          compactBlankish([\n            toS(err.name).trim(),\n            mapNotBlank((err as any).code, ea => `code ${ea.trim()}`),\n            toS(err.message).trim()\n          ])\n        ).join(\": \")\n      : toS(err)\n  return ellipsize(result, 255)\n}\n\nexport function errorToVerbose(err: any): string {\n  if (err == null) return \"(undefined)\"\n  return [errorToS(err), ...toA(shortStack(err.stack))].join(\"\\n\")\n}\n\nexport function shortStack(stack?: string): Maybe<string[]> {\n  return blank(stack) ? undefined : toS(stack).split(\"\\n\").slice(0, 6)\n}\n\nexport function asError(reason?: any): Error {\n  if (blank(reason)) {\n    throw new Error(\"undefined error\")\n  } else if (reason instanceof Error) {\n    return reason\n  } else if (Array.isArray(reason)) {\n    const first = reason[0]\n    if (first instanceof Error) {\n      if (reason.length > 1) {\n        ;(first as any).errors = reason.slice(1)\n      }\n      return first\n    } else {\n      return new Error(\n        reason\n          .map(ea => toS(ea))\n          .filter(notBlank)\n          .join(\", \")\n      )\n    }\n  } else {\n    // Errors render as \"Error: something bad happened\". If you create a new\n    // Error from that string, you'll get an Error that toString's to \"Error:\n    // Error: something bad happened\", so strip the name of the error and give\n    // it to the return value:\n    const s = errorToS(reason)\n    const reasonNameIdx = s.indexOf(\":\")\n    if (reasonNameIdx > 2 && reasonNameIdx < 15) {\n      const e = new Error(s.slice(reasonNameIdx + 1).trim())\n      e.name = s.slice(0, reasonNameIdx).trim()\n      return e\n    } else {\n      return new Error(s)\n    }\n  }\n}\n\nexport function isError(err: any): err is Error {\n  return err instanceof Error\n}\n", "import { strEnum, StrEnumKeys } from \"./StrEnum\"\n\nexport const PromiseStates = strEnum(\"pending\", \"resolved\", \"rejected\")\nexport type PromiseState = StrEnumKeys<typeof PromiseStates>\n", "import { errorToS } from \"../../fe/Error\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { ending } from \"../async/Endable\"\nimport { isFalse, isTrue } from \"../../fe/Boolean\"\n\n// I could also go with a \u26A0\uFE0F\uD83D\uDED1\uD83D\uDCA5 or \"\uD83D\uDD01\u23F9\u23CF\uFE0F\" \uFE0Fbut these seem less cutesy:\nexport const FatalErrorFlag = \"\u00B9\"\nexport const NonRetriableErrorFlag = \"\u00B2\"\nexport const IgnorableErrorFlag = \"\u00B3\"\nexport const PleaseSendErrorFlag = \"\u2074\"\nexport const HealthCheckErrorFlag = \"\u2075\"\nexport const DoNotSendErrorFlag = \"\u2076\"\nexport const RetriableErrorFlag = \"\u2077\"\n\n// \u2070\u00B9\u00B2\u00B3\u2074\u2075\u2076\u2077\u2078\u2079\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089\n\nexport const ErrorFlags = [\n  FatalErrorFlag,\n  NonRetriableErrorFlag,\n  IgnorableErrorFlag,\n  PleaseSendErrorFlag,\n  HealthCheckErrorFlag,\n  DoNotSendErrorFlag,\n  RetriableErrorFlag\n]\n\nexport type ErrorFlag =\n  | typeof FatalErrorFlag\n  | typeof NonRetriableErrorFlag\n  | typeof IgnorableErrorFlag\n  | typeof PleaseSendErrorFlag\n  | typeof HealthCheckErrorFlag\n  | typeof DoNotSendErrorFlag\n  | typeof RetriableErrorFlag\n\nexport function addErrorFlags(msg: string, ...flags: Maybe<ErrorFlag>[]) {\n  return msg + flags.filter(ea => ea != null && !msg.includes(ea)).join(\"\")\n}\nconst ErrorFlagsRE = /[\u2070\u00B9\u00B2\u00B3\u2074\u2075\u2076\u2077\u2078\u2079\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089]/g\n\nexport function stripErrorFlags(err: string): string {\n  return err.replace(ErrorFlagsRE, \"\")\n}\n\nexport function extractErrorFlags(err: string): string {\n  return err\n    .split(\"\")\n    .filter(ea => ErrorFlags.includes(ea))\n    .join(\"\")\n}\n\nexport function hasErrorFlag(err: string): boolean {\n  return err.match(ErrorFlagsRE) != null\n}\n\nexport function isHealthCheckError(err: any): boolean {\n  return errorToS(err).includes(HealthCheckErrorFlag)\n}\n\nexport function isPleaseSendError(err: any): boolean {\n  return errorToS(err).includes(PleaseSendErrorFlag)\n}\n\nconst ignorablePatterns = [\n  IgnorableErrorFlag,\n  \"0 output files created\", // From exiftool\n  \"BatchCluster has ended, cannot enqueue\", // when sync-file is stopped before it's done\n  \"called while not idle\", // From old versions of batch-cluster\n  \"Can't set headers after they are sent\", // ignorable internal error\n  \"debugger attached\", //nodeJS inspector issues\n  \"debugger listening on\", //nodeJS inspector issues\n  \"diskutil: interrupted\", // dang flaky macOS tool\n  \"ECONNRESET\", // read ECONNRESET from broken socket\n  \"end() called before task completed\", // when sync-file is stopped before it's done\n  \"EPIPE\", // meh whatev\n  \"for help\", //nodeJS inspector issues\n  \"Format error in file\", // from exiftool\n  \"https://nodejs.org/en/docs/inspector\", //nodeJS inspector issues\n  \"Invalid data found when processing input\", // from invalid ffmpeg file\n  \"Missing expected status message\", // From exiftool\n  \"net::ERR_\", //See https://cs.chromium.org/codesearch/f/chromium/src/net/base/net_error_list.h  like net::ERR_TIMED_OUT\n  \"onExit(exit) called end()\", // From old versions of batch-cluster\n  \"This socket has been ended by the other party\", // so rude\n  \"Unexpected error while trimming\", // From sharp\n  \"Warning\" // I mean it's a warning\n].map(ea => ea.toLowerCase())\n\n/**\n * Ignorable errors are expected, and not even important enough to log.\n */\nexport function isIgnorableError(err: any): boolean {\n  if (err == null) return true\n  const msg = errorToS(err).toLowerCase()\n  const matchesIgnorable = ignorablePatterns.some(ea => msg.includes(ea))\n  return (\n    ending() ||\n    (!isPleaseSendError(err) && !isFatalError(err) && matchesIgnorable)\n  )\n\n  // return mkLogger().tap({\n  //   msg: \"isIgnorableError\",\n  //   result:\n  //     ending() ||\n  //     (!isPleaseSendError(err) && !isFatalError(err) && matchesIgnorable),\n  // meta: {\n  //   err: errorToS(err),\n  //   ending: ending(),\n  //   isPleaseSend: isPleaseSendError(err),\n  //   isFatal: isFatalError(err),\n  //   matchesIgnorable\n  // }\n}\n\nconst BusyErrorRe = /SQLITE_BUSY|database is locked/i\n\nexport function isSqliteBusyError(err: any): boolean {\n  return err.code === \"SQLITE_BUSY\" || null != errorToS(err).match(BusyErrorRe)\n}\n\nexport function isSqliteDisconnectedError(err: any): boolean {\n  return null != errorToS(err).match(/database .+ not open/i)\n}\n\nexport function isSqliteConstraintError(err: any): boolean {\n  return null != errorToS(err).match(/SQLITE_CONSTRAINT|constraint failed/i)\n}\n\nexport function isRetriableError(err: any): boolean {\n  return (\n    !isFatalError(err) &&\n    !errorToS(err).includes(NonRetriableErrorFlag) &&\n    !isSqliteConstraintError(err) &&\n    !isFalse(err.retriable)\n  )\n}\n\nexport function isNonRetriableError(err: any): boolean {\n  return !isRetriableError(err)\n}\n\n/**\n * These may be fatal errors (like loss of library lock), and the user will care\n * about them, but we don't need to tell Sentry about them.\n */\nexport function isDoNotSendError(err: any): boolean {\n  if (isPleaseSendError(err)) return false\n  if (isTrue(err?.doNotSend)) return true // WrappedError\n\n  const msg = errorToS(err).toLowerCase()\n  return doNotSendPatterns.some(ea => msg.includes(ea)) || isIgnorableError(msg)\n}\n\nconst doNotSendPatterns = [\n  DoNotSendErrorFlag,\n  \"Corrupt JPEG data\", // invalid jpeg, don't tell me.\n  \"premature end of data segment\", // invalid jpeg, don't tell me.\n  \"VipsJpeg\" // invalid jpeg, don't tell me.\n]\n\n/**\n * Default errors that indicate serious problems\n */\nexport const FatalErrorRe = new RegExp(\n  // (?! ... ) is a negative lookahead:\n  \"SQLITE_(FULL|IOERR|NOMEM)|ON CONFLICT|Error: Cannot find module|\" +\n    FatalErrorFlag,\n  \"i\"\n)\n\n/**\n * Does `err` represent a \"fatal\" error?\n */\nexport function isFatalError(err: any): boolean {\n  if (err == null) return false\n  if (isTrue(err.fatal)) return true\n  return FatalErrorRe.exec(errorToS(err)) != null\n}\n", "import { setInterval, setTimeout } from \"timers\"\nimport { tap } from \"../../fe/Object\"\n\nexport function setUnrefTimeout(\n  callback: (...ea: any[]) => void,\n  ms: number,\n  ...args: any[]\n): NodeJS.Timeout {\n  return tap(setTimeout(callback, Math.round(ms), ...args), t => t.unref())\n}\n\nexport function setUnrefInterval(\n  callback: (...ea: any[]) => void,\n  ms: number,\n  ...args: any[]\n): NodeJS.Timeout {\n  return tap(setInterval(callback, Math.round(ms), ...args), t => t.unref())\n}\n", "import { count, filterInPlace } from \"../../fe/Array\"\nimport { Latch } from \"../../fe/Latch\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { isFunction } from \"../../fe/ObjectType\"\nimport { Average } from \"../math/Average\"\nimport { Pojo } from \"../Object\"\nimport { maxCpus } from \"../work/MaxCpus\"\nimport { Deferred } from \"./Deferred\"\nimport { Later, LaterMaybe } from \"./Later\"\n\n/**\n * Aggregate promises efficiently\n *\n * Note that `N` is either a descriptive name for the promise, or can be a data\n * payload associated to the promise.\n */\nexport class Promises<N extends string | Pojo = string> {\n  private _pushCount = 0\n  lastPushTs = 0\n  private readonly _arr: Deferred<any>[] = []\n  private readonly nextSettledLatches: Latch[] = []\n  readonly serialLatencyAvg = new Average()\n  readonly applyListeners: ((name: N) => any)[] = []\n\n  private get arr() {\n    filterInPlace(this._arr, ea => ea.pending)\n    return this._arr\n  }\n\n  get pushCount() {\n    return this._pushCount\n  }\n\n  /**\n   * Listener that will be called once the given push()ed or serial()ed or\n   * maybeRun()ed promise is started.\n   */\n  onApply(listener: (name: N) => any) {\n    this.applyListeners.push(listener)\n  }\n\n  private _emitApply(name: N) {\n    for (const ea of this.applyListeners) {\n      ea(name)\n    }\n  }\n\n  push<T>(name: N, promiseOrLater: Promise<T> | Later<T>): Promise<T> {\n    this._emitApply(name)\n    return this._push(name, promiseOrLater)\n  }\n\n  private _push<T>(name: N, promiseOrLater: Promise<T> | Later<T>) {\n    this._pushCount++\n    this.lastPushTs = Date.now()\n    // We observe quietly here so one rejected promise doesn't kill all the\n    // following. Note that `this.arr` (not this._arr) does garbage collection:\n    const p = isFunction(promiseOrLater) ? promiseOrLater() : promiseOrLater\n    this.arr.push(\n      new Deferred(name).observeQuietly(p).finally(() => this.emitSettled())\n    )\n    return p\n  }\n\n  private emitSettled() {\n    for (const ea of this.nextSettledLatches) {\n      void ea.resolve()\n    }\n    this.nextSettledLatches.length = 0\n  }\n\n  awaitNextSettled(): Latch {\n    const l = new Latch()\n    this.nextSettledLatches.push(l)\n    return l\n  }\n\n  /**\n   * Run f() after all prior-enqueued promises have resolved.\n   */\n  serial<T>(name: N, f: () => Promise<T>): Promise<T> {\n    const start = Date.now()\n    return this._push(\n      name,\n      this.awaitAll().then(() => {\n        this.serialLatencyAvg.push(Date.now() - start)\n        this._emitApply(name)\n        return f()\n      })\n    )\n  }\n\n  /**\n   * Run f() after all prior-enqueued promises have resolved.\n   */\n  serialByName<T>(name: N, f: () => Promise<T>): Promise<T> {\n    const start = Date.now()\n    return this._push(\n      name,\n      this.awaitAllByName(name).then(() => {\n        this.serialLatencyAvg.push(Date.now() - start)\n        this._emitApply(name)\n        return f()\n      })\n    )\n  }\n\n  /**\n   * Only run f() if all prior have finished, otherwise, no-op and wait until\n   * all pending have resolved.\n   */\n  oneRunAtATime<T>(name: N, f: () => Promise<T>): PromiseMaybe<T> {\n    return this.pending ? this.awaitAll() : this.serial(name, f)\n  }\n\n  /**\n   * If you don't care about the returned promise: only run f() if all prior have\n   * finished, and return no-op otherwise\n   */\n  maybeRun<T>(name: N, f: () => Promise<T>): Maybe<Promise<T>> {\n    return this.maybeRunConcurrent(name, f, 1)\n  }\n\n  /**\n   * If you don't care about the returned promise: only run f() if fewer than maxConcurrent\n   */\n  maybeRunConcurrent<T>(\n    name: N,\n    f: () => Promise<T>,\n    maxConcurrent = maxCpus()\n  ): Maybe<Promise<T>> {\n    return this.pendingCount >= maxConcurrent ? undefined : this.push(name, f)\n  }\n\n  get pendingCount() {\n    // We don't want to muck with _arr state, so use this._arr directly:\n    return count(this._arr, ea => ea.pending)\n  }\n\n  get pending() {\n    return this.pendingCount > 0\n  }\n\n  pendingNames(): N[] {\n    return this.arr.map(ea => ea.name) as N[]\n  }\n\n  get settled() {\n    // this.arr is a getter that does vacuuming\n    return this.arr.length === 0\n  }\n\n  /**\n   * @return a promise that will be resolved when all previously-pushed Promises\n   * are resolved. Any promise rejection will throw the whole chain.\n   */\n  async awaitAll() {\n    // NOTE: don't use Promise.all here, it doesn't seem to scale.\n    for (const ea of [...this.arr]) {\n      await ea.promise\n    }\n    return undefined\n  }\n\n  async awaitAllByName(name: N) {\n    // NOTE: don't use Promise.all here, it doesn't seem to scale.\n    for (const ea of [...this.arr]) {\n      if (ea.name === name) await ea.promise\n    }\n    return undefined\n  }\n\n  async pushAll<T>({\n    name,\n    laters,\n    maxConcurrent = maxCpus()\n  }: {\n    name: N\n    laters: Later<T>[]\n    maxConcurrent?: number\n  }): Promise<T[]> {\n    maxConcurrent = clamp(1, maxCpus() * 2, maxConcurrent)\n    const results: Promise<T>[] = []\n    for (const later of laters) {\n      while (this.pendingCount >= maxConcurrent) {\n        await this.awaitNextSettled()\n      }\n      results.push(this.push(name, later))\n    }\n    return Promise.all(results)\n  }\n}\n\n/**\n * Run the given thunk never more than once concurrently. Invocations while\n * prior runs were invoked will return after prior runs have completed but will\n * be no-ops.\n */\nexport function oneRunAtATime<T>(name: string, l: Later<T>): LaterMaybe<T> {\n  const p = new Promises()\n  return () => p.oneRunAtATime(name, l)\n}\n\n/**\n * Run the given thunk never more than once concurrently. Invocations while\n * prior runs were invoked will return after prior runs have completed but will\n * be no-ops.\n */\nexport function maybeRun<T>(\n  name: string,\n  l: Later<T>\n): () => Maybe<Promise<T>> {\n  const p = new Promises()\n  return () => p.maybeRun(name, l)\n}\n\n/**\n * Run the given thunk never more than once concurrently. Invocations while\n * prior runs were invoked will be started after all prior runs have finished.\n */\nexport function serially<T>(name: string, l: Later<T>): Later<T> {\n  const p = new Promises()\n  return () => p.serial(name, l)\n}\n\nexport async function withBoundedConcurrency<T>({\n  name,\n  laters,\n  maxConcurrent\n}: {\n  name: string\n  laters: Later<T>[]\n  maxConcurrent?: number\n}): Promise<T[]> {\n  // SITS: NOTE: if we share the same Promises instance, and a code block within\n  // withBoundedConcurrency calls withBoundedConcurrency, we'll starve.\n  return new Promises().pushAll({ name, laters, maxConcurrent })\n}\n", "import { isFunction } from \"./ObjectType\"\n\nexport type AsPromiseable<T> =\n  | T\n  | Promise<T>\n  | (() => T | Promise<T>)\n  | Promise<() => T | Promise<T>>\n\nexport async function asPromise<T>(o: AsPromiseable<T>): Promise<T> {\n  const a = await o\n  return isFunction(a) ? a() : a\n}\n", "import { asPromise } from \"../../fe/AsPromise\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { unrefDelay } from \"../../fe/Delay\"\n\nexport async function thenOrTimeout<T>(\n  p: T | (() => T | Promise<T>),\n  timeoutMs: number,\n  onTimeout: () => any = () => undefined,\n  onSuccess: (t: T) => any | Promise<any> = () => undefined\n): PromiseMaybe<T> {\n  let _resolved = false\n  let timedOut = false\n  let result: Maybe<T>\n  await Promise.race([\n    asPromise(p).then(ea => {\n      if (!timedOut) {\n        result = ea\n        _resolved = true\n        return ea\n      } else {\n        return\n      }\n    }),\n    // This delay must be unref'ed so as to not prevent node from exitting:\n    unrefDelay(timeoutMs).then(() => {\n      if (!_resolved) {\n        timedOut = true\n      }\n    })\n  ])\n  if (_resolved) {\n    await onSuccess(result!)\n  } else {\n    await onTimeout()\n  }\n  return result\n}\n", "import { compact, isEmpty, isNotEmpty, sortBy, uniq } from \"../../fe/Array\"\nimport { isFalse, isTrue } from \"../../fe/Boolean\"\nimport { secondMs } from \"../../fe/Date\"\nimport { unrefDelay } from \"../../fe/Delay\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport {\n  Maybe,\n  MaybeNull,\n  MaybePromiseMaybe,\n  PromiseMaybe\n} from \"../../fe/MaybeTypes\"\nimport { isFunction } from \"../../fe/ObjectType\"\nimport { MaybeSyncOrAsync, SyncOrAsync } from \"../../fe/OptAsync\"\nimport { Primitive } from \"../../fe/Primitive\"\nimport { thenMap } from \"../../fe/Promise\"\nimport { Thunk } from \"../../fe/Thunk\"\nimport { toA } from \"../../fe/toA\"\nimport { batches, greatestBy } from \"../Array\"\nimport { identity } from \"../Object\"\nimport { withBoundedConcurrency } from \"./Promises\"\nimport { thenOrTimeout } from \"./thenOrTimeout\"\n\n// TODO: INLINE\nexport { thenMap } from \"../../fe/Promise\"\n\nexport async function thenCollectBatched<T1, T2>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T1>[]>,\n  batchSize: number,\n  f: (arr: T1[]) => MaybeSyncOrAsync<T2[]>\n) {\n  const result: T2[] = []\n  for (const batchArr of batches(toA(await arr), batchSize)) {\n    const batchInput: T1[] = []\n    for (const ea of batchArr) {\n      if (ea != null) {\n        const v = await ea\n        if (v != null) {\n          batchInput.push(v)\n        }\n      }\n    }\n    for (const ea of toA(await f(batchInput))) {\n      if (ea != null) {\n        result.push(ea)\n      }\n    }\n  }\n  return result\n}\n\nexport async function thenMapResolved<T1, T2>(\n  objP: MaybeSyncOrAsync<T1>,\n  f: (t: T1) => MaybeSyncOrAsync<T2>\n): PromiseMaybe<T2> {\n  if (objP == null) return Promise.resolve(undefined)\n  try {\n    return await thenMap(objP, f)\n  } catch (e) {\n    return undefined\n  }\n}\n\nexport function resolvedWithin<T>(\n  p: Promise<T>,\n  withinMs: number\n): Promise<boolean> {\n  return Promise.race([\n    p.then(() => true),\n    unrefDelay(withinMs).then(() => false)\n  ]).catch(() => false)\n}\n\nexport async function resolved(p: Promise<any>): Promise<boolean> {\n  try {\n    await p\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nexport async function rejected(p: Promise<any>): Promise<boolean> {\n  return !(await resolved(p))\n}\n\nexport async function thenDefined(p: Promise<any>): Promise<boolean> {\n  return (await p) != null\n}\n\nexport async function allSerial<T>(\n  arr: Maybe<() => MaybePromiseMaybe<T>>[]\n): Promise<T[]> {\n  const result: Maybe<T>[] = []\n  for (const ea of compact(arr)) {\n    result.push(await ea())\n  }\n  return compact(result)\n}\n\nexport async function awaitAll(\n  arr: Maybe<(PromiseMaybe<any> | any)[]>\n): Promise<void> {\n  const ea = compact(arr)\n  if (isNotEmpty(ea)) {\n    await Promise.all(ea)\n  }\n}\n\n// maybeist champion:\nexport async function thenFlatten<T>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T | MaybeSyncOrAsync<T>[]>[]>\n): Promise<T[]> {\n  const result: T[] = []\n  for (const ea of toA(await arr)) {\n    const v = await ea\n    if (v != null) {\n      if (Array.isArray(v)) {\n        for (const ea2 of v) {\n          const v2 = await ea2\n          if (v2 != null) result.push(v2)\n        }\n      } else {\n        result.push(v)\n      }\n    }\n  }\n  return result\n}\n\nexport async function thenCompact<T>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T>[]>\n): Promise<T[]> {\n  const c = compact(await arr)\n  return isEmpty(c) ? [] : compact(await Promise.all(c))\n}\n\nexport async function thenUniq<T>(\n  arr: MaybeSyncOrAsync<MaybeSyncOrAsync<T>[]>\n): Promise<T[]> {\n  const result: T[] = []\n  for (const ea of toA(await arr)) {\n    const v = await ea\n    if (v != null) {\n      result.push(v)\n    }\n  }\n  return uniq(result)\n}\n\nexport async function asyncFind<T>(\n  arr: T[],\n  f: (t: T) => Promise<boolean>\n): PromiseMaybe<T> {\n  for (const ea of arr) {\n    if (await f(ea)) return ea\n  }\n  return\n}\n\n/**\n * For each in `V[]`, apply `f(v)` concurrently, returning `[v, await f(v)]`\n * @see thenCollect\n */\nexport async function thenCollectParallel<T, V>(\n  arr: Maybe<MaybeSyncOrAsync<Maybe<T>[]>>,\n  f: (t: T, index: number) => SyncOrAsync<Maybe<V>>,\n  maxConcurrent?: number\n): Promise<[V, T][]> {\n  if (arr == null) return []\n  const array = compact(await arr)\n  if (isEmpty(array)) return []\n  const t = await withBoundedConcurrency({\n    name: \"thenCollectParallel\",\n    laters: array.map((ea, index) => async () =>\n      [await f(ea, index), ea] as [V, T]\n    ),\n    maxConcurrent\n  })\n  return t.filter(([k, v]) => k != null && v != null)\n}\n\nexport async function mapAsync<T, V>(\n  arr: Maybe<MaybeSyncOrAsync<Maybe<T>[]>>,\n  f: (t: T, index: number) => SyncOrAsync<Maybe<V>>,\n  maxConcurrent?: number\n): Promise<V[]> {\n  return (await thenCollectParallel(arr, f, maxConcurrent)).map(ea => ea[0])\n}\n\n/**\n * @return all items in `arr` that `f` returns true or Promise<true>\n */\nexport async function filterAsync<T>(\n  arr: Maybe<T>[],\n  f: (t: T) => Maybe<boolean> | PromiseMaybe<boolean>,\n  maxConcurrent?: number\n): Promise<T[]> {\n  const t = await thenCollectParallel(compact(arr), f, maxConcurrent)\n  return t.filter(([b]) => b).map(([, v]) => v)\n}\n\nexport async function partitionAsync<T>(\n  arr: T[],\n  filter: (t: T, index: number) => MaybeSyncOrAsync<boolean>\n): Promise<[T[], T[]]> {\n  const t = await thenCollectParallel(arr, filter)\n  return [\n    t.filter(([ea]) => isTrue(ea)).map(([, ea]) => ea),\n    t.filter(([ea]) => isFalse(ea)).map(([, ea]) => ea)\n  ]\n}\n\nexport async function tryAsync<T>(f: () => T | Promise<T>) {\n  try {\n    return await f()\n  } catch {\n    return\n  }\n}\n\nexport const DefaultTryAllTimeoutMs = 30 * secondMs\n\nexport async function tryAll(\n  arr: (any | (() => any))[],\n  onError = (err: Error) => console.error(err),\n  timeoutMs = DefaultTryAllTimeoutMs\n): Promise<void> {\n  for (const ea of arr) {\n    try {\n      await thenOrTimeout(ea, timeoutMs)\n    } catch (err) {\n      onError(err)\n    }\n  }\n  return\n}\n\nexport async function thenFinally<T>(\n  p: SyncOrAsync<T> | (() => SyncOrAsync<T>),\n  err_: (err: Error | any) => any = () => {\n    // no-op\n  },\n  finally_: (r: T | Error) => any = () => {\n    // no-op\n  }\n): Promise<T> {\n  let result: T\n  let caught = null\n  try {\n    result = await (isFunction(p) ? p() : p)\n  } catch (err) {\n    caught = err\n    try {\n      await err_(err)\n    } catch {\n      // no-op\n    }\n  }\n  try {\n    await finally_(caught != null ? caught : result!)\n  } catch {\n    // no-op\n  }\n  if (caught != null) {\n    throw caught\n  } else {\n    return result!\n  }\n}\n\nexport async function thenNot(\n  p: MaybePromiseMaybe<boolean>,\n  nullIsFalse = true\n): Promise<boolean> {\n  if (p == null) return nullIsFalse\n  const r = await p\n  return r == null ? nullIsFalse : !isTrue(r)\n}\n\nexport async function thenMap2<T1, T2, T3>(\n  objP1: MaybeSyncOrAsync<T1>,\n  objP2: MaybeSyncOrAsync<T2>,\n  f: (t1: T1, t2: T2) => MaybeSyncOrAsync<T3>\n): PromiseMaybe<T3> {\n  const o1 = await objP1\n  if (o1 == null) return\n  const o2 = await objP2\n  if (o2 == null) return\n  return f(o1, o2)\n}\n\n/**\n * Safe calls for Optional promises, with default\n */\nexport async function thenMapOr<T1, T2, T3>(\n  objP: MaybeSyncOrAsync<T1>,\n  f: (t: T1) => MaybeSyncOrAsync<T2>,\n  ifUndefined: () => SyncOrAsync<T3>\n): Promise<T2 | T3> {\n  const obj = await objP\n  if (obj == null) return ifUndefined()\n  const result = await f(obj)\n  return result == null ? ifUndefined() : result\n}\n/**\n * Safe calls for Optional promises, with default\n */\nexport async function thenMap2Or<A1, A2, R1, R2>(\n  objP1: MaybeSyncOrAsync<A1>,\n  objP2: MaybeSyncOrAsync<A2>,\n  f: (t1: A1, t2: A2) => MaybeSyncOrAsync<R1>,\n  ifUndefined: () => SyncOrAsync<R2>\n): Promise<R1 | R2> {\n  const o1 = await objP1\n  if (o1 == null) return ifUndefined()\n  const o2 = await objP2\n  if (o2 == null) return ifUndefined()\n  const result = await f(o1, o2)\n  return result == null ? ifUndefined() : result\n}\n\n/**\n * Only call f if the promise resolves to truthy\n */\nexport async function thenAnd<T>(\n  predicatePromise: MaybeNull<Promise<true | any>>,\n  f: () => SyncOrAsync<T>\n): PromiseMaybe<T> {\n  return predicatePromise != null && isTrue(await predicatePromise)\n    ? f()\n    : undefined\n}\n\nexport async function thenOrElse<T>(\n  objP: Promise<MaybeNull<T>> | MaybeNull<T>,\n  f: () => SyncOrAsync<T>\n): Promise<T> {\n  return orElse(await objP, f)\n}\n\n/**\n * Just like `firstDefinedPromise` but applies a function to all defined\n * elements in `arr`.\n */\nexport async function first<T, R>(\n  arr: Maybe<Maybe<T>[]>,\n  f: (t: T, index: number) => SyncOrAsync<MaybeNull<R>>\n): PromiseMaybe<R> {\n  if (arr != null) {\n    let index = -1\n    for (const t of arr) {\n      index++\n      try {\n        if (t == null) continue\n        const r = await f(t, index)\n        if (r != null) {\n          return r\n        }\n      } catch {\n        // no-op\n      }\n    }\n  }\n  return undefined\n}\n\n/**\n * @see #firstDefinedLater\n */\nexport async function firstDefinedPromise<T, U = T>(\n  promiseThunks: Thunk<MaybeSyncOrAsync<T>>[],\n  filter: (t: T) => SyncOrAsync<Maybe<U>> = identity as any\n): PromiseMaybe<U> {\n  for (const ea of promiseThunks) {\n    const o = await ea()\n    if (o != null) {\n      const result = await filter(o)\n      if (result != null) {\n        return result\n      }\n    }\n  }\n  return\n}\n\nexport async function firstResolvedDefinedPromise<T>(\n  promiseThunks: Thunk<MaybeSyncOrAsync<T>>[],\n  onError: (err: Error) => void\n): PromiseMaybe<T> {\n  for (const t of promiseThunks) {\n    try {\n      const result = await t()\n      if (result != null) {\n        return result\n      }\n    } catch (err) {\n      onError(err)\n    }\n  }\n  return\n}\n\nexport async function firstTruePromise<T>(\n  predicate: (t: T) => Maybe<boolean> | PromiseMaybe<boolean>,\n  ...promiseThunks: (() => MaybeSyncOrAsync<T>)[]\n): PromiseMaybe<T> {\n  for (const thunk of promiseThunks) {\n    try {\n      const ea = await thunk()\n      if (ea != null && (await predicate(ea)) === true) {\n        return ea\n      }\n    } catch (_) {\n      //\n    }\n  }\n  return\n}\n\nexport async function thenGreatest<T, V extends Primitive | Primitive[]>(\n  arr: T[],\n  f: (t: T) => PromiseMaybe<V>\n): PromiseMaybe<T> {\n  return map(\n    greatestBy(await thenCollectParallel(arr, f), ea => ea[0]),\n    ea => ea[1]\n  )\n}\n\n/**\n * @return `arr` sorted by the tuples in f. elements that `f` returns undefined\n * will be removed from the returned array.\n * @see https://en.wikipedia.org/wiki/Schwartzian_transform\n */\nexport async function sortByAsync<T, V extends Primitive | Primitive[]>(\n  arr: T[],\n  f: (t: T) => PromiseMaybe<V>\n): Promise<T[]> {\n  return sortBy(await thenCollectParallel(arr, f), ea => ea[0]).map(ea => ea[1])\n}\n", "import { readFileSync } from \"fs\"\nimport { arch, platform } from \"os\"\nimport _p from \"process\"\nimport { notBlank } from \"../fe/Blank\"\nimport { lazy } from \"../fe/Lazy\"\nimport { map } from \"../fe/Maybe\"\nimport { toS } from \"../fe/toS\"\nimport { isTrue } from \"../fe/Boolean\"\nimport { isEnvTrue } from \"./Env\"\n\nconst _platform = platform()\n\nexport const inspectFlag =\n  _p.argv.includes(\"--inspect\") || isTrue(_p.env.NODE_INSPECT)\n\n// Expect __filename to be something like\n// '/home/mrm/src/photostructure/src/library/dist/core/Platform.js' if we're not\n// web-packed.\nexport const isPacked = !toS(__filename).includes(\"Platform\")\n\nexport const isWin = _platform === \"win32\" || _platform === \"cygwin\"\nexport const isWinPortable = isWin && notBlank(_p.env.PORTABLE_EXECUTABLE_DIR)\n\nexport const isMac = _platform === \"darwin\"\n\nexport const isLinux = _platform === \"linux\"\nexport const isLinux_x64 = isLinux && arch() === \"x64\"\nexport const isArm = arch() === \"arm\"\nexport const isLinux_arm = isLinux && isArm\nexport const isLinuxAppImage =\n  isLinux && (notBlank(_p.env.APPIMAGE) || notBlank(_p.env.APPDIR))\nexport const isLinuxSnap = isLinux && notBlank(_p.env.SNAP_USER_DATA)\n\nexport const isPosix = isMac || isLinux\n\nexport const PS_IS_ELECTRON = \"PS_IS_ELECTRON\"\nexport const PS_IS_DOCKER = \"PS_IS_DOCKER\"\n\nexport const isElectron =\n  // PS_IS_ELECTRON is a workaround because versions.electron doesn't exist if\n  // ELECTRON_RUN_AS_NODE is set (!!)\n  _p.versions[\"electron\"] != null || isTrue(_p.env[PS_IS_ELECTRON])\n\nexport function setIsDocker(b: boolean) {\n  if (b) {\n    _p.env[PS_IS_DOCKER] = \"1\"\n  } else {\n    delete _p.env[PS_IS_DOCKER]\n  }\n}\n\n// NOTE: don't lazy this without fixing setIsDocker\nexport function isDocker() {\n  // PS_IS_DOCKER is set by the Dockerfile and by tests:\n  return (\n    isLinux &&\n    (isEnvTrue(PS_IS_DOCKER) ||\n      // TODO: this was set in earlier Dockerfiles (and could probably be removed)\n      isEnvTrue(\"PS_DOCKER\"))\n  )\n\n  // NOTE TO THE FUTURE: we used to parse out the owner from /proc/1/cgroup\n  // but that wasn't guaranteed to be \"docker\". Just using an environment flag\n  // is much safer.\n}\n\nexport const isRaspberryPi = lazy(\n  () => isLinux_arm && toS(procDeviceModel()).startsWith(\"Raspberry Pi\")\n)\n\n/**\n * This seems to only be set on Raspberry PIs:\n */\nexport const procDeviceModel = lazy(() => {\n  try {\n    return isLinux\n      ? map(readFileSync(\"/proc/device-tree/model\"), toS)\n      : undefined\n  } catch {\n    return\n  }\n})\n\n/**\n * Compatible with electron-builder:\n */\nexport type Platform = \"win\" | \"mac\" | \"linux\"\n\nexport const platformName: Platform = isWin\n  ? \"win\"\n  : isMac\n  ? \"mac\"\n  : isLinux\n  ? \"linux\"\n  : (_platform as any) // < punt\n", "import { hourMs, minuteMs, secondMs } from \"../../fe/Date\"\nimport { MiB } from \"../../fe/Units\"\n\n/**\n * This needs to be short enough to pick up when drives are inserted or ejected\n * in reasonable-ish time, but not so often it breaks the OS\n */\nexport const MountpointsTtlMs = 15 * secondMs\n\n/**\n * Update frequently enough to detect substantive changes in available bytes\n */\nexport const LongMountpointsTtlMs = 5 * minuteMs\n\n/**\n * How long the `df` or `wmic` should be allowed to run before timing out. Note\n * that external hard drives can take longer than 10 seconds to spin up...\n */\n// There were filesystem timeout errors with 25 seconds, so bumping up to 35.\nexport const CmdTimeoutMs = 35 * secondMs\n\n/**\n * For commands that don't need to wait for a disk to spin up, and only return\n * something like --version:\n */\nexport const ShortCmdTimeoutMs = 7 * secondMs\n\n/**\n * Volume UUIDs should never change, so this is long.\n */\nexport const LongTtlMs = 1 * hourMs\n\n/**\n * The worst-expected transfer rate for file I/O:\n */\nexport const MinIoRate = secondMs / (2 * MiB)\n", "import { secondMs } from \"../../fe/Date\"\n\nexport const StatTimeoutMs = 25 * secondMs\n", "import { ChildProcess } from \"child_process\"\nimport { Socket } from \"net\"\nimport {\n  Duplex,\n  pipeline,\n  Readable,\n  Transform,\n  TransformCallback\n} from \"stream\"\nimport { promisify } from \"util\"\nimport { unrefDelay } from \"../../fe/Delay\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, MaybeNull } from \"../../fe/MaybeTypes\"\nimport { maybeCall } from \"../../fe/Object\"\nimport { NoOp } from \"../../fe/Thunk\"\nimport { ending } from \"../async/Endable\"\nimport { isIgnorableError } from \"../error/ErrorTypes\"\nimport { Try } from \"../Object\"\n\nexport class ReadableBuffer extends Readable {\n  constructor(buffer: Buffer) {\n    super()\n    this.push(buffer)\n    this.push(null)\n  }\n}\n\nexport class PassthroughStream extends Duplex {\n  _write(chunk: any, encoding: BufferEncoding) {\n    this.push(chunk, encoding)\n  }\n}\n\n// I don't want to just Pick<Writable, \"end\"> because I don't want to require\n// all the overloaded signatures as well.\nexport interface EndableStream {\n  end(chunk: any, cb?: () => void): void\n}\n\nexport async function endStream(\n  endable: MaybeNull<EndableStream>\n): Promise<void> {\n  if (endable == null) return\n  Try(() => maybeCall(endable, \"unref\"))\n  if (ending()) {\n    endable.end(null)\n  } else {\n    // Half-closes the socket (!!)\n    await new Promise<void>(resolve => endable.end(null, resolve))\n  }\n  await unrefDelay(50)\n\n  // Ensures that no more I/O activity happens on this socket\n  Try(() => maybeCall(endable, \"destroy\"))\n  return\n}\n\nexport interface ClosableStream {\n  close(callback: () => void): void\n}\n\nexport async function closeStream(\n  closable: Maybe<ClosableStream>\n): Promise<void> {\n  if (closable == null) return\n  Try(() => maybeCall(closable, \"unref\"))\n  if (ending()) {\n    closable.close(NoOp)\n  } else {\n    await new Promise<void>(resolve => closable.close(resolve))\n  }\n  // I don't think this is necessary (and caused errors with electron last year):\n  // await delay(50)\n  // Try(() => maybeCall(closable, \"destroy\"))\n  return\n}\n\nexport function onChildError(\n  cp: ChildProcess,\n  f: (src: \"cp\" | \"stdin\" | \"stdout\" | \"stderr\", err: Error) => void\n): void {\n  ;[\n    { name: \"cp\", ea: cp },\n    { name: \"stdin\", ea: cp.stdin },\n    { name: \"stdout\", ea: cp.stdout },\n    { name: \"stderr\", ea: cp.stderr }\n  ].forEach(({ name, ea }) =>\n    map(ea, ea2 =>\n      ea2.on(\"error\", err => {\n        if (!isIgnorableError(err)) f(name as any, err)\n      })\n    )\n  )\n}\n\nexport function closeStreams(cp: ChildProcess) {\n  for (const ea of [cp?.stdin, cp?.stdout, cp?.stderr]) {\n    try {\n      ea?.destroy()\n    } catch {\n      //\n    }\n  }\n}\n\nexport const pipelineAsync = promisify(pipeline)\n\nexport type Pipeline = [\n  NodeJS.ReadableStream,\n  ...(NodeJS.ReadWriteStream | NodeJS.WritableStream)[]\n]\n\nexport function remoteDesc(s: Socket): string {\n  return s.destroyed\n    ? \"destroyed\"\n    : `${s.remoteFamily}:${s.remoteAddress}:${s.remotePort}`\n}\n\nexport class ByteCounter extends Transform {\n  private bytes = 0\n  constructor(readonly onProgress: (bytes: number) => any) {\n    super({\n      transform: (\n        chunk: any,\n        _encoding: BufferEncoding,\n        callback: TransformCallback\n      ) => {\n        this.onProgress((this.bytes += chunk.length))\n        callback(chunk)\n      }\n    })\n  }\n}\n", "import { homedir } from \"os\"\nimport { resolve } from \"path\"\nimport { compactBlanks } from \"../fe/Array\"\nimport { lazy } from \"../fe/Lazy\"\nimport { getEnv } from \"./Env\"\nimport { isDirectorySync } from \"./fs/Path\"\nimport { isWin } from \"./Platform\"\n\nexport const homeDir = lazy(() => {\n  const paths = []\n  if (isWin) {\n    // cygwin may mess with HOMEPATH and HOME. Only trust USERPROFILE.\n    paths.push(getEnv(\"USERPROFILE\"))\n  } else {\n    paths.push(getEnv(\"HOME\"))\n  }\n  for (const ea of compactBlanks(paths)) {\n    const d = resolve(ea)\n    if (isDirectorySync(d)) return d\n  }\n  return homedir()\n})\n", "import { compactBlanks } from \"../fe/Array\"\nimport { AppName } from \"./AppName\"\nimport { getEnv } from \"./Env\"\nimport { isDirectorySync, resolve } from \"./fs/Path\"\nimport { homeDir } from \"./HomeDir\"\nimport { isDocker, isMac, isWin } from \"./Platform\"\n\nexport function defaultCacheDir() {\n  if (isDocker() && isDirectorySync(\"/ps/cache\")) {\n    return \"/ps/cache\"\n  }\n\n  if (isWin) {\n    for (const ea of compactBlanks([getEnv(\"TEMP\"), getEnv(\"LOCALAPPDATA\")])) {\n      if (isDirectorySync(ea)) return resolve(ea, AppName())\n    }\n  }\n\n  if (isMac) {\n    const d = resolve(homeDir(), \"Library\", \"Caches\")\n    if (isDirectorySync(d)) return resolve(d, AppName())\n  }\n\n  // .cache directories on posix seem to be uniformly lowercase:\n  return resolve(homeDir(), \".cache\", AppName().toLowerCase())\n}\n", "import { resolve } from \"path\"\nimport { appData } from \"./AppData\"\nimport { SimpleAppName } from \"./AppName\"\nimport { homeDir } from \"./HomeDir\"\nimport { isDocker, isMac } from \"./Platform\"\n\nexport function defaultLogDir() {\n  return isDocker()\n    ? \"/ps/logs\"\n    : isMac\n    ? resolve(homeDir(), \"Library\", \"Logs\", SimpleAppName.toLowerCase())\n    : defaultPosixLogDir()\n}\n\nexport function defaultPosixLogDir() {\n  return resolve(appData(), SimpleAppName.toLowerCase(), \"logs\")\n}\n", "import { statSync } from \"fs\"\nimport { mkdirpSync } from \"fs-extra\"\nimport { resolve } from \"path\"\nimport { env } from \"process\"\nimport { compactBlanks } from \"../fe/Array\"\nimport { lazy } from \"../fe/Lazy\"\nimport { getEnv } from \"./Env\"\nimport { FatalErrorFlag } from \"./error/ErrorTypes\"\nimport { homeDir } from \"./HomeDir\"\nimport { isDocker, isMac, isPosix, isWin } from \"./Platform\"\n\n/**\n * @return PS_CONFIG_DIR, ~/AppData/Roaming, or ~/Library/Application Support, or ~/.config\n */\nexport const appData = lazy(() => {\n  // lazy because this hits the filesystem and shouldn't ever change\n  const maybePaths = [\n    // We're not resolving the env value. If they give us something crazy, just go with it.\n    env.PS_CONFIG_DIR, // < this should override APPDATA or XDG_*_HOME values.\n    isDocker() ? \"/ps/config\" : undefined\n  ]\n\n  // %APPDATA% is C:\\Users\\username\\AppData\\Roaming\n  if (isWin) {\n    maybePaths.push(getEnv(\"APPDATA\"))\n    maybePaths.push(resolve(homeDir(), \"AppData\", \"Roaming\"))\n  }\n\n  if (isMac) {\n    maybePaths.push(resolve(homeDir(), \"Library\", \"Application Support\"))\n  }\n\n  // See https://specifications.freedesktop.org/freedesktop-platform-specs/1.0/basedir-spec-0.6/ar01s03.html\n  if (!isMac && isPosix) {\n    maybePaths.push(\n      getEnv(\"XDG_DATA_HOME\"),\n      getEnv(\"XDG_CONFIG_HOME\"),\n      resolve(homeDir(), \".config\")\n    )\n  }\n\n  const paths = compactBlanks(maybePaths)\n\n  // Return the first path that exists:\n  for (const ea of paths) {\n    try {\n      if (statSync(ea).isDirectory()) return ea\n    } catch {\n      //\n    }\n  }\n\n  // Otherwise, try to return the first path that we can make:\n  for (const ea of paths) {\n    try {\n      mkdirpSync(ea)\n      return ea\n    } catch {\n      console.error(\"Failed to mkdirp \" + ea)\n    }\n  }\n\n  throw new Error(\"Cannot determine appData\" + FatalErrorFlag)\n})\n", "export const version = \"1.0.0-alpha.1\";\nexport const release = \"1.0.0-alpha.1+20210314162034\";\nexport const gitSha = \"35109a3849a633155ab4c6b37c09648c754e6669\";\nexport const gitDate = new Date(1615764034000);\nexport default { version, release, gitSha, gitDate };\n", "import { version } from \"./Version\"\n\nexport const isAlphaVersion = () => version.includes(\"-alpha\")\nexport const isBetaVersion = () => version.includes(\"-beta\")\nexport const channel = () =>\n  isAlphaVersion() ? \"alpha\" : isBetaVersion() ? \"beta\" : \"latest\"\n\n/**\n * @return \"1.2.3\", even if `version` is \"1.2.3-alpha.0\" or \"1.2.3-beta.32\"\n */\nexport const baseVersion = () => version.split(\"-\")[0]\n", "import { resolve } from \"path\"\nimport { notBlank } from \"../fe/Blank\"\nimport { lazy } from \"../fe/Lazy\"\nimport { homeDir } from \"./HomeDir\"\nimport { isWin } from \"./Platform\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\n\nexport async function picturesDirWindows() {\n  return isWin\n    ? PowerShell.instance().executeJson(\n        `Get-ItemPropertyValue \"Registry::HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\" -name \"My Pictures\"`\n      )\n    : undefined\n}\n\nexport const picturesDir = lazy(async () => {\n  if (isWin) {\n    const result = await picturesDirWindows()\n    if (notBlank(result)) return result\n  }\n  return defaultPicturesDir()\n})\n\nexport const defaultPicturesDir = lazy(() => resolve(homeDir(), \"Pictures\"))\n", "import { BatchCluster, Parser, Task } from \"batch-cluster\"\nimport { blank, mapNotBlankOr, notBlank } from \"../../fe/Blank\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { Endable, EndableRanks, ending } from \"../async/Endable\"\nimport { thenMap } from \"../async/Promise\"\nimport { thenOrTimeout } from \"../async/thenOrTimeout\"\nimport { until } from \"../async/until\"\nimport { BatchClusterObserver } from \"../BatchClusterObserver\"\nimport { execFile } from \"../child/ChildProcess\"\nimport { elapsedAsync } from \"../Elapsed\"\nimport { onClearCache } from \"../event/EventEmitter\"\nimport { ms2level } from \"../log/Logger\"\nimport { mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { Pojo } from \"../Object\"\nimport { isWin } from \"../Platform\"\nimport { Settings } from \"../settings/Settings\"\nimport { ellipsize, ensureSuffix, stripPrefix } from \"../String\"\nimport { CmdTimeoutMs, ShortCmdTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { maxCpus } from \"../work/MaxCpus\"\n\nconst maxProcAgeMillis = 10 * minuteMs\n\nconst Done = \"{ready}\"\n\nconst ConvertToCompressedJson = \" | ConvertTo-Json -Compress\"\n\nexport type Result = { stdout: string; stderr?: string; passed: boolean }\n\nexport interface PowerShellVersion {\n  Major: number\n  Minor: number\n  Build: number\n  Revision: number\n  MajorRevision: number\n  MinorRevision: number\n}\n\nexport function pwshQuote(s: string): string {\n  const s2 = s\n    .replace(/['`\"\u201C\u201D#]/g, ea => \"`\" + ea)\n    .replace(/\\0/g, \"`0\")\n    .replace(/\\n/g, \"`n\")\n    .replace(/\\r/g, \"`r\")\n    .replace(/\\t/g, \"`t\")\n    .replace(/\\v/g, \"`v\")\n  return '\"' + s2 + '\"'\n}\n\nfunction versionCommand() {\n  return [\n    `function prompt {\"${Done}\"}`,\n    ...mapNotBlankOr(\n      Settings.powerShellCulture.valueOrDefault,\n      ea => [\n        `[System.Threading.Thread]::CurrentThread.CurrentCulture = '${ea}'`,\n        `[System.Threading.Thread]::CurrentThread.CurrentUICulture = '${ea}'`\n      ],\n      []\n    )\n  ].join(\";\")\n}\n\nlater(() => onClearCache(() => PowerShell.instance.prior()?.clearMockResults()))\n\nexport class PowerShell implements Endable {\n  readonly name = \"PowerShell\"\n  static readonly instance = lazy(() => {\n    if (!isWin) throw new Error(\"PowerShell isn't available on this platform\")\n    return new PowerShell()\n  })\n  private readonly logger = mkLogger(\"PowerShell\")\n  private readonly bco: BatchClusterObserver<BatchCluster>\n  private readonly pwsh: BatchCluster\n  private readonly mockResults = new Map<string, Result>()\n\n  private constructor() {\n    this.bco = new BatchClusterObserver(\n      \"PowerShell\",\n      new BatchCluster({\n        processFactory: () =>\n          execFile(\n            \"powershell\",\n            Settings.powerShellArgs.values,\n            maxProcAgeMillis\n          ),\n        logger: () => mkLogger(\"PowerShell\"),\n        versionCommand: versionCommand(),\n        pass: Done,\n        fail: \"Error\",\n        exitCommand: \"exit\",\n        maxProcs: maxCpus() > 6 ? 3 : 2,\n        maxTasksPerProcess: 150, // based on absolutely nothing\n        taskTimeoutMillis: CmdTimeoutMs,\n        cleanupChildProcs: false\n      }),\n      EndableRanks.postdb // last to shut down.\n    )\n    this.pwsh = this.bco.t\n  }\n\n  get lastStartError() {\n    return this.bco.lastStartError\n  }\n\n  get lastTaskError() {\n    return this.bco.lastTaskError\n  }\n\n  end() {\n    return this.pwsh.end()\n  }\n\n  get ended() {\n    return this.pwsh.ended\n  }\n\n  versionPojo(): PromiseMaybe<PowerShellVersion> {\n    return this.executeJson(\"$PSVersionTable.PSVersion\")\n  }\n\n  version(): PromiseMaybe<string> {\n    return thenMap(\n      this.executeJson(\"$PSVersionTable.PSVersion\"),\n      ea => `${ea.Major}.${ea.Minor}.${ea.Build}`\n    )\n  }\n\n  get spawnedProcs() {\n    return this.pwsh.spawnedProcs\n  }\n\n  pushMockJsonResult(cmd: string, result: Result) {\n    this.pushMockResult(ensureSuffix(cmd, ConvertToCompressedJson), result)\n  }\n\n  pushMockResult(cmd: string, result: Result) {\n    this.mockResults.set(cmd, result)\n  }\n\n  clearMockResults() {\n    this.mockResults.clear()\n  }\n\n  async execute<T>(cmd: string, parser: Parser<T>): PromiseMaybe<T> {\n    if (this.pwsh.ended || ending()) {\n      this.logger.warn(\"execute() failed (ended)\", { cmd })\n      return\n    }\n\n    if (isTest && this.mockResults.has(cmd)) {\n      const f = this.mockResults.get(cmd)!\n      return parser(f.stdout, f.stderr, f.passed)\n    }\n\n    try {\n      this.logger.debug(\"execute()\", { cmd })\n      const r = await elapsedAsync(() =>\n        this.pwsh.enqueueTask(\n          new Task(\n            cmd,\n            (stdout: string, stderr: string | undefined, passed: boolean) =>\n              parser(map(stdout, ea => stripPrefix(ea, cmd))!, stderr, passed)\n          )\n        )\n      )\n      // launching PowerShell may take upwards of 3-4 seconds normally:\n      this.logger.log(ms2level(r.elapsedMs, 7 * secondMs), \"execute()\", {\n        cmd,\n        elapsedMs: r.elapsedMs\n      })\n      return r.result\n    } catch (err) {\n      this.logger.warn(\"execute() failed: \" + err, { cmd })\n      return\n    }\n  }\n\n  async executeJson(cmd: string): PromiseMaybe<any> {\n    const r = await this.execute(\n      ensureSuffix(cmd, ConvertToCompressedJson),\n      (stdout, stderr, passed) => ({ stdout, stderr, passed })\n    )\n    if (r == null) {\n      this.logger.warn(\"executeJson(): null result\", { cmd })\n      return\n    }\n    if (blank(r.stdout) || notBlank(r.stderr) || !r.passed) {\n      this.logger.warn(\"executeJson(): failed result\", { cmd, ...r })\n      return\n    }\n    try {\n      return JSON.parse(r.stdout)\n    } catch (err) {\n      const fixed = r.stdout.replace(/\\\\/g, \"\\\\\\\\\")\n      this.logger.info(\n        \"executeJson(): parsing failed, trying dub-whack fix...\",\n        { before: ellipsize(r.stdout), after: ellipsize(fixed) }\n      )\n      return JSON.parse(fixed)\n    }\n  }\n\n  async executeJsonToA(cmd: string): PromiseMaybe<Pojo[]> {\n    return thenMap(this.executeJson(cmd), json =>\n      Array.isArray(json) ? json : [json]\n    )\n  }\n}\n\nexport async function checkPowerShell() {\n  if (!isWin) return\n  const ps = PowerShell.instance()\n  if (ps.ended || ending()) return\n  const version = await thenOrTimeout(() => ps.version(), 7 * secondMs)\n  if (version == null) {\n    const err = await until(() => orElse(ps.lastStartError, ps.lastTaskError), {\n      timeoutMs: ShortCmdTimeoutMs,\n      timeBetweenMs: 250\n    })\n    if (err != null) throw err\n    else throw new Error(\"(unknown error)\")\n  }\n  return\n}\n", "import { isFalse, isTrue } from \"../../fe/Boolean\"\nimport { delay, unrefDelay } from \"../../fe/Delay\"\nimport { orElse } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { clamp } from \"../../fe/Number\"\nimport { isFunction } from \"../../fe/ObjectType\"\nimport { MaybeSyncOrAsync } from \"../../fe/OptAsync\"\nimport { randomInt } from \"../../fe/Random\"\n\nexport type UntilOpts<T> = {\n  timeoutMs?: number\n  timeBetweenMs?: number\n  acceptable?: (t: Maybe<T>) => boolean\n  timeoutResult?: T\n  unref?: boolean\n}\n\nexport async function until<T>(\n  f: () => MaybeSyncOrAsync<T>,\n  { timeoutMs, timeBetweenMs, acceptable, timeoutResult, unref }: UntilOpts<T>\n): PromiseMaybe<T> {\n  const timeoutAt = timeoutMs == null ? undefined : timeoutMs + Date.now()\n  while (timeoutAt == null || Date.now() < timeoutAt) {\n    const start = Date.now()\n    const result = await f()\n    if (\n      result == null ||\n      (isFunction(acceptable) ? !acceptable(result) : (result as any) === false)\n    ) {\n      const elapsed = Date.now() - start\n      const delayMs = orElse(timeBetweenMs, () =>\n        clamp(100, 5000, elapsed * randomInt(4, 10))\n      )\n      await (isFalse(unref) ? delay(delayMs) : unrefDelay(delayMs))\n    } else {\n      return result\n    }\n  }\n  return timeoutResult\n}\n\n/**\n * Run the given thunk until the promise is resolved to true, or the timeout\n * passes.\n * @return false on timeout, or true when the the given Later returned true.\n */\n\nexport async function untilTrue(\n  f: () => MaybeSyncOrAsync<boolean>,\n  opts: UntilOpts<boolean>\n) {\n  return until(f, {\n    ...opts,\n    acceptable: (ea: Maybe<boolean>) => isTrue(ea),\n    timeoutResult: false\n  }) as Promise<boolean>\n}\n", "import { BatchCluster } from \"batch-cluster\"\nimport { ChildProcess } from \"child_process\"\nimport { ExifTool } from \"exiftool-vendored\"\nimport _p from \"process\"\nimport { minuteMs, secondMs } from \"../fe/Date\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { EndableRank, EndableRanks, ending } from \"./async/Endable\"\nimport { EndableWrapper } from \"./async/EndableWrapper\"\nimport { endProcess } from \"./child/ChildProcess\"\nimport { onError } from \"./error/Error\"\nimport { isIgnorableError } from \"./error/ErrorTypes\"\nimport { addPid } from \"./Pids\"\nimport { renice } from \"./Renice\"\nimport { CmdTimeoutMs } from \"./volumes/VolumeTtls\"\n\n/**\n * Rather than spork (the technical term for monkeypatching an instance that was\n * invented here) in a name field into the exiftool or batch cluster singleton,\n * just facade it to be an Endable\n */\nexport class BatchClusterObserver<\n  T extends ExifTool | BatchCluster\n> extends EndableWrapper {\n  lastStartError: Maybe<Error>\n  lastInternalError: Maybe<Error>\n  lastTaskError: Maybe<Error>\n\n  constructor(\n    readonly name: string,\n    readonly t: T,\n    rank: EndableRank = EndableRanks.service,\n    addExitHandler = false\n  ) {\n    super(\n      name,\n      () => this.t.end(),\n      rank,\n      () => this.t.ended,\n      name === \"sync-file\" ? CmdTimeoutMs : secondMs\n    )\n\n    t.on(\"childStart\", (cp: ChildProcess) => {\n      this.logger.info(\"Started child process \" + name + \":\" + cp.pid)\n      renice(cp.pid).catch(err =>\n        this.onError(\"renice failed for \" + name, err)\n      )\n\n      // zombie prevention of ExifTool on Alpine:\n      if (addExitHandler) {\n        cp.on(\"exit\", () => endProcess(cp, 5 * secondMs))\n      }\n\n      addPid(\n        {\n          pid: cp.pid,\n          ppid: _p.pid,\n          cmd: name,\n          maxAgeMs: t.options.maxProcAgeMillis + minuteMs\n        },\n        new Date()\n      ).catch(err => this.onError(\"addPid failed for \" + name, err))\n    })\n    t.on(\"startError\", error => {\n      this.lastStartError = error\n      this.onError(\"failed to start\", error)\n    })\n    t.on(\"taskError\", (error, task) => {\n      this.lastTaskError = error\n      this.onError(\"failed to run \" + map(task, ea => ea.command), error)\n    })\n    t.on(\"internalError\", error => {\n      this.lastInternalError = error\n      this.onError(\"internal error\", error)\n    })\n    t.on(\"endError\", err => {\n      this.logger.error(\"observeBatchCluster.endError()\", err)\n    })\n  }\n\n  onError(reason: string, error: Error) {\n    // Avoid stack overflow on end (where end error asks services to shut down,\n    // which causes an end error, which ...)\n    if (!this.t.ended && !ending() && !isIgnorableError(error)) {\n      onError(this.name + \": \" + reason, error)\n    } else {\n      this.logger.warn(\"onError() (ending or ignorable): \" + reason, error)\n    }\n  }\n}\n", "import { mapOr } from \"../../fe/Maybe\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { addEndable, Endable, EndableRank } from \"./Endable\"\nimport { awaitAll } from \"./Promise\"\n\n/**\n * Base class for Endables.\n */\nexport class EndableWrapper implements Endable {\n  readonly logger: Logger\n  protected readonly onEnds: (() => any)[] = []\n  private _ended = false\n  /**\n   * @param name for logging\n   * @param _onEnd called by `this.end()`. May return a promise.\n   * @param _isEnded if the wrapped instance can end from other state mutations,\n   * providing this method will allow this wrapper to be garbage collected.\n   */\n  // TODO: destructure?\n  constructor(\n    readonly name: string,\n    onEnd: () => Promise<any> | any,\n    rank: EndableRank,\n    private readonly _isEnded?: () => boolean,\n    readonly endTimeoutMs?: number\n  ) {\n    this.logger = mkLogger(name)\n    this.onEnds.push(onEnd)\n    addEndable(rank, this)\n  }\n\n  get ended() {\n    return (\n      mapOr(\n        this._isEnded,\n        f => f(),\n        () => false\n      ) || this._ended\n    )\n  }\n\n  end() {\n    // don't run onEnds more than once:\n    if (this._ended) return\n    this._ended = true\n    return awaitAll(this.onEnds.map(ea => ea()))\n  }\n}\n", "import _cp from \"child_process\"\nimport _p from \"process\"\nimport { retryOnReject } from \"../../fe/AsyncRetry\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { secondMs } from \"../../fe/Date\"\nimport { delay, unrefDelay } from \"../../fe/Delay\"\nimport { stringify } from \"../../fe/JSON\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { denull, orElse } from \"../../fe/Maybe\"\nimport { gt0 } from \"../../fe/Number\"\nimport { omit, pick } from \"../../fe/Object\"\nimport { isFunction } from \"../../fe/ObjectType\"\nimport { toS } from \"../../fe/toS\"\nimport { Deferred } from \"../async/Deferred\"\nimport { thenNot } from \"../async/Promise\"\nimport { setUnrefTimeout } from \"../async/Timers\"\nimport { untilTrue } from \"../async/until\"\nimport { errorContains } from \"../error/Error\"\nimport { isIgnorableError } from \"../error/ErrorTypes\"\nimport { closeStreams, endStream } from \"../fs/Streams\"\nimport { mkLogger } from \"../Logger\"\nimport { isSingleSpecTests } from \"../NodeEnv\"\nimport { Try } from \"../Object\"\nimport { addPid, killPid, pidExists, Pids } from \"../Pids\"\nimport { isWin } from \"../Platform\"\nimport { renice } from \"../Renice\"\nimport { gist } from \"../String\"\nimport { spawnOptions } from \"./ChildEnv\"\n\nconst logger = lazy(() => mkLogger(\"ChildProcess\"))\n\nfunction cp2log(cp: _cp.ChildProcess) {\n  return pick(cp as any, \"pid\", \"killed\", \"connected\", \"exitCode\", \"signalCode\")\n}\n\nexport function waitForExit(pid: number, timeoutMs: number): Promise<boolean> {\n  return untilTrue(() => thenNot(pidExists(pid)), { timeoutMs })\n}\n\nexport async function endProcess(\n  cp: _cp.ChildProcess,\n  timeoutMs = 30 * secondMs\n): Promise<boolean> {\n  if (cp == null) return false\n\n  const pid = cp.pid\n  logger().debug(\"endProcess(\" + pid + \")\", {\n    killed: cp.killed,\n    connected: cp.connected\n  })\n  if (pid <= 0) {\n    logger().warn(\"endProcess(): asked to end invalid pid\", cp2log(cp))\n    return false\n  }\n  if (pid === _p.pid) {\n    logger().warn(\"endProcess(): asked to end MY pid\", cp2log(cp))\n    return false\n  }\n\n  // Let streams flush before closing:\n  await delay(250)\n  await closeStreams(cp)\n\n  {\n    // Send a SIGTERM\n    const killResult = cp.kill()\n    logger().debug(\"endProcess(\" + pid + \")\", {\n      killResult,\n      childGotSigterm: cp.killed\n    })\n    if (!killResult) {\n      await killPid(pid).catch(err => {\n        logger().warn(\"endProcess(): kill(\" + pid + \",false) failed: \" + err)\n      })\n    }\n  }\n\n  // We don't use messaging, but in case we do later:\n  // TODO: do we need to do this?\n  // if (cp.connected) Try(() => cp.disconnect())\n\n  // We can exit even if this child is still running:\n  Try(() => cp.unref())\n\n  // don't wait for cleanup if we're running tests:\n  if (isSingleSpecTests()) return true\n\n  if (await waitForExit(pid, timeoutMs)) {\n    logger().debug(\"endProcess(): exitted\", cp2log(cp))\n    return true\n  }\n\n  {\n    // OK, shite got real. time for kill -9.\n    void Pids.instance().onKill(pid)\n    const killResult = cp.kill(\"SIGKILL\")\n    logger().warn(\"endProcess(\" + pid + \") had to resort to SIGKILL\", {\n      killResult\n    })\n    if (!killResult) {\n      await killPid(pid, true).catch(err => {\n        logger().warn(\"endProcess(): kill(\" + pid + \",true) failed: \" + err)\n      })\n    }\n  }\n\n  // Give the OS some time to clean up:\n  return waitForExit(pid, 5000)\n}\n\nexport function niceable(\n  cmd: string,\n  args: string[] | readonly string[]\n): boolean {\n  return (\n    cmd !== \"renice\" &&\n    cmd !== \"which\" &&\n    cmd !== \"where\" && // windows version of \"which\"\n    [cmd, ...args].every(\n      ea =>\n        !ea.endsWith(\"web.js\") &&\n        !ea.endsWith(\"db.js\") &&\n        !ea.includes(\"sqlite3\")\n    )\n  )\n}\n\n// NOTE: MUST NOT BE ASYNC\nfunction newProc(\n  cp: _cp.ChildProcess,\n  cmd: string,\n  args: ReadonlyArray<string>,\n  maxAgeMs: number\n) {\n  const start = new Date()\n  // If we write the pidfile now and hold up processing, `cp.stderr` and\n  // `cp.stdout` event listeners will miss initial data, so we put this in a\n  // timeout for later.\n\n  // Note that THIS IS NOT UNREF'ed! We want pids to be cleaned up!\n\n  let exitted = false\n  cp.on(\"exit\", () => (exitted = true))\n\n  const _niceable = niceable(cmd, args)\n\n  setUnrefTimeout(\n    async () => {\n      if (exitted) return\n      await untilTrue(() => gt0(cp.pid), { timeoutMs: 5 * secondMs })\n      const pid = cp.pid\n      if (!gt0(pid)) {\n        logger().info(\n          \"newProc(): not writing pidfile, child_process has no pid\",\n          {\n            cmd,\n            cp: cp2log(cp)\n          }\n        )\n        return\n      } else {\n        if (_niceable) await renice(pid)\n        return addPid({ pid, cmd, maxAgeMs, ppid: _p.pid }, start)\n      }\n    },\n    isWin ? 500 : 250 // < windows regularly takes hundreds of millis to exec, and the fs is slow, so be nice/gentle on windows.\n  )\n  return cp\n}\n\nexport function spawn(\n  command: string,\n  args: ReadonlyArray<string>,\n  maxAgeMs: number,\n  options?: _cp.SpawnOptions\n): _cp.ChildProcess {\n  const opts = spawnOptions(options)\n  logger().debug(\"spawn()\", { command, args, maxAgeMs, opts })\n  return newProc(_cp.spawn(command, args, opts), command, args, maxAgeMs)\n}\n\nexport type ExecFileOptions =\n  | _cp.ExecFileOptions\n  | _cp.ExecFileOptionsWithBufferEncoding\n  | _cp.ExecFileOptionsWithStringEncoding\n\nexport function execFile(\n  command: string,\n  args: ReadonlyArray<string>,\n  maxAgeMs: number,\n  options?: ExecFileOptions\n): _cp.ChildProcess {\n  const opts = spawnOptions(options)\n  return newProc(_cp.execFile(command, args, opts), command, args, maxAgeMs)\n}\n\nexport type StdoutOpts = {\n  timeout: number\n  maxRetries?: number\n  quiet?: boolean\n  disconnect?: boolean\n  ignoreStderr?: boolean\n  ignoreExitCode?: boolean\n  isIgnorableError?: (err: any) => boolean\n} & _cp.ExecFileOptions\n\nexport type StdoutResult = {\n  result: string\n  pid: number\n  code?: number\n}\n\n/**\n * @throws on errors\n */\nexport async function stdoutResult(\n  cmd: string,\n  args: string[],\n  opts: StdoutOpts\n): Promise<StdoutResult> {\n  return retryOnReject(() => _stdoutResult(cmd, args, opts), {\n    timeoutMs: opts.timeout,\n    maxRetries: orElse(opts.maxRetries, 3),\n    onRetryWaitUntil: retryCount => unrefDelay(100 * retryCount),\n    errorIsRetriable: error =>\n      logger().tap({\n        msg: \"stdoutResult.errorIsRetriable()\",\n        result: errorContains(error, /EPERM/),\n        meta: { error, cmd, args }\n      })\n  })\n}\n\nasync function _stdoutResult(\n  cmd: string,\n  args: string[],\n  opts: StdoutOpts\n): Promise<StdoutResult> {\n  const quiet = orElse(opts.quiet, false)\n  const ignoreStderr = orElse(opts.ignoreStderr, false)\n  const ignoreExitCode = orElse(opts.ignoreExitCode, false)\n\n  const dataChunks: (Buffer | string)[] = []\n  logger().debug(\"stdoutResult(): execFile\", { cmd, args })\n  const proc = await execFile(\n    cmd,\n    args,\n    opts.timeout,\n    omit(\n      opts,\n      \"timeout\",\n      \"quiet\",\n      \"disconnect\",\n      \"ignoreStderr\",\n      \"ignoreExitCode\"\n    )\n  )\n\n  if (opts.disconnect === true) {\n    proc.disconnect()\n    return { result: \"\", pid: proc.pid }\n  }\n\n  const name = stringify({ cmd, args })\n  const d = new Deferred<StdoutResult>(name)\n  setTimeout(() => {\n    if (d.pending) {\n      logger().warn(\"stdoutResult(): SLOW COMMAND\", { cmd, args })\n    }\n  }, opts.timeout / 3).unref()\n\n  // timeout on linux and windows doesn't seem to work. We'll take care of it:\n  d.setTimeout(opts.timeout)\n\n  const onError = (ctx: string, error: any) => {\n    if (\n      isIgnorableError(error) ||\n      (isFunction(opts.isIgnorableError) && opts.isIgnorableError(error))\n    ) {\n      logger().debug(\"stdoutResult(): ignorable error for \" + ctx, {\n        cmd,\n        args,\n        opts,\n        error\n      })\n      return\n    }\n    if (proc.pid != null) {\n      void endProcess(proc)\n    }\n    if (!quiet)\n      logger().warn(\"stdoutResult(): \" + ctx, { cmd, args, opts, error })\n    if (d.pending) d.reject(error)\n  }\n  try {\n    proc.on(\"error\", err => onError(\"on(error)\", err))\n    proc.on(\"close\", code => {\n      const elapsedMs = Date.now() - d.start\n      const level = code !== 0 ? \"warn\" : \"debug\"\n      const result = dataChunks.join(\"\")\n      if (!quiet) {\n        logger().log(level, \"stdoutResult(): on(close)\", {\n          cmd,\n          code,\n          args,\n          elapsedMs,\n          result: gist(result, 160, 160)\n        })\n      }\n      if (!ignoreExitCode && code !== 0)\n        d.reject(\n          new Error(\"non-zero exit code: \" + stringify({ code, cmd, args }))\n        )\n      else d.resolve({ result, code: denull(code), pid: proc.pid })\n    })\n    void endStream(proc.stdin)\n    proc.stdout?.on(\"data\", ea => {\n      if (ea != null) dataChunks.push(ea)\n    })\n    proc.stderr?.on(\"error\", err => onError(\"stderr(error)\", err))\n    proc.stderr?.on(\"data\", err =>\n      ignoreStderr\n        ? logger().warn(\"stdoutResult(): stderr(data): \" + toS(err))\n        : onError(\"stderr(data)\", err)\n    )\n  } catch (err) {\n    onError(\"try/catch\", err)\n  }\n  return await d.promise\n}\n\n/**\n * @return just the stdout stream\n * @see stdoutResult if you need more information about the command.\n */\nexport function stdout(\n  cmd: string,\n  args: string[],\n  opts: StdoutOpts\n): Promise<string> {\n  return stdoutResult(cmd, args, opts).then(ea => ea.result)\n}\n\n/**\n * ONLY FOR SANITIZED INPUTS\n * @return just the stdout stream\n */\nexport function execStdout(cmd: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    _cp.exec(cmd, (err, sout, serr) =>\n      err != null ? reject(err) : notBlank(serr) ? reject(serr) : resolve(sout)\n    )\n  })\n}\n", "import { unrefDelay } from \"./Delay\"\nimport { orElse } from \"./Maybe\"\nimport { Maybe } from \"./MaybeTypes\"\nimport { gt0 } from \"./Number\"\nimport { opt } from \"./Opt\"\nimport { SyncOrAsync } from \"./OptAsync\"\n\nexport async function thenOrTimeout<T>(\n  p: () => Promise<T>,\n  timeoutMs: number\n): Promise<T> {\n  let resolved: Maybe<boolean>\n  return Promise.race([\n    p().then(ea => {\n      if (resolved == null) {\n        resolved = true\n        return ea\n      } else {\n        return\n      }\n    }),\n    // This delay must be unref'ed so as to not prevent node from exitting:\n    unrefDelay(timeoutMs).then(() => {\n      if (resolved == null) {\n        resolved = false\n        throw new Error(\"timeout\")\n      }\n      return\n    })\n  ]) as Promise<T>\n}\n\nexport function retryOnReject<T>(\n  f: () => Promise<T>,\n  opts: {\n    maxRetries: number\n    timeoutMs?: number\n    retryDelay?: number\n    onRetryWaitUntil?: (retryCount: number) => any\n    errorIsRetriable?: (error: Error) => SyncOrAsync<boolean>\n  }\n): Promise<T> {\n  const g = gt0(opts.timeoutMs) ? () => thenOrTimeout(f, opts.timeoutMs!) : f\n\n  if (opts.maxRetries <= 0) {\n    return g()\n  }\n  const onRetryWaitUntil = opt(\n    opts.onRetryWaitUntil\n  ).getOrElse(() => (retry: number) =>\n    unrefDelay((opts.retryDelay ?? 250) * orElse(retry, 1))\n  )\n  let retryCount = 0\n  const h: () => Promise<T> = async () => {\n    try {\n      return await g()\n    } catch (err) {\n      if (\n        false === (await opts.errorIsRetriable?.(err)) ||\n        retryCount > opts.maxRetries\n      ) {\n        throw err\n      } else {\n        retryCount++\n        await onRetryWaitUntil(retryCount)\n        return h()\n      }\n    }\n  }\n  return h()\n}\n", "import { inspect } from \"util\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { sigFigs } from \"../../fe/Number\"\nimport { mapGt0, mapGte0f } from \"../Number\"\nimport { TTLArray } from \"../TTLArray\"\nimport { avg, weightedAvg } from \"./Vector\"\n\nexport class Rate {\n  private _eventCount = 0\n  private _lastEventTime = 0\n  private readonly eventDeltas: TTLArray<number>\n\n  constructor(readonly ttlMs: number) {\n    if (ttlMs <= 0) throw new Error(\"ttlMs must be positive\")\n    this.eventDeltas = new TTLArray<number>(ttlMs)\n  }\n\n  [inspect.custom]() {\n    return this.stats()\n  }\n\n  stats() {\n    return {\n      ctor: \"Rate\",\n      epm: this.eventsPerMinute,\n      eventCount: this._eventCount,\n      msSinceLastEvent: this.msSinceLastEvent\n    }\n  }\n\n  onEvent() {\n    const now = Date.now()\n    if (this._lastEventTime > 0) {\n      this.eventDeltas.push(now - this._lastEventTime)\n    }\n    this._lastEventTime = now\n    this._eventCount++\n  }\n\n  clear() {\n    this._lastEventTime = 0\n    this._eventCount = 0\n    this.eventDeltas.clear()\n  }\n\n  get lastEventTime(): number {\n    return this._lastEventTime\n  }\n\n  get msSinceLastEvent() {\n    return Date.now() - this._lastEventTime\n  }\n\n  get eventCount(): number {\n    return this._eventCount\n  }\n\n  get avgMsBetweenEvent(): Maybe<number> {\n    return mapGt0(this.eventDeltas.length, () => weightedAvg(this.eventDeltas))\n  }\n\n  get msPerEvent(): Maybe<number> {\n    return avg(this.eventDeltas)\n  }\n\n  get eventsPerMs(): Maybe<number> {\n    return mapGte0f(this.msPerEvent, ea => 1 / ea)\n  }\n\n  get eventsPerSecond(): Maybe<number> {\n    return mapGte0f(this.eventsPerMs, ea => sigFigs(secondMs * ea, 3))\n  }\n\n  get eventsPerMinute(): Maybe<number> {\n    return mapGte0f(this.eventsPerMs, ea => sigFigs(minuteMs * ea, 3))\n  }\n}\n", "import { Maybe } from \"../fe/MaybeTypes\"\nimport { times } from \"../fe/Number\"\n\nexport class TTLArray<T> implements Iterable<T> {\n  private readonly times: number[] = []\n  private readonly a: T[] = []\n  constructor(readonly ttlMs: number, readonly maxLength?: number) {}\n\n  [Symbol.iterator](): Iterator<T, any, undefined> {\n    this.vacuum()\n    const arr = [...this.a]\n    function* iter(): IterableIterator<T> {\n      for (const k of arr) {\n        yield k\n      }\n    }\n    return iter()\n  }\n\n  push(...t: T[]) {\n    times(t.length, () => this.times.push(Date.now()))\n    this.a.push(...t)\n    if (this.maxLength != null) this.vacuum()\n  }\n\n  pushUniq(...t: T[]) {\n    t.forEach(ea => {\n      if (!this.includes(ea)) this.push(ea)\n    })\n  }\n\n  includes(t: T) {\n    this.vacuum()\n    return this.a.indexOf(t) >= 0\n  }\n\n  shift() {\n    this.vacuum()\n    this.times.shift()\n    return this.a.shift()\n  }\n\n  first() {\n    this.vacuum()\n    return this.a[0]\n  }\n\n  shiftOrFirst() {\n    return this.length > 1 ? this.shift() : this.first()\n  }\n\n  pop() {\n    this.vacuum()\n    this.times.pop()\n    return this.a.pop()\n  }\n\n  get length(): number {\n    this.vacuum()\n    return this.a.length\n  }\n\n  clear(): this {\n    this.times.length = 0\n    this.a.length = 0\n    return this\n  }\n\n  get values(): T[] {\n    this.vacuum()\n    return [...this.a]\n  }\n\n  oldestEntryAge(): Maybe<number> {\n    this.vacuum()\n    return this.times[0]\n  }\n\n  /**\n   * Remove all expired entries\n   */\n  private vacuum() {\n    if (this.a.length === 0) return\n    if (this.maxLength != null) {\n      const deleteCount = this.a.length - this.maxLength\n      this.times.splice(0, deleteCount)\n      this.a.splice(0, deleteCount)\n    }\n    const minTime = Date.now() - this.ttlMs\n    const firstGoodIndex = this.times.findIndex(ea => ea > minTime)\n    if (firstGoodIndex === -1) {\n      this.clear()\n    } else if (firstGoodIndex > 0) {\n      this.times.splice(0, firstGoodIndex)\n      this.a.splice(0, firstGoodIndex)\n    }\n  }\n}\n", "import { mapOr } from \"../../fe/Maybe\"\nimport { toS } from \"../../fe/toS\"\nimport { stripSuffix } from \"../String\"\n\nexport function describeError(ea: string) {\n  const key = stripSuffix(toS(ea).trim().toUpperCase(), \":\")\n  return mapOr(\n    ErrorCodes[key],\n    ec => ec.description,\n    () => ea\n  )\n}\n\nconst ErrorCodes = Object.freeze({\n  UNKNOWN: { errno: -1, description: \"unknown error\" },\n  OK: { errno: 0, description: \"success\" },\n  EOF: { errno: 1, description: \"end of file\" },\n  EADDRINFO: { errno: 2, description: \"getaddrinfo error\" },\n  EACCES: { errno: 3, description: \"permission denied\" },\n  EAGAIN: { errno: 4, description: \"resource temporarily unavailable\" },\n  EADDRINUSE: { errno: 5, description: \"address already in use\" },\n  EADDRNOTAVAIL: { errno: 6, description: \"address not available\" },\n  EAFNOSUPPORT: { errno: 7, description: \"address family not supported\" },\n  EALREADY: { errno: 8, description: \"connection already in progress\" },\n  EBADF: { errno: 9, description: \"bad file descriptor\" },\n  EBUSY: { errno: 10, description: \"resource busy or locked\" },\n  ECONNABORTED: { errno: 11, description: \"software caused connection abort\" },\n  ECONNREFUSED: { errno: 12, description: \"connection refused\" },\n  ECONNRESET: { errno: 13, description: \"connection reset by peer\" },\n  EDESTADDRREQ: { errno: 14, description: \"destination address required\" },\n  EFAULT: { errno: 15, description: \"bad address in system call argument\" },\n  EHOSTUNREACH: { errno: 16, description: \"host is unreachable\" },\n  EINTR: { errno: 17, description: \"interrupted system call\" },\n  EINVAL: { errno: 18, description: \"invalid argument\" },\n  EISCONN: { errno: 19, description: \"socket is already connected\" },\n  EMFILE: { errno: 20, description: \"too many open files\" },\n  EMSGSIZE: { errno: 21, description: \"message too long\" },\n  ENETDOWN: { errno: 22, description: \"network is down\" },\n  ENETUNREACH: { errno: 23, description: \"network is unreachable\" },\n  ENFILE: { errno: 24, description: \"file table overflow\" },\n  ENOBUFS: { errno: 25, description: \"no buffer space available\" },\n  ENOMEM: { errno: 26, description: \"not enough memory\" },\n  ENOTDIR: { errno: 27, description: \"not a directory\" },\n  EISDIR: { errno: 28, description: \"illegal operation on a directory\" },\n  ENONET: { errno: 29, description: \"machine is not on the network\" },\n  ENOTCONN: { errno: 31, description: \"socket is not connected\" },\n  ENOTSOCK: { errno: 32, description: \"socket operation on non-socket\" },\n  ENOTSUP: { errno: 33, description: \"operation not supported on socket\" },\n  ENOENT: { errno: 34, description: \"no such file or directory\" },\n  ENOSYS: { errno: 35, description: \"function not implemented\" },\n  EPIPE: { errno: 36, description: \"broken pipe\" },\n  EPROTO: { errno: 37, description: \"protocol error\" },\n  EPROTONOSUPPORT: { errno: 38, description: \"protocol not supported\" },\n  EPROTOTYPE: { errno: 39, description: \"protocol wrong type for socket\" },\n  ETIMEDOUT: { errno: 40, description: \"connection timed out\" },\n  ECHARSET: { errno: 41, description: \"invalid Unicode character\" },\n  EAIFAMNOSUPPORT: {\n    errno: 42,\n    description: \"address family for hostname not supported\"\n  },\n  EAISERVICE: {\n    errno: 44,\n    description: \"servname not supported for ai_socktype\"\n  },\n  EAISOCKTYPE: { errno: 45, description: \"ai_socktype not supported\" },\n  ESHUTDOWN: {\n    errno: 46,\n    description: \"cannot send after transport endpoint shutdown\"\n  },\n  EEXIST: { errno: 47, description: \"file already exists\" },\n  ESRCH: { errno: 48, description: \"no such process\" },\n  ENAMETOOLONG: { errno: 49, description: \"name too long\" },\n  EPERM: { errno: 50, description: \"operation not permitted\" },\n  ELOOP: { errno: 51, description: \"too many symbolic links encountered\" },\n  EXDEV: { errno: 52, description: \"cross-device link not permitted\" },\n  ENOTEMPTY: { errno: 53, description: \"directory not empty\" },\n  ENOSPC: { errno: 54, description: \"no space left on device\" },\n  EIO: { errno: 55, description: \"i/o error\" },\n  EROFS: { errno: 56, description: \"read-only file system\" },\n  ENODEV: { errno: 57, description: \"no such device\" },\n  ESPIPE: { errno: 58, description: \"invalid seek\" },\n  ECANCELED: { errno: 59, description: \"operation canceled\" }\n})\n", "import { compactBlanks } from \"../../fe/Array\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { errorToS, errorToVerbose } from \"../../fe/Error\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { lt } from \"../../fe/Number\"\nimport { toS } from \"../../fe/toS\"\nimport { ending } from \"../async/Endable\"\nimport { eventEmitter } from \"../event/EventEmitter\"\nimport { currentFileLogger, mkLogger } from \"../Logger\"\nimport { Rate } from \"../math/Rate\"\nimport { isMainService } from \"../ServiceNames\"\nimport { Settings } from \"../settings/Settings\"\nimport { ellipsize, stripAnsiEsc, stripPrefix } from \"../String\"\nimport { describeError } from \"./ErrorCodes\"\nimport {\n  extractErrorFlags,\n  isFatalError,\n  isIgnorableError,\n  stripErrorFlags\n} from \"./ErrorTypes\"\n\nconst StartTs = Date.now()\n\nconst logger = lazy(() => mkLogger(\"Error\"))\n\nconst errorRate = new Rate(minuteMs)\nconst fatalErrorRate = new Rate(minuteMs)\n\nexport function mapError<T>(obj: any, f: (error: Error) => T): Maybe<T> {\n  return obj instanceof Error ? f(obj) : undefined\n}\n\nexport function errorContains(err: any, re: RegExp): boolean {\n  return re.exec(errorToS(err)) != null\n}\n\n/**\n * Should this error be considered fatal to this process?\n */\nexport function isFatalErrorAllowed(): boolean {\n  const postProbation =\n    Date.now() > StartTs + Settings.probationMs.valueOrDefault\n\n  const lowErrorRate = lt(\n    fatalErrorRate.eventsPerMinute,\n    Settings.fatalErrorRatePerMinute.valueOrDefault\n  )\n\n  // The only time a fatal error should not be considered fatal is by the main\n  // service, after passing probation, and the error rate is not too high:\n\n  return logger().tap({\n    level: \"info\",\n    msg: \"isFatalErrorAllowed()\",\n    result: isMainService() && postProbation && lowErrorRate,\n    meta: {\n      mainService: isMainService(),\n      postProbation,\n      lowErrorRate,\n      fatalErrorRatePerMin: fatalErrorRate.eventsPerMinute,\n      errorRatePerMin: errorRate.eventsPerMinute,\n      fatalErrorRatePerMinuteSetting:\n        Settings.fatalErrorRatePerMinute.valueOrDefault\n    }\n  })\n}\n\nexport function throws(f: () => any): boolean {\n  try {\n    f()\n    return false\n  } catch {\n    return true\n  }\n}\n\nexport function stack(): string[] {\n  const e: any = {}\n  Error.captureStackTrace(e, stack)\n  return e.stack.split(/\\n(?:\\s*at\\s+)?/).slice(1)\n}\n\nconst trimPatterns = [\n  /^error:? /i,\n  /^code\\b/i,\n  /^unhandledRejection:? /i,\n  /^uncaughtException:? /i,\n  /^[0-9T.: -]+Z? /i,\n  /\\[object Object]/i\n]\n\nexport function trimErrorMessage(msg: string): string {\n  let result = stripErrorFlags(stripAnsiEsc(msg))\n  let prior = result\n  do {\n    prior = result\n    result = trimPatterns.reduce((s, re) => s.replace(re, \"\"), result).trim()\n  } while (prior !== result)\n\n  return compactBlanks(\n    result.split(/\\s+/).map(ea => {\n      if (ea.startsWith(\"E\")) {\n        const desc = describeError(ea)\n        if (result.toLowerCase().includes(desc.toLowerCase())) {\n          return \"\"\n        } else {\n          return desc + \":\"\n        }\n      }\n      return ea\n    })\n  ).join(\" \")\n}\n\nexport function errorToHumanString(\n  err: string | Error,\n  maxChars = 256\n): string {\n  const s = errorToS(err)\n  const flags = extractErrorFlags(s)\n  return ellipsize(trimErrorMessage(s), maxChars - flags.length) + flags\n}\n\nexport function cleanError(msg: string, context: string): string {\n  return toS(msg)\n    .split(/\\r?\\n/)\n    .map(ea => stripPrefix(ea, context))\n    .map(ea => ea.replace(/: ?/, \"\"))\n    .filter(notBlank)\n    .join(\", \")\n}\n\nexport function onError(message: string, error?: Error, context?: any): void {\n  if (blank(message) && error == null) {\n    logger().warn(\"onError() with empty args\", stack())\n    return\n  }\n  const s = errorToS(message) + errorToS(error) + errorToS(context)\n  const fatal = isFatalError(error) || isFatalError(s) || isTrue(context?.fatal)\n  if (!fatal && isIgnorableError(s)) {\n    logger().info(\"onError(): (ignorable): \" + errorToVerbose(error), {\n      message,\n      ...context\n    })\n    return\n  }\n\n  void map(currentFileLogger(), ea => ea.writeRecentLogEntries())\n\n  errorRate.onEvent()\n  if (fatal) fatalErrorRate.onEvent()\n  const event = !fatal || isFatalErrorAllowed() ? \"nonFatal\" : \"fatal\"\n  logger().log(\n    event === \"fatal\" ? \"error\" : \"warn\",\n    \"onError(): \" + errorToVerbose(error),\n    {\n      event,\n      message,\n      ...orElse(context, {})\n    }\n  )\n  if (!ending()) {\n    // Only propagate errors if we're not ending.\n    eventEmitter.emit(event, { message, error })\n  }\n}\n\nexport function addMessage(error: Maybe<Error>, message: Maybe<string>) {\n  if (error == null) return new Error(message)\n\n  if (notBlank(message)) {\n    if (!error.message.toLowerCase().includes(message.toLowerCase())) {\n      error.message += \": \" + message\n    }\n  }\n  return error\n}\n", "import _cp from \"child_process\"\nimport _p from \"process\"\nimport { compact, flatten, isEmpty, sortBy, uniq } from \"../fe/Array\"\nimport { notBlank } from \"../fe/Blank\"\nimport { ago, minuteMs, secondMs } from \"../fe/Date\"\nimport { lazy } from \"../fe/Lazy\"\nimport { map, orElse } from \"../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { gt0, toInt } from \"../fe/Number\"\nimport { opt } from \"../fe/Opt\"\nimport { toA } from \"../fe/toA\"\nimport { toS } from \"../fe/toS\"\nimport { Endable, EndableRanks, ending } from \"./async/Endable\"\nimport { EndableWrapper } from \"./async/EndableWrapper\"\nimport { thenMap, thenNot } from \"./async/Promise\"\nimport { Promises } from \"./async/Promises\"\nimport { setUnrefInterval } from \"./async/Timers\"\nimport { onError } from \"./error/Error\"\nimport { FifoCache } from \"./FifoCache\"\nimport { BaseFile } from \"./fs/BaseFile\"\nimport { parseNativePath } from \"./fs/Path\"\nimport { mkLogger } from \"./Logger\"\nimport { toMapAsync } from \"./Map\"\nimport { mapGt0 } from \"./Number\"\nimport { identity, Try } from \"./Object\"\nimport { isWin } from \"./Platform\"\nimport { pidInfo, pidInfos, ProcEntry } from \"./Ps\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\nimport { userData } from \"./UserData\"\n\nconst logger = lazy(() => mkLogger(\"Pids\"))\n\nexport interface PidfileInfo {\n  pid: number\n  cmd: string // < only for debugging\n  ppid: number // < if ppid is gone, reap.\n  /**\n   * If <= 0, the process can run indefinitely (like web or sync)\n   */\n  maxAgeMs: number\n}\n\nexport interface PidfileJson extends PidfileInfo {\n  startTime: number\n  timeoutTime?: number\n}\n\n// yeah, it's a lot of slop, but addPid() is called after a timeout, so start\n// isn't really the start time.\nconst AllowableStartSlopMs = 10 * secondMs\n\nfunction matchesPidfileInfo(\n  info: Maybe<PidfileJson>,\n  entry: Maybe<ProcEntry>\n): boolean {\n  if (info == null || entry == null) return false\n\n  // The start times need to match, ish:\n  const entryStartTime = map(entry.start, ea => ea.getTime())\n  const fileStartTime = info.startTime\n  return (\n    gt0(entryStartTime) &&\n    gt0(fileStartTime) &&\n    Math.abs(entryStartTime - fileStartTime) < AllowableStartSlopMs\n  )\n\n  // Command names can change, so we just use the start time to match PIDs.\n}\n\nasync function matchesPidfile(\n  pidfile: Maybe<BaseFile>,\n  entry: Maybe<ProcEntry>\n): Promise<boolean> {\n  if (pidfile == null || entry == null) return false\n  if (pidfile.name !== toS(entry.pid)) return false\n  return matchesPidfileInfo(await pidfile.readJson<PidfileJson>(), entry)\n}\n\nfunction killWinTaskkill(pid: number, force = false) {\n  const args = [\"/PID\", toS(toInt(pid)), \"/T\"]\n  if (force) {\n    args.push(\"/F\")\n  }\n  _cp.execFile(\"taskkill\", args)\n}\n\nasync function killWin(pid: number, force = false) {\n  if (ending() || PowerShell.instance().ended) {\n    return killWinTaskkill(pid, force)\n  }\n\n  try {\n    // https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/stop-process?view=powershell-6\n    const cmd = compact([\n      \"Stop-Process\",\n      \"-Id\",\n      toInt(pid),\n      force ? \"-Force\" : undefined\n    ]).join(\" \")\n    await PowerShell.instance().execute(cmd, identity)\n  } catch (err) {\n    logger().warn(\"killWin(): pwsh error, using TASKKILL: \" + err)\n    killWinTaskkill(pid, force)\n  }\n}\nasync function killPosix(pid: number, force = false) {\n  try {\n    _p.kill(pid, force ? \"SIGKILL\" : \"SIGTERM\")\n  } catch (err) {\n    if (!String(err).includes(\"ESRCH\")) throw err\n  }\n}\n\n/**\n * Send a signal to the given process id.\n *\n * @export\n * @param {number} pid the process id. Required.\n * @param {boolean} [force=false] if true, and the current user has\n * permissions to send the signal, the pid will be forced to shut down.\n */\nexport function killPid(\n  pid: number,\n  force = false,\n  rewritePidfileOnForce = true\n) {\n  if (pid === _p.pid || pid === _p.ppid) {\n    throw new Error(\"cannot self-terminate\")\n  }\n  if (force && rewritePidfileOnForce) {\n    void Pids.instance().onKill(pid)\n  }\n  return isWin ? killWin(pid, force) : killPosix(pid, force)\n}\n\nexport async function pidExists(pid: number): Promise<boolean> {\n  const pi = await pidInfo(pid)\n  return pi != null\n}\n\nexport function pidNotExists(pid: number): Promise<boolean> {\n  return thenNot(pidExists(pid))\n}\n\nexport class Pids {\n  static readonly instance = lazy(() => new Pids())\n  private readonly p = new Promises()\n  private readonly recentPids = new FifoCache<Promise<BaseFile>>(10 * secondMs)\n  constructor(readonly pidsDir = BaseFile.for(userData()).join(\"pids\")) {}\n\n  async addPid(\n    info: PidfileInfo,\n    start: Date,\n    force = false\n  ): Promise<BaseFile> {\n    if (info == null) {\n      throw new Error(\"undefined info\")\n    }\n    const pid = info.pid\n    if (!gt0(pid)) {\n      throw new Error(\"undefined pid\")\n    }\n    const key = info.ppid + \":\" + info.pid\n    if (force) this.recentPids.delete(key)\n    return this.recentPids.getOrSet(key, async () => {\n      const f = this.pidsDir.join(info.pid + \".json\")\n      const cmd = opt(Try(() => parseNativePath(info.cmd).base))\n        .filter(notBlank)\n        .getOrElse(() => info.cmd)\n\n      const startTime = start.getTime()\n      const timeoutTime = mapGt0(info.maxAgeMs, ea => startTime + ea)\n      const json: PidfileJson = {\n        ...info,\n        cmd,\n        startTime,\n        timeoutTime\n      }\n      if (null == (await f.writeJsonMaybe(json))) {\n        return logger().throw(\"Failed to write to \" + f, { info, force })\n      }\n      logger().debug(\"addPid() wrote \" + f, json)\n      return f\n    })\n  }\n\n  pidfiles() {\n    return this.pidsDir\n      .clear()\n      .children(ea => ea.ext === \".json\" && null != toInt(ea.name))\n  }\n\n  async onKill(pid: number): PromiseMaybe<BaseFile> {\n    const pidfile = this.pidsDir.join(pid + \".json\")\n    return thenMap(pidfile.clear().readJson<PidfileJson>(), priorInfo =>\n      this.addPid({ ...priorInfo, maxAgeMs: 1 }, ago(minuteMs), true).catch(\n        err => {\n          logger().info(\"onKill(): failed to rewrite pidfile: \" + err, { pid })\n          return undefined\n        }\n      )\n    )\n  }\n\n  /**\n   * Remove all pidfiles that aren't running anymore\n   */\n  private async vacuumPids() {\n    const pidfiles = await this.pidfiles()\n    const pids = toA(pidfiles)\n      .map(ea => toInt(ea.name))\n      .filter(gt0)\n    if (isEmpty(pids)) return\n\n    const entries = await pidInfos(pids)\n    if (entries == null) {\n      onError(\"Failed to get pidInfo for pids \" + pids)\n      return\n    }\n    logger().debug(\"vacuumPids\", {\n      pids,\n      pidfiles: toA(pidfiles).map(ea => ea.base),\n      entries\n    })\n    for (const pidfile of pidfiles!) {\n      const psEntry = entries.find(ea => toS(ea.pid) === pidfile.name)\n      if (psEntry == null || !(await matchesPidfile(pidfile, psEntry))) {\n        logger().debug(\"vacuumPids(): Removing old pidfile \" + pidfile.base, {\n          psEntry,\n          pidfile: await pidfile\n            .readFile()\n            .then(toS)\n            .catch(err => \"(failed to read file: \" + err + \")\")\n        })\n        await pidfile.unlink()\n      }\n    }\n    return\n  }\n\n  /**\n   * @param everything if `true`, ignore pidfile maxAgeMs.\n   * @param force given to `kill`.\n   */\n  readonly killOldProcs = (\n    opts: {\n      everything?: boolean\n      force?: boolean\n      everythingBefore?: number\n    } = {}\n  ) =>\n    this.p.serial(\"killOldProcs()\", async () => {\n      const everything = orElse(opts.everything, false)\n      const force = orElse(opts.force, isWin)\n      const pidfiles = await this.pidfiles()\n      const pid2pidfile = await toMapAsync(pidfiles, ea =>\n        thenMap(\n          ea.readJson<PidfileJson>(),\n          info => [info.pid, info] as [number, PidfileJson]\n        )\n      )\n      const pids = uniq(\n        flatten(toA(pid2pidfile.values()).map(ea => [ea.pid, ea.ppid]))\n      )\n      if (isEmpty(pids)) {\n        logger().debug(\"killOldProcs(): no pidfiles\")\n        return []\n      }\n      const allEntries = await pidInfos(pids)\n      logger().debug(\"killOldProcs()\", { pids, allEntries })\n      if (allEntries == null) {\n        onError(\"Pids.killOldProcs(): failed to get process information\")\n        return\n      }\n      const runningPids = new Set(allEntries.map(ea => ea.pid))\n      const trackedEntries = allEntries.filter(ea => pid2pidfile.has(ea.pid))\n\n      const trackedPids: (ProcEntry & PidfileJson)[] = sortBy(\n        compact(\n          trackedEntries.map(ea =>\n            map(pid2pidfile.get(ea.pid), info =>\n              matchesPidfileInfo(info, ea) ? { ...info!, ...ea } : undefined\n            )\n          )\n        ),\n        ea => ea.pid\n      ).filter(ea => _p.pid !== ea.pid) // < no suicide\n\n      const victims = everything\n        ? trackedPids\n        : trackedPids.filter(\n            ea =>\n              !runningPids.has(ea.ppid) || // if the parent pid is dead, kill.\n              !runningPids.has(ea.pid) || // if the pid is dead, kill.\n              (gt0(ea.timeoutTime) && Date.now() >= ea.timeoutTime) ||\n              (opts.everythingBefore != null &&\n                ea.startTime < opts.everythingBefore)\n          )\n      logger().debug(\"killOldProcs()\", {\n        trackedEntries,\n        victims,\n        pidfiles: toA(pid2pidfile.values())\n      })\n\n      for (const entry of victims) {\n        logger().debug(\"killOldProcs(): killing\", { entry })\n        void killPid(entry.pid, force, false)\n      }\n      await this.vacuumPids()\n      return sortBy(victims, ea => ea.pid)\n    })\n}\n\nexport function addPid(info: PidfileInfo, start: Date): Promise<BaseFile> {\n  return Pids.instance().addPid(info, start)\n}\n\n// Should only be invoked by MainService\nexport const ProcCleaner = lazy<Endable>(() => {\n  const timers = [\n    // TCBH: prime intervals so they don't collide unnecessarily:\n    { everything: false, force: false, intervalMs: 5 * minuteMs },\n    { everything: false, force: true, intervalMs: 17 * minuteMs }\n  ].map(ea =>\n    setUnrefInterval(() => Pids.instance().killOldProcs(ea), ea.intervalMs)\n  )\n  return new EndableWrapper(\n    \"ProcCleaner\",\n    () => {\n      timers.map(clearInterval)\n      return Pids.instance().killOldProcs()\n    },\n    EndableRanks.predb\n  )\n})\n", "import { inspect } from \"util\"\nimport { isNotEmpty, uniq } from \"../fe/Array\"\nimport { GetOrSet } from \"../fe/GetOrSet\"\nimport { orElse } from \"../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { gt0, round } from \"../fe/Number\"\nimport { toS } from \"../fe/toS\"\nimport { thenOrTimeout } from \"./async/thenOrTimeout\"\nimport { setUnrefInterval } from \"./async/Timers\"\nimport { until } from \"./async/until\"\nimport { union } from \"./Set\"\n\n// simple null-safe keys()\nfunction keys(o: any): string[] {\n  return o == null ? [] : Object.keys(o)\n}\n\n/**\n * First-in-first-out cache. Implementation inspired by\n * https://github.com/dominictarr/hashlru.\n *\n * https://en.wikipedia.org/wiki/Cache_replacement_policies\n */\nexport class FifoCache<V> implements GetOrSet<string, V> {\n  private currentCache!: Record<string, V>\n  private setsSinceLastSpill: number = 0\n  private priorCache!: Record<string, V>\n  private clearInterval?: NodeJS.Timeout\n\n  private readonly expireListeners: ((k: string, v: V) => void)[] = []\n\n  constructor(readonly maxSize: number, readonly clearEveryMs?: number) {\n    if (maxSize < 1) {\n      throw new Error(\"maxSize must be positive\")\n    }\n    if (maxSize > 30_000) {\n      // 30 seconds\n      throw new Error(\"maxSize is too big\")\n    }\n    // Set up _size and caches:\n    this.clear()\n    if (gt0(clearEveryMs)) {\n      this.clearInterval = setUnrefInterval(() => {\n        this.spill()\n      }, round(clearEveryMs / 2))\n    }\n  }\n\n  private spill() {\n    if (\n      this.priorCache != null &&\n      this.currentCache != null &&\n      isNotEmpty(this.expireListeners)\n    ) {\n      for (const k in this.priorCache) {\n        if (this.currentCache[k] == null) {\n          const v = this.priorCache[k]\n          if (v != null) {\n            for (const el of this.expireListeners) {\n              el(k, v)\n            }\n          }\n        }\n      }\n    }\n    this.priorCache = this.currentCache ?? Object.create(null)\n    this.currentCache = Object.create(null)\n    this.setsSinceLastSpill = 0\n  }\n\n  [inspect.custom]() {\n    return {\n      ...this.priorCache,\n      ...this.currentCache\n    }\n  }\n\n  end() {\n    if (this.clearInterval != null) clearInterval(this.clearInterval)\n  }\n\n  clear(): this {\n    this.visit((k, v) => {\n      for (const el of this.expireListeners) {\n        el(k, v)\n      }\n    })\n    this.currentCache = Object.create(null)\n    this.priorCache = Object.create(null)\n    this.setsSinceLastSpill = 0\n    return this\n  }\n\n  get size(): number {\n    if (this.currentCache == null || this.priorCache == null) return 0\n    let sum = 0\n    for (const k of union(keys(this.priorCache), keys(this.currentCache))) {\n      if (this.has(k)) sum++\n    }\n    return sum\n  }\n\n  // private get currentSize(): number {\n  //   if (this.currentCache == null) return 0\n  //   let sum = 0\n  //   for (const k in this.currentCache) {\n  //     if (this.currentCache[k] != null) sum++\n  //   }\n  //   return sum\n  // }\n\n  has(key: string): boolean {\n    return this.currentCache[key] != null || this.priorCache[key] != null\n  }\n\n  keys(): string[] {\n    return uniq([...keys(this.priorCache), ...keys(this.currentCache)]).filter(\n      k => null != this.currentCache[k] ?? this.priorCache[k]\n    )\n  }\n\n  delete(key: string) {\n    // We don't decrement size here, because we don't use `delete\n    // this.currentCache[key]` (because it's slow)\n    const v = this.currentCache[key]\n    if (v != null) {\n      this.currentCache[key] = undefined as any\n      for (const el of this.expireListeners) {\n        el(key, v)\n      }\n    }\n    const v2 = this.priorCache[key]\n    if (v2 != null) {\n      this.priorCache[key] = undefined as any\n      if (v == null) {\n        for (const el of this.expireListeners) {\n          el(key, v2)\n        }\n      }\n    }\n  }\n\n  visit(visitor: (key: string, value: V) => any) {\n    for (const k of union(keys(this.priorCache), keys(this.currentCache))) {\n      const v = this.currentCache[k] ?? this.priorCache[k]\n      if (v != null) visitor(k, v)\n    }\n  }\n\n  deleteIf(predicate: (key: string, value: V) => boolean) {\n    for (const k of this.keys()) {\n      const v = orElse(this.currentCache[k], this.priorCache[k])\n      if (v != null) {\n        if (predicate(k, v)) {\n          this.delete(k)\n        }\n      }\n    }\n  }\n\n  get(key: string | number) {\n    key = toS(key)\n    return this.currentCache[key] ?? this.priorCache[key]\n  }\n\n  set(key: string | number, value: V) {\n    key = toS(key)\n    if (this.currentCache[key] == null) {\n      if (this.setsSinceLastSpill >= this.maxSize) this.spill()\n      this.setsSinceLastSpill++\n    }\n    this.currentCache[key] = value\n  }\n\n  getOrSet(key: string | number, valueThunk: () => V): V {\n    key = toS(key)\n    const prior = this.get(key)\n    if (prior != null) return prior\n\n    const v = valueThunk()\n    this.set(key, v)\n    return v\n  }\n\n  on(_event: \"expire\", listener: (k: string, v: V) => void) {\n    this.expireListeners.push(listener)\n  }\n}\n\nexport interface Placeholder {\n  __uid: number\n  __start: number\n}\n\nexport class FifoCacheAsync<V> {\n  private uid = 0\n  private cacheSyncHits = 0\n  private cacheAsyncHits = 0\n  private cacheMisses = 0\n  private timeouts = 0\n  readonly cache: FifoCache<V | Placeholder>\n  constructor(\n    readonly opts: { maxSize: number; timeoutMs: number; clearEveryMs?: number }\n  ) {\n    this.cache = new FifoCache(opts.maxSize, opts.clearEveryMs)\n  }\n\n  get size() {\n    return this.cache.size\n  }\n\n  stats() {\n    return {\n      size: this.size,\n      cacheSyncHits: this.cacheSyncHits,\n      cacheAsyncHits: this.cacheAsyncHits,\n      cacheMisses: this.cacheMisses,\n      timeouts: this.timeouts\n    }\n  }\n\n  get(key: string): Maybe<V> {\n    const v = this.cache.get(key)\n    return v == null || v[\"__uid\"] != null ? undefined : (v as V)\n  }\n\n  clear() {\n    this.cache.clear()\n    this.cacheSyncHits = 0\n    this.cacheAsyncHits = 0\n    this.cacheMisses = 0\n    this.timeouts = 0\n  }\n\n  deleteIf(predicate: (key: string) => boolean) {\n    for (const k of this.cache.keys()) {\n      if (predicate(k)) {\n        this.cache.delete(k)\n      }\n    }\n  }\n\n  async getOrSetAsync(\n    key: string,\n    later: () => Promise<V>,\n    retries = 1\n  ): PromiseMaybe<V> {\n    key = toS(key)\n    {\n      const result = this.get(key)\n      if (result != null) {\n        this.cacheSyncHits++\n        // logger().debug(\"getOrSetAsync(): prior value\")\n        return result\n      }\n    }\n\n    const __uid = this.uid++\n    const __start = Date.now()\n    const prior = this.cache.getOrSet(key, () => ({\n      __uid,\n      __start\n    }))\n    // logger().debug(\"getOrSetAsync(): prior\", {\n    //   key,\n    //   prior,\n    //   current: { __uid, __start }\n    // })\n    if (prior[\"__uid\"] === __uid) {\n      // logger().debug(\"getOrSetAsync(): applying later...\", {\n      //   key,\n      //   prior,\n      //   current: { __uid, __start }\n      // })\n      this.cacheMisses++\n\n      // I get to run the later, yay!\n      return thenOrTimeout(\n        later,\n        this.opts.timeoutMs,\n        () => {\n          this.timeouts++\n          if (this.cache.get(key)?.[\"__uid\"] === __uid) this.cache.delete(key)\n          return\n        },\n        v => {\n          // logger().debug(\"getOrSetAsync(): onSuccess(): stored new value\", {\n          //   key,\n          //   __uid,\n          //   elapsedMs: Date.now() - __start\n          // })\n          this.cache.set(key, v)\n        }\n      )\n    } else {\n      // Remaining time for prior call:\n      const priorStart = prior[\"__start\"]\n      if (priorStart != null) {\n        const priorTimeoutAt = priorStart + this.opts.timeoutMs\n        const priorTimeoutMs = priorTimeoutAt - Date.now()\n        if (priorTimeoutMs > 0) {\n          // logger().debug(\n          //   \"getOrSetAsync(): waiting for concurrent resolution...\",\n          //   { priorTimeoutMs }\n          // )\n          const v = until(() => this.get(key), {\n            timeoutMs: priorTimeoutMs\n          })\n          if (v != null) {\n            this.cacheAsyncHits++\n            // logger().debug(\"getOrSetAsync(): returning concurrent prior\", {\n            //   key\n            // })\n            return v\n          }\n        }\n      }\n      return retries > 0\n        ? this.getOrSetAsync(key, later, retries - 1)\n        : undefined\n    }\n  }\n}\n", "import fs from \"fs\"\nimport fse from \"fs-extra\"\nimport { join, sep } from \"path\"\nimport { Readable, Transform } from \"stream\"\nimport { inspect } from \"util\"\nimport { createBrotliCompress, createGunzip, createGzip } from \"zlib\"\nimport {\n  compact,\n  flatten,\n  includesAll,\n  isEmpty,\n  isNotEmpty,\n  startsWith,\n  uniq\n} from \"../../fe/Array\"\nimport { retryOnReject } from \"../../fe/AsyncRetry\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { fmtYMDHMS, minuteMs, secondMs, unixtime } from \"../../fe/Date\"\nimport { delay } from \"../../fe/Delay\"\nimport { stringify } from \"../../fe/JSON\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { map, map3, mapOr, orElse } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { closeTo } from \"../../fe/Number\"\nimport { opt } from \"../../fe/Opt\"\nimport { newlineRe } from \"../../fe/String\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { MiB } from \"../../fe/Units\"\nimport { leastIndex, max } from \"../Array\"\nimport { Deferred } from \"../async/Deferred\"\nimport { apply, Predicate } from \"../async/Predicate\"\nimport {\n  filterAsync,\n  thenCompact,\n  thenDefined,\n  thenMap,\n  thenMap2Or,\n  thenMapOr,\n  thenNot,\n  thenOrElse\n} from \"../async/Promise\"\nimport { withBoundedConcurrency } from \"../async/Promises\"\nimport { time } from \"../async/PromiseTimer\"\nimport { untilTrue } from \"../async/until\"\nimport { stdout } from \"../child/ChildProcess\"\nimport { elapsedAsync } from \"../Elapsed\"\nimport { eql, eqlAsync } from \"../Eql\"\nimport { isNonRetriableError, NonRetriableErrorFlag } from \"../error/ErrorTypes\"\nimport { emitFileChanged, emitFileCopied } from \"../event/EventEmitter\"\nimport { LogLevel } from \"../log/LogLevel\"\nimport { mkLogger } from \"../Logger\"\nimport { min } from \"../math/Vector\"\nimport { Try } from \"../Object\"\nimport { isMac, isWin } from \"../Platform\"\nimport { PowerShell, pwshQuote } from \"../pwsh/PowerShell\"\nimport { Settings } from \"../settings/Settings\"\nimport { equalsIgnoreCase, pad2, stripPrefix, stripSuffix } from \"../String\"\nimport { diceCoeff } from \"../StringSimilarity\"\nimport { CmdTimeoutMs, MinIoRate } from \"../volumes/VolumeTtls\"\nimport { crlf, splitLines } from \"./CRLF\"\nimport { DirectoryEntry, StatDirent } from \"./DirectoryEntry\"\nimport { FileCache } from \"./FileCache\"\nimport { fileSha } from \"./Hash\"\nimport { LineReader } from \"./LineReader\"\nimport {\n  ensureNewNativePath_,\n  EnsureNewOptions,\n  isAbsolute,\n  isUNC,\n  nameWithoutCount,\n  native2posix,\n  parseNativePath,\n  posixPathFrom,\n  resolve\n} from \"./Path\"\nimport { PullProgressObserver, PushProgressObserver } from \"./ProgressObservers\"\nimport { ProjectPath } from \"./ProjectPath\"\nimport { SimpleFile } from \"./SimpleFile\"\nimport { onDataChunked } from \"./StreamChunker\"\nimport { ByteCounter, pipelineAsync } from \"./Streams\"\nimport { zCopyToBuffer_, zCopyTo_ } from \"./zcat\"\n\nexport const WipPrefix = isWin ? \"wip-\" : \".\"\n\nexport type WriteOptions = Partial<{\n  encoding: BufferEncoding\n  fd: number\n  mode: number\n  flags: string\n  emitClose: boolean\n  autoClose: boolean\n  start: number\n}>\n\nexport interface FileProgress {\n  path: string\n  /**\n   * operation (like \"sha\" or \"cp\")\n   */\n  op: string\n  /**\n   * percent complete\n   */\n  pct: number\n}\nconst cache = new FileCache<BaseFile>()\n\n/**\n * Extracted from PosixFile, this superclass is used by the FileLogger.\n *\n * It must not depend on core code that also requires a Logger.\n */\nexport class BaseFile implements SimpleFile {\n  protected readonly bflog = lazy(() =>\n    mkLogger(\"BaseFile(\" + this.nativePath + \")\")\n  )\n\n  protected static attrTTL = 3 * minuteMs\n  readonly posixPath: string\n  readonly nativePath: string\n\n  /** \"/home/user/dir\" of \"/home/user/dir/file.txt\" */\n  readonly dir: string\n  /** \"file.txt\" of \"/home/user/dir/file.txt\" */\n  readonly base: string\n  /** \"file\" of \"/home/user/dir/file.txt\" */\n  readonly name: string\n  /** \".txt\" of \"/home/user/dir/file.txt\" */\n  readonly ext: string\n\n  protected constructor(nativePath: string, private dirent?: DirectoryEntry) {\n    if (dirent != null) {\n      this.nativePath = dirent.nativePath\n      this.dir = dirent.dir\n      this.base = dirent.base\n      this.name = dirent.name\n      this.ext = dirent.ext\n    } else {\n      this.nativePath = resolve(nativePath)\n      const parsed = parseNativePath(this.nativePath)\n      this.dir = parsed.dir\n      this.base = parsed.base\n      this.name = parsed.name\n      this.ext = parsed.ext\n    }\n    this.posixPath = native2posix(this.nativePath)\n\n    cache.set(nativePath, this)\n  }\n\n  toJSON() {\n    return {\n      nativePath: this.nativePath\n    }\n  }\n\n  [inspect.custom]() {\n    return this.toJSON()\n  }\n\n  static async withFastestAccess<F extends BaseFile>(\n    files: Maybe<F>[]\n  ): PromiseMaybe<F> {\n    const arr = compact(files)\n    const msArr = await Promise.all(arr.map(f => f.shaMs()))\n    return arr[leastIndex(msArr)]\n  }\n\n  static projectRoot = lazy(() => {\n    const root = ProjectPath.Root()\n    if (root == null) {\n      throw new Error(\"Cannot find project path\")\n    } else {\n      return BaseFile.for(root)\n    }\n  })\n\n  static forPosix(posixPathOrFile: string | BaseFile) {\n    return posixPathOrFile instanceof BaseFile\n      ? posixPathOrFile\n      : this.for(posixPathOrFile.split(\"/\").join(sep))\n  }\n\n  static forDirectoryEntry(de: DirectoryEntry) {\n    return this.for(de.nativePath, de)\n  }\n\n  static for(nativePathOrFile: string | BaseFile, dirent?: DirectoryEntry) {\n    if (nativePathOrFile instanceof BaseFile) {\n      return nativePathOrFile\n    }\n    // PERF: resolve() is expensive.\n    const prior = cache.get(nativePathOrFile)\n    if (prior != null) return prior\n    const resolvedPath = resolve(nativePathOrFile)\n    return cache.getOrSet(\n      resolvedPath,\n      () => new BaseFile(resolvedPath, dirent)\n    )\n\n    // return new BaseFile(resolve(nativePathOrFile), dirent)\n  }\n\n  /**\n   * Wipe the instance cache and caches of all instances.\n   *\n   * This should only be used by tests.\n   *\n   * @param fromPath if undefined, all instances will be cleared.\n   */\n  static clear(fromPath?: string) {\n    emitFileChanged(fromPath)\n  }\n\n  for(path: string, dirent?: DirectoryEntry): this {\n    return BaseFile.for(path, dirent) as this\n  }\n\n  clear(): this {\n    this.dirent = undefined\n    this._childDirectoryEntries.unset()\n    this.stat.unset()\n    this.statSync.unset()\n    this.shaResult.unset()\n    return this\n  }\n\n  clearThisAndParent(): this {\n    emitFileChanged(this.dir)\n    return this\n  }\n\n  toString() {\n    return this.nativePath\n  }\n\n  valueOf() {\n    return this.pathnames\n  }\n\n  eql(that: Maybe<string | BaseFile>): boolean {\n    return that == null\n      ? false\n      : that instanceof BaseFile\n      ? this.nativePath === that.nativePath\n      : this.nativePath === BaseFile.for(that).nativePath\n  }\n\n  get isUNC() {\n    return isUNC(this.nativePath)\n  }\n\n  /**\n   * posix path from parent\n   */\n  get baseWithParent(): string {\n    return (this.isRoot\n      ? \"/\"\n      : this.parent().isRoot\n      ? \"/\" + this.base\n      : (this.parent().parent().isRoot ? \"/\" : \"\") + // <  prefixes the path with a / if grandparent is root.\n        this.parent().base +\n        \"/\" +\n        this.base\n    ).normalize()\n  }\n\n  /**\n   * posix path from grandparent\n   */\n  get baseWithGrandparent(): string {\n    return (this.isRoot\n      ? \"/\"\n      : this.parent().isRoot\n      ? this.baseWithParent\n      : this.parent().baseWithParent + \"/\" + this.base\n    ).normalize()\n  }\n\n  posixPathFrom(from: BaseFile): string {\n    return posixPathFrom(from, this)\n  }\n\n  async directoryEntry(): PromiseMaybe<DirectoryEntry> {\n    if (this.dirent == null) {\n      this.dirent = await thenMap(\n        this.stat(),\n        ea => new DirectoryEntry(this.dir, new StatDirent(this.base, ea))\n      )\n    }\n    return this.dirent\n  }\n\n  private readonly _childDirectoryEntries = lazy(() =>\n    thenMap(this.directoryEntry(), de => de.children())\n  )\n\n  async childDirectoryEntries(f?: Predicate<DirectoryEntry>) {\n    const dirents = await this._childDirectoryEntries()\n    return dirents == null || f == null || isEmpty(dirents)\n      ? dirents\n      : await filterAsync(dirents, f)\n  }\n\n  _directoryEntryChild(de: DirectoryEntry) {\n    return this.for(join(this.nativePath, de.base), de)\n  }\n\n  /**\n   * @return the basename of the children of `this`, locale sorted.\n   */\n  childNames() {\n    return thenMap(this.childDirectoryEntries(), arr => arr.map(ea => ea.base))\n  }\n\n  async children(predicate?: Predicate<DirectoryEntry>): PromiseMaybe<this[]> {\n    return (await this.childDirectoryEntries(predicate))?.map(ea =>\n      this._directoryEntryChild(ea)\n    )\n  }\n\n  async childFiles(f?: Predicate<this>): PromiseMaybe<this[]> {\n    // PERF: unrolled from thenMap\n    const result: this[] = []\n    for (const de of toA(await this.childDirectoryEntries())) {\n      if (de.isFile()) {\n        const ea = this._directoryEntryChild(de)\n        if (f == null || (await f(ea))) {\n          result.push(ea)\n        }\n      }\n    }\n    return result\n  }\n\n  async childDirectories(predicate?: Predicate<this>): PromiseMaybe<this[]> {\n    return thenMap(this.childDirectoryEntries(), arr =>\n      thenCompact(\n        arr\n          .filter(ea => ea.isDirectory())\n          .map(async ea => apply(this._directoryEntryChild(ea), predicate))\n      )\n    )\n  }\n\n  /**\n   * ONLY FOR TESTS\n   */\n  childrenSync(): this[] {\n    return orElse(\n      this.trapSync(\"childrenSync\", () =>\n        fs.readdirSync(this.nativePath).map(ea => this.join(ea))\n      ),\n      []\n    )\n  }\n\n  async hasChildren(childNames?: string[]) {\n    const actualChildNames = await this.childNames()\n    return isNotEmpty(childNames)\n      ? includesAll(actualChildNames, childNames)\n      : isNotEmpty(actualChildNames)\n  }\n\n  async hasNoChildren() {\n    return (await this.isFile()) || isEmpty(await this.childNames())\n  }\n\n  /**\n   * Depth-first recursion, includes child directories.\n   */\n  async visitDescendants(\n    f: (descendant: this) => any | Promise<any>\n  ): Promise<void> {\n    return thenMap(this.children(), async children => {\n      for (const child of children) {\n        await child.visitDescendants(f)\n        await f(child)\n      }\n    })\n  }\n\n  /**\n   * Breadth-first recursion\n   *\n   * @return all files (no directories) that pass the given predicate.\n   */\n  async descendants(predicate: Predicate<this>): PromiseMaybe<this[]> {\n    const result: this[] = []\n    for (const ea of toA(await this.childFiles())) {\n      if (await predicate(ea)) result.push(ea)\n    }\n\n    const dirs = await this.childDirectories()\n    if (dirs == null) return\n    await withBoundedConcurrency({\n      name: \"descendants\",\n      laters: dirs.map(dir => () =>\n        thenMap(dir.descendants(predicate), ea => result.push(...ea))\n      )\n    })\n    return result\n  }\n\n  async ancestorWithChildren(childNames: string[]): PromiseMaybe<this> {\n    if (await this.hasChildren(childNames)) {\n      return this\n    } else if (this.isRoot) {\n      return undefined\n    } else {\n      return this.parent().ancestorWithChildren(childNames)\n    }\n  }\n\n  async siblings(f?: Predicate<DirectoryEntry>): PromiseMaybe<this[]> {\n    const p = this.parent()\n    return (await this.siblingDirectoryEntries(f))?.map(ea =>\n      p._directoryEntryChild(ea)\n    )\n  }\n\n  async siblingDirectoryEntries(\n    f?: Predicate<DirectoryEntry>\n  ): PromiseMaybe<DirectoryEntry[]> {\n    return this.parent().childDirectoryEntries(\n      async ea => ea.base !== this.base && (f == null || (await f(ea)))\n    )\n  }\n\n  async selfAndSiblings() {\n    return this.parent().children()\n  }\n\n  async firstExistingSelfOrAncestor(): Promise<this> {\n    return this.isRoot || (await this.exists())\n      ? this\n      : this.parent().firstExistingSelfOrAncestor()\n  }\n\n  /**\n   * @return [\"C:\", \"Users\", \"Bob\", \"image.jpg\"] on win, [\"home\", \"bob\",\n   * \"image.jpg\"] on !win\n   */\n  get pathnames(): string[] {\n    return this.nativePath.split(sep).filter(ea => ea != null && ea !== \"\")\n  }\n\n  get pathnamesWithoutDrive(): string[] {\n    return isWin ? this.pathnames.slice(1) : this.pathnames\n  }\n\n  /**\n   * @return 0 for \"/\" or \"C:\\\", 1 for \"C:\\Users\" or \"/etc\", ...\n   */\n  get depth(): number {\n    return this.pathnames.length - (isWin ? 1 : 0)\n  }\n\n  get isRoot(): boolean {\n    return this.pathnames.length === (isWin ? 1 : 0)\n  }\n\n  /**\n   * @param depth The number of directories from root to include. For example,\n   * \"C:\\\" or \"/\" for 0, \"C:\\Users\" or \"/home\" for depth 1\n   */\n  root(depth: number = 0): this {\n    // \"/\".root(1) should return \"/\"\n    return this.depth <= depth ? this : this.parent().root(depth)\n  }\n\n  parent(): this {\n    // MEMLEAK: don't cache this: this.for will do that for us.\n    return this.isRoot ? this : (this.for(this.dir) as this)\n  }\n\n  isAncestorOf(maybeDescendant: Maybe<BaseFile>): boolean {\n    return (\n      maybeDescendant != null &&\n      (this.nativePath === maybeDescendant.nativePath ||\n        // Don't use nativePath + path: that doesn't handle roots correctly.\n        startsWith(maybeDescendant.pathnames, this.pathnames))\n    )\n  }\n\n  isDescendantOf(maybeAncestor: Maybe<BaseFile>): boolean {\n    return maybeAncestor != null && maybeAncestor.isAncestorOf(this)\n  }\n\n  parentsAndSelf(): this[] {\n    return [...this.parents(), this]\n  }\n\n  selfAndParents(depth: number): this[] {\n    return [\n      this,\n      ...(this.isRoot || depth <= 0\n        ? []\n        : this.parent().selfAndParents(depth - 1))\n    ]\n  }\n\n  /**\n   * Root-first order of paths (so [/, /var, /var/tmp, ...]\n   */\n  parents(): this[] {\n    const p = this.parent()\n    // NOTE: ALWAYS RETURN A NEW ARRAY, because consumers may .reverse or do\n    // other nasty things to it.\n    return this.isRoot ? [] : [...p.parents(), p]\n  }\n\n  /**\n   * Paths from URIs can have differently-encoded unicode paths (which switching\n   * from macOS to linux or Windows, for example.)\n   *\n   * If `this` exists, return it.\n   *\n   * If it doesn't, walk from the root of the path and try to find elements that,\n   * when unicode-normalized, match the current filesystem.\n   *\n   * As a last-ditch effort, try a case-insensitive match.\n   *\n   * If none of these work, `undefined` will be returned.\n   */\n  async normalize(): PromiseMaybe<this> {\n    // Don't need to handle UNC paths (they are always windows-only):\n    if (this.isUNC) return this\n\n    if ((await this.exists()) || this.isRoot) return this\n\n    return thenMap(this.parent().normalize(), async p => {\n      // We don't fetch .children(), as we don't want to instantiate all those\n      // BaseFiles unnecessarily.\n      const siblingNames = await p.childNames()\n\n      if (isNotEmpty(siblingNames)) {\n        for (const ea of siblingNames) {\n          if (ea === this.base) return p.join(ea)\n        }\n\n        const normalizedBase = this.base.normalize()\n        for (const ea of siblingNames) {\n          if (ea.normalize() === normalizedBase) return p.join(ea)\n        }\n\n        if (isMac || isWin) {\n          for (const ea of siblingNames) {\n            if (equalsIgnoreCase(ea, this.base)) return p.join(ea)\n          }\n        }\n      }\n\n      return\n    })\n  }\n\n  sibling(base: string): this {\n    return this.parent().join(base)\n  }\n\n  withPrefix(prefix: string): this {\n    return this.sibling(prefix + this.base)\n  }\n\n  withNameSuffix(suffix: string): this {\n    return this.sibling(this.name + suffix + this.ext)\n  }\n\n  siblingOf(possibleSibling: BaseFile): boolean {\n    return (\n      this.nativePath !== possibleSibling.nativePath &&\n      this.dir === possibleSibling.dir\n    )\n  }\n\n  /**\n   * Allows ../... directory traversals.\n   */\n  join(...paths: string[]): this {\n    if (isEmpty(paths) || eql([\".\"], paths)) return this\n    return isAbsolute(paths[0])\n      ? this.for(join(...paths))\n      : this.for(join(this.nativePath, ...paths))\n  }\n\n  joinYMD(d = new Date()): Maybe<this> {\n    return map3(\n      d?.getFullYear(),\n      d?.getMonth(),\n      d?.getDate(),\n      (year, month, day) => this.join(toS(year), pad2(month + 1), pad2(day))\n    )\n  }\n\n  /**\n   * Prevents `..` directory traversals\n   * @param paths\n   */\n  child(...paths: string[]): this {\n    if (isEmpty(paths)) return this\n    const pathElements = flatten(paths.map(ea => ea.split(sep))).filter(\n      ea => ea !== \"..\"\n    )\n    // Convert to posix to prevent \"\\\\\" and \"/\" from confusing the split:\n    return this.join(...pathElements)\n  }\n\n  //  _  _    _\n  // (_)| |_ ( )___    __ _\n  // | || __||// __|  / _` |\n  // | || |_   \\__ \\ | (_| | _  _  _\n  // |_| \\__|  |___/  \\__,_|(_)(_)(_)\n  protected async trap<T>(\n    methodName: string,\n    p: () => PromiseMaybe<T>,\n    errLogLevel: LogLevel = \"warn\"\n  ): PromiseMaybe<T> {\n    try {\n      return await time(\"fs.\" + methodName, p)\n      // this.bflog().trace(\n      //   `trap ${methodName}()`,\n      //   Buffer.isBuffer(result) ? \"<Buffer>\" : result\n      //   // Used for https://gitlab.com/photostructure/photostructure/issues/87:\n      //   // , { callstack: stack().slice(0, 10) }\n      // )\n      // return result\n    } catch (err) {\n      this.bflog().log(errLogLevel, `trap: ${methodName}() failed: ${err}`)\n      return undefined\n    }\n  }\n\n  // Return true if p() doesn't raise an error, else return false.\n  protected async trapOr(\n    methodName: string,\n    p: () => Promise<any>,\n    errLogLevel: LogLevel = \"warn\"\n  ): Promise<boolean> {\n    try {\n      this.bflog().trace(`trapOr ${methodName}()`)\n      await p()\n      return true\n    } catch (err) {\n      this.bflog().log(errLogLevel, `trapOr: ${methodName}() failed: ${err}`)\n      return false\n    }\n  }\n\n  protected trapSync<T>(methodName: string, p: () => T): Maybe<T> {\n    try {\n      this.bflog().trace(`trapSync ${methodName}()`)\n      return p()\n    } catch (err) {\n      this.bflog().warn(`trapSync: ${methodName}() failed: ${err}`)\n      return undefined\n    }\n  }\n\n  readonly stat = lazy<PromiseMaybe<fs.Stats>>(\n    // Don't log these errors:\n    () =>\n      this.trap(\"stat\", () => fse.stat(this.nativePath).catch(() => undefined)),\n    BaseFile.attrTTL\n  )\n\n  readonly statSync = lazy<Maybe<fs.Stats>>(\n    // Don't log these errors:\n    () =>\n      this.trapSync(\"statSync\", () => Try(() => fs.statSync(this.nativePath))),\n    BaseFile.attrTTL\n  )\n\n  async exists(): Promise<boolean> {\n    return this.dirent != null || (await thenDefined(this.stat()))\n  }\n\n  existsSync(): boolean {\n    return this.dirent != null || this.statSync() != null\n  }\n\n  async notExists(): Promise<boolean> {\n    return thenNot(this.exists())\n  }\n\n  mtime(): PromiseMaybe<Date> {\n    return thenMap(this.stat(), s => s.mtime)\n  }\n\n  mtimeMs(): PromiseMaybe<number> {\n    return thenMap(this.stat(), s => Math.floor(s.mtimeMs))\n  }\n\n  mtimeSec(): PromiseMaybe<number> {\n    return thenMap(this.stat(), s => unixtime(s.mtime))\n  }\n\n  async lastModifiedUtc(): PromiseMaybe<string> {\n    return thenMap(this.stat(), s => s.mtime.toUTCString())\n  }\n\n  // The mtime, rather than the birthtime, will actually be the capture\n  // time if the file is \"copied and pasted\" via the Windows explorer\n  // (rather than using `rsync --times` or `cp --preserve=all`).\n\n  // Birthtime isn't supported by default in linux, and seems to just return\n  // the ctime.\n\n  statTimes(): PromiseMaybe<number[]> {\n    return thenMap(this.stat(), s =>\n      // birthtimeMs will be 0 on OSes that don't support it.\n      // remember that ctime is directory-change-time, not create-time!\n      uniq(\n        [s.birthtimeMs, s.mtimeMs, s.ctimeMs].filter(\n          ea => ea != null && ea !== 0\n        )\n      )\n    )\n  }\n\n  maxStatMs(): PromiseMaybe<number> {\n    return thenMap(this.statTimes(), max)\n  }\n\n  maxStatDate(): PromiseMaybe<Date> {\n    return thenMap(this.maxStatMs(), ea => new Date(ea))\n  }\n\n  minStatMs(): PromiseMaybe<number> {\n    return thenMap(this.statTimes(), min)\n  }\n\n  minStatDate(): PromiseMaybe<Date> {\n    return thenMap(this.minStatMs(), ea => new Date(ea))\n  }\n\n  size(): PromiseMaybe<number> {\n    return thenMap(this.stat(), s => s.size)\n  }\n\n  async access(mode: number): Promise<boolean> {\n    try {\n      await fse.access(this.nativePath, mode)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * @return Promise<true> if the file is executable (not relevant on windows)\n   */\n  isExecutable() {\n    return this.access(fs.constants.R_OK | (isWin ? 0 : fs.constants.X_OK))\n  }\n\n  isReadable(): Promise<boolean> {\n    return this.access(fs.constants.R_OK)\n  }\n\n  isNotReadable(): Promise<boolean> {\n    return thenNot(this.isReadable())\n  }\n\n  isReadWritable(): Promise<boolean> {\n    return this.access(fs.constants.R_OK | fs.constants.W_OK)\n  }\n\n  isNotReadWritable(): Promise<boolean> {\n    return thenNot(this.isReadWritable())\n  }\n\n  isHiddenPosix(): boolean {\n    return this.base.startsWith(\".\")\n  }\n\n  async isEmpty(bytesConsideredEmpty = 0): Promise<boolean> {\n    if (await this.isDirectory()) {\n      return isNotEmpty(await this.childNames())\n    } else {\n      const s = await this.size()\n      return s == null || s <= bytesConsideredEmpty\n    }\n  }\n\n  isNonEmpty(minSizeBytes = 1): Promise<boolean> {\n    return thenNot(this.isEmpty(minSizeBytes))\n  }\n\n  async isNonEmptyFile(minSizeBytes = 1): Promise<boolean> {\n    return (await this.isFile()) && (await this.isNonEmpty(minSizeBytes))\n  }\n\n  async modifiedGTE(mtime: Date): PromiseMaybe<boolean> {\n    return thenMap(\n      this.mtime(),\n      thisMtime =>\n        // Filesystems have only second-level resolution\n        unixtime(thisMtime) >= unixtime(mtime)\n    )\n  }\n\n  async modifiedCloseTo(\n    mtimeMs: number,\n    deltaMs: number\n  ): PromiseMaybe<boolean> {\n    return thenMap(\n      this.mtimeMs(),\n      thisMtimeMs => Math.abs(thisMtimeMs - mtimeMs) <= deltaMs\n    )\n  }\n\n  async isRecent(agoMs: number): Promise<boolean> {\n    const mtime = await this.maxStatMs()\n    return mtime != null && mtime > Date.now() - agoMs\n  }\n\n  async modifiedGT(mtime: Maybe<Date>): PromiseMaybe<boolean> {\n    if (mtime == null) return\n    return thenMap(\n      this.mtime(),\n      thisMtime =>\n        // Filesystems have only second-level resolution\n        unixtime(thisMtime) > unixtime(mtime)\n    )\n  }\n\n  async isDirectory(): Promise<boolean> {\n    if (this.dirent != null) return this.dirent.isDirectory()\n    return thenMapOr(\n      this.stat(),\n      ea => ea.isDirectory(),\n      () => false\n    )\n  }\n\n  async isNotDirectory(): Promise<boolean> {\n    return thenNot(this.isDirectory())\n  }\n\n  isDirectorySync(): boolean {\n    if (this.dirent != null) return this.dirent.isDirectory()\n    return mapOr(\n      this.statSync(),\n      ea => ea.isDirectory(),\n      () => false\n    )\n  }\n\n  async nearestDir(): Promise<this> {\n    return (await this.isDirectory()) ? this : this.parent()\n  }\n\n  async isFile(): Promise<boolean> {\n    if (this.dirent != null) return this.dirent.isFile()\n    return this.stat().then(stat =>\n      opt(stat)\n        .map(ea => ea.isFile())\n        .getOrElse(() => false)\n    )\n  }\n\n  isFileSync(): boolean {\n    if (this.dirent != null) return this.dirent.isFile()\n    return opt(this.statSync()).filter(ea => ea.isFile()).isDefined\n  }\n\n  rmdir(errLogLevel: LogLevel = \"warn\"): Promise<boolean> {\n    this.clear()\n    return this.trapOr(\"rmdir\", () => fse.rmdir(this.nativePath), errLogLevel)\n  }\n\n  /**\n   * @throws on error\n   */\n  async mkdirp_(): Promise<this> {\n    // Try simple call first:\n    try {\n      await fse.mkdirp(this.nativePath)\n    } catch (err) {\n      // race condition:\n      if (err.code !== \"EEXIST\") throw err\n    }\n    // // SITS: workaround for linux fs-extra's failure to copy files to NTFS\n    // // partitions due to lag. Hypothetically we should be able to just\n    // // mkdirp() and be done, but that doesn't work.\n    // if (null == (await this.parent().mkdirp())) {\n    //   throw new Error(\"Failed to mkdirp parent of \" + this)\n    // }\n    // await fse.mkdirp(this.nativePath)\n    if (\n      // kernel FS lag can't be longer than a second or two\n      false ===\n      (await untilTrue(() => this.clear().isDirectory(), {\n        timeoutMs: 2 * secondMs,\n        timeBetweenMs: 200\n      }))\n    ) {\n      throw new Error(\"Failed to mkdirp \" + this)\n    } else {\n      // this and parent because parent caches children.\n      return this.clearThisAndParent()\n    }\n  }\n\n  async mkdirp(): PromiseMaybe<this> {\n    if ((await this.clear().isDirectory()) || this.isRoot) return this\n    return this.trap(\"mkdirp\", async () => this.mkdirp_())\n  }\n\n  /**\n   * @throws on error\n   */\n  mkdirpSync_(): this {\n    fse.mkdirpSync(this.nativePath)\n    return this.clearThisAndParent()\n  }\n\n  mkdirpSync(): Maybe<this> {\n    if (this.isRoot) return this\n    return this.trapSync(\"mkdirpSync\", () => this.mkdirpSync_())\n  }\n\n  readonly shaResult = lazy(async () => {\n    const size = await this.size()\n    if (size === 0 || size == null) {\n      return undefined\n    }\n    const observer =\n      size > 5 * MiB\n        ? new PushProgressObserver(\n            { op: \"Computing SHA of\", path: this.nativePath },\n            size\n          )\n        : undefined\n    const result = await elapsedAsync(() =>\n      this.trap(\"sha\", () => fileSha([this.nativePath], { observer }))\n    )\n    const b64 = map(result.result, ea => ea.toString(\"base64\"))\n    return {\n      elapsedMs: result.elapsedMs,\n      buffer: result.result,\n      b64\n    }\n  }, BaseFile.attrTTL)\n\n  /**\n   * base64 encoded SHA-512/192 (ish)\n   */\n  sha(): PromiseMaybe<string> {\n    return thenMap(this.shaResult(), r => r.b64)\n  }\n\n  /**\n   * @return ms to gather the sha for this file\n   */\n  shaMs(): PromiseMaybe<number> {\n    return thenMap(this.shaResult(), r => r.elapsedMs)\n  }\n\n  /**\n   * @throws so when readables encounter errors in the midst of reading, they\n   * can propagate the error to the caller\n   */\n  async writeStream_(\n    readable: Readable,\n    options?: WriteOptions & { onProgress?: (bytes: number) => any }\n  ): PromiseMaybe<this> {\n    await pipelineAsync(\n      compact([\n        readable,\n        map(options?.onProgress, f => new ByteCounter(f)),\n        fse.createWriteStream(this.nativePath, options)\n      ])\n    )\n    return this.clearThisAndParent()\n  }\n\n  async writeJsonMaybe(\n    object: any,\n    options: WriteOptions & {\n      replacer?: (key: string, value: any) => any\n      spaces?: number\n    } = {}\n  ): PromiseMaybe<this> {\n    // outputJSON is almost the same as writeJson, except that if the directory\n    // does not exist, it's created\n    return this.trap(\"writeJsonMaybe\", () => this.writeJSON_(object, options))\n  }\n\n  /**\n   * @throws on error\n   */\n  async writeJSON_(\n    object: any,\n    options: WriteOptions & {\n      replacer?: (key: string, value: any) => any\n      spaces?: number\n    } = {}\n  ): PromiseMaybe<this> {\n    // outputJSON is almost the same as writeJson, except that if the directory\n    // does not exist, it's created\n    await this.parent().mkdirp()\n    // fs-extra's writeJSON seemed to delete the file first, so we're using\n    // writeFile with the overwrite mode flag:\n    await fse.writeFile(\n      this.nativePath,\n      stringify(object, options.replacer, options.spaces),\n      { flag: \"w\", ...options }\n    )\n    return this.clearThisAndParent()\n  }\n\n  readJson<T>(errLogLevel: LogLevel = \"warn\"): PromiseMaybe<T> {\n    return this.trap(\n      \"readJson\",\n      () =>\n        retryOnReject(\n          async () =>\n            (await this.isNonEmptyFile())\n              ? fse.readJson(this.nativePath)\n              : undefined,\n          {\n            maxRetries: 1,\n            onRetryWaitUntil: () => delay(errLogLevel === \"warn\" ? 250 : 25),\n            errorIsRetriable: err => err[\"errno\"] !== -2 // ENOENT\n          }\n        ),\n      errLogLevel\n    )\n  }\n\n  readJsonSync(): Maybe<any> {\n    return this.trapSync(\"readJsonSync\", () =>\n      fse.readJsonSync(this.nativePath)\n    )\n  }\n\n  readFileSync_() {\n    return fse.readFileSync(this.nativePath)\n  }\n\n  readFile_() {\n    return fse.readFile(this.nativePath)\n  }\n\n  readFile(errLogLevel: LogLevel = \"warn\"): PromiseMaybe<Buffer> {\n    return this.trap(\"readFile\", () => this.readFile_(), errLogLevel)\n  }\n\n  /**\n   * `readFile`, but on-the-fly decompression for .gz and .br\n   * @throws on error\n   */\n  async zReadFile_(options?: {\n    start?: number\n    end?: number\n  }): PromiseMaybe<Buffer> {\n    return zCopyToBuffer_(this.nativePath, options)\n  }\n\n  async zcat(options?: { start?: number; end?: number }): PromiseMaybe<string> {\n    return this.trap(\"zcat\", () => thenMap(this.zReadFile_(options), toS))\n  }\n\n  async zCopyFile(dest: this, options?: { start?: number; end?: number }) {\n    return this.trap(\"zCopyFile\", async () => {\n      await dest.parent().mkdirp()\n      await zCopyTo_(\n        this.nativePath,\n        fs.createWriteStream(dest.nativePath),\n        options\n      )\n      return dest\n    })\n  }\n\n  readLines(): PromiseMaybe<string[]> {\n    return thenMap(this.readFile(), buf => splitLines(buf.toString()))\n  }\n\n  readFileSync(): Maybe<string> {\n    return Try(() => map(fs.readFileSync(this.nativePath), toS))\n  }\n\n  /**\n   * @throws on error\n   */\n  writeTxt_(txt: string) {\n    return this.writeFile_(crlf(txt))\n  }\n\n  /**\n   * @throws on error\n   */\n  async writeFile_(data: string | Buffer) {\n    // Don't try to make the mountpoint (or, say, \"c:\")\n    await this.parent().mkdirp()\n    await fse.writeFile(this.nativePath, data)\n    return this.clearThisAndParent()\n  }\n\n  wip(wipPrefix = WipPrefix): this {\n    return this.sibling(wipPrefix + this.base)\n  }\n\n  /**\n   * @throws if there are errors\n   */\n  async unwip_(wipPrefix = WipPrefix): Promise<this> {\n    const dest = this.sibling(stripPrefix(this.base, wipPrefix))\n    return this.mv_(dest, { overwrite: true })\n  }\n\n  private async dest(destOrDestDir: this): Promise<this> {\n    const destOrDir = destOrDestDir.clear() // < bust cache\n    return (notBlank(this.ext) && blank(destOrDir.ext)) ||\n      (await destOrDir.isDirectory())\n      ? destOrDir.join(this.base)\n      : destOrDir\n  }\n\n  /**\n   * Atomically overwrite `destOrDestDir.join(paths)` with the contents of\n   * `this`. Use `.ensureNew` on destOrDestDir if you want to prevent\n   * overwriting.\n   *\n   * If the result of joining `destOrDestDir` and `paths` results in an\n   * extensionless name, the path will be assumed to be a containing directory,\n   * and this name will be appended to the result.\n   *\n   * @throws if there are any errors\n   */\n  copyFile_(destFileOrDir: this): Promise<this> {\n    return time(\"fs.copyFile\", async () => {\n      const dest = (await this.dest(destFileOrDir)).clear()\n      if (this.nativePath === dest.nativePath) {\n        return this\n      }\n      const mkdir = await dest.parent().mkdirp()\n      if (mkdir == null) return this.bflog().throw(\"Cannot mkdirp \" + dest.dir)\n\n      try {\n        return await this._copyFile(dest)\n      } catch (error) {\n        if (isNonRetriableError(error)) {\n          throw error\n        } else {\n          this.bflog().warn(\"_copyFile failed, trying _nativeCopyFile\", {\n            src: this.nativePath,\n            dest: dest.nativePath,\n            error\n          })\n          return await this._nativeCopyFile(dest)\n        }\n      } finally {\n        this.clearThisAndParent()\n      }\n    })\n  }\n\n  private async _copyFile(dest: this): Promise<this> {\n    let obs: Maybe<PullProgressObserver>\n    let wipDest: Maybe<this>\n    let result = dest\n    try {\n      const stat = await thenOrElse(this.stat(), () => this.clear().stat())\n      if (stat == null) {\n        return this.bflog().throw(\n          \"Can't copy missing files\" + NonRetriableErrorFlag\n        )\n      }\n      if (stat.size === 0) {\n        // empty file, skip copy\n        await dest.touch(stat.mtime, stat.atime)\n      } else {\n        if (Settings.verifyFileCopies.valueOrDefault) {\n          if ((await this.sha()) == null) {\n            return this.bflog().throw(\n              \"Can't copy file without SHA\" + NonRetriableErrorFlag\n            )\n          }\n        }\n        wipDest = dest.wip()\n        const p = fse.copyFile(this.nativePath, wipDest.nativePath)\n        if (stat.size > 5 * MiB) {\n          obs = new PullProgressObserver(\n            {\n              op: \"Copying\",\n              path: this.nativePath,\n              dest: dest.nativePath\n            } as any,\n            stat.size,\n            () => wipDest!.clear().size()\n          )\n        }\n        await p\n        const sizeMatches = await untilTrue(\n          async () => stat.size === (await wipDest!.clear().size()),\n          { timeoutMs: CmdTimeoutMs }\n        )\n        if (Settings.verifyFileCopies.valueOrDefault) {\n          const shaMatches =\n            sizeMatches &&\n            (await untilTrue(\n              () => eqlAsync(this.sha(), wipDest!.clear().sha()),\n              { timeoutMs: CmdTimeoutMs }\n            ))\n          if (!shaMatches) {\n            return this.bflog().throw(\"copyFile_() failed\", {\n              sizeMatches,\n              shaMatches\n            })\n          }\n        }\n        if (!sizeMatches) {\n          return this.bflog().throw(\"copyFile_() failed\", {\n            expectedSize: stat.size,\n            actualSize: await wipDest.clear().size()\n          })\n        }\n        result = await wipDest.unwip_()\n        if (result == null) {\n          return this.bflog().throw(\n            \"copyFile_(\" + dest + \") failed: .unwip() was null\"\n          )\n        }\n        await fse.utimes(result.nativePath, stat.atime, stat.mtime)\n      }\n      try {\n        await fse.chmod(result.nativePath, stat.mode)\n      } catch (err) {\n        this.bflog().debug(\n          `copyFile_(${result.nativePath}) warning: couldn't chmod to ${stat.mode}: ${err}`\n        )\n      }\n      this.bflog().debug(`copyFile_(${dest.nativePath}): success`)\n      emitFileCopied(this.nativePath, dest.nativePath)\n      return dest\n    } catch (err) {\n      this.bflog().warn(`copyFile_(${wipDest?.nativePath}) failed: ${err}`)\n      await wipDest?.unlink()\n      await dest.unlink()\n      throw err\n    } finally {\n      map(obs, ea => ea.end())\n    }\n  }\n\n  async copyTimeoutMs(): Promise<number> {\n    return thenMapOr(\n      this.size(),\n      bytes => Math.max(CmdTimeoutMs, bytes * MinIoRate),\n      () => CmdTimeoutMs\n    )\n  }\n\n  private async _nativeCopyFile(dest: this): Promise<this> {\n    let obs: Maybe<PullProgressObserver>\n    try {\n      if (null == (await dest.parent().mkdirp())) {\n        return this.bflog().throw(\"Can't mkdir destination directory\", {\n          src: this.nativePath,\n          dest: dest.nativePath\n        })\n      }\n      const stat = await this.stat()\n      const size = map(stat, ea => ea.size)\n      if (stat == null || size == null) {\n        return this.bflog().throw(\"Can't copy missing files\")\n      }\n      if (size > 5 * MiB) {\n        obs = new PullProgressObserver(\n          {\n            op: \"Copying\",\n            path: this.nativePath,\n            dest: dest.nativePath\n          } as any,\n          size,\n          () => dest.clear().size()\n        )\n      }\n\n      if (isWin) {\n        await PowerShell.instance().execute(\n          `Copy-Item -LiteralPath ${pwshQuote(\n            this.nativePath\n          )} -Destination ${pwshQuote(dest.nativePath)}`,\n          ea => ea\n        )\n      } else {\n        // -a means archive, or -pPR on macOS or -dR --preserve=all on debian\n        // -f means force. If existing dest cannot be opened, remove it and try again.\n        await stdout(\"cp\", [\"-a\", \"-f\", this.nativePath, dest.nativePath], {\n          timeout: await this.copyTimeoutMs()\n        })\n      }\n\n      emitFileCopied(this.nativePath, dest.nativePath)\n      return dest.clearThisAndParent()\n    } catch (err) {\n      return this.bflog().throw(\"_nativeCopyFile(\" + dest + \"): \" + err)\n    } finally {\n      map(obs, ea => ea.end())\n    }\n  }\n\n  async touch(\n    mtime: Date | number = Date.now(),\n    atime?: Date | number\n  ): PromiseMaybe<this> {\n    return this.trap(\"touch\", () =>\n      thenMap(this.ensureFile(), () => this.utimes(mtime, atime))\n    )\n  }\n\n  async utimes(\n    mtime?: Date | number,\n    atime?: Date | number\n  ): PromiseMaybe<this> {\n    const _mtime = orElse(mtime, Date.now())\n    const _atime = orElse(atime, _mtime)\n    return this.trap(\"utimes\", () =>\n      fse\n        .utimes(this.nativePath, unixtime(_atime), unixtime(_mtime))\n        .then(() => this.clearThisAndParent())\n    )\n  }\n\n  /**\n   * Deletes the current file.\n   * @return Promise<true> if unlink was successful\n   */\n  async unlink(errLogLevel: LogLevel = \"warn\") {\n    return this.trap(\n      \"unlink\",\n      async () => {\n        await fse.unlink(this.nativePath)\n        return this.clearThisAndParent()\n      },\n      errLogLevel\n    )\n  }\n\n  /**\n   * Delete files or directories. Should only be needed by tests or applied to\n   * cache dirs.\n   *\n   * Note that the promise may be returned before the file op is actually\n   * complete due to a (bug?) in fs-extra.\n   */\n  async rmrf(logLevel: LogLevel = \"info\"): PromiseMaybe<this> {\n    return this.trap(\"rmrf\", async () => {\n      this.bflog().log(logLevel, \"rmrf()\")\n      await fse.remove(this.nativePath)\n      return this.clearThisAndParent()\n    })\n  }\n\n  /**\n   * SITS: Mac sometimes locks files when they've been copied. No, I couldn't\n   * find out why, but if I own the file, I can chflags the file back to being\n   * unlocked.\n   *\n   * This should only be applied to newly-copied files, not files that I don't\n   * own (or have created).\n   */\n  async unlock(): Promise<this> {\n    if (isMac && (await this.clear().exists())) {\n      await stdout(\"chflags\", [\"nouchg\", this.nativePath], {\n        timeout: CmdTimeoutMs\n      })\n    }\n    return this\n  }\n\n  /**\n   * @throws on error\n   */\n  async renameWithNameSuffix_(nameSuffix: string): PromiseMaybe<this> {\n    return thenMap(\n      this.withNameSuffix(nameSuffix).ensureNew_({ emptyIsNew: true }),\n      dest => dest.unlink(\"debug\").then(() => this.mv_(dest))\n    )\n  }\n\n  /**\n   * @return the file that was copied into\n   * @throws error if there are issues\n   */\n  async mv_(\n    destFileOrDir: this,\n    opts: fse.MoveOptions = { overwrite: false }\n  ): Promise<this> {\n    const dest = await this.dest(destFileOrDir)\n    if (this.nativePath === dest.nativePath) {\n      this.bflog().warn(\"mv(): no-op\", new Error(\"internal error\"))\n      return this\n    }\n    await dest.parent().mkdirp()\n    this.bflog().debug(\"mv\", dest)\n    // https://github.com/jprichardson/node-fs-extra/blob/master/docs/move.md\n    // Moves a file or directory, even across devices:\n    try {\n      await fse.move(this.nativePath, dest.nativePath, opts)\n    } catch (err) {\n      this.bflog().warn(\n        \"mv() try #1 failed. Calling unlock() and waiting for source to be non-empty.\",\n        err\n      )\n      await Promise.all([this.unlock(), dest.unlock()])\n      await untilTrue(() => this.clear().isNonEmptyFile(), {\n        timeoutMs: 7 * secondMs\n      })\n      await fse.move(this.nativePath, dest.nativePath, opts)\n    }\n    await dest.unlock()\n    this.clearThisAndParent()\n    return dest.clearThisAndParent()\n  }\n\n  /**\n   * Supports gzip/gunzip/brotli/whatever transform you've got:\n   */\n  private async pipeTo(base: string, transform: Transform) {\n    return this.trap(\"pipeTo(\" + base + \")\", async () => {\n      const dest = await this.sibling(base).ensureNew_()\n      await pipelineAsync([\n        fs.createReadStream(this.nativePath),\n        transform,\n        fs.createWriteStream(dest.nativePath)\n      ])\n      await this.unlink()\n      return dest\n    })\n  }\n\n  async gunzip(): PromiseMaybe<this> {\n    return this.pipeTo(stripSuffix(this.base, \".gz\"), createGunzip())\n  }\n\n  async gzip(): PromiseMaybe<this> {\n    return this.pipeTo(this.base + \".gz\", createGzip())\n  }\n\n  async compressBrotli(): PromiseMaybe<this> {\n    return this.pipeTo(this.base + \".br\", createBrotliCompress())\n  }\n\n  ensureFile(): PromiseMaybe<this> {\n    return this.trap(\"ensureFile\", () =>\n      fse.ensureFile(this.nativePath).then(() => this.clearThisAndParent())\n    )\n  }\n\n  /**\n   * @throws on error\n   */\n  ensureFileSync_() {\n    fse.ensureFileSync(this.nativePath)\n    return this.clearThisAndParent()\n  }\n\n  /**\n   * @return \"P12345\" from \"/var/tmp/P12345-01.JPG\"\n   */\n  get nameWithoutCount(): string {\n    return nameWithoutCount(this.name)\n  }\n\n  /**\n   * @return \"P12345.JPG\" from \"/var/tmp/P12345-01.JPG\"\n   */\n  get baseWithoutCount(): string {\n    return this.nameWithoutCount + this.ext\n  }\n\n  get baseWithoutCountWithParent(): string {\n    return this.parent().base + \"/\" + this.baseWithoutCount\n  }\n\n  get siblingWithoutCount(): this {\n    return this.sibling(this.baseWithoutCount)\n  }\n\n  /**\n   * Returns a basename in this directory with this same .ext and prefixed with\n   * this.name which either doesn't exist or is zero length.\n   *\n   * If `options.emptyIsNew` is `true`, the file may exist, but must be\n   * zero-length. If `options.emptyIsNew` is `false`, the returned path will be\n   * nonexistent.\n   */\n  async ensureNewNativePath(\n    options: Omit<EnsureNewOptions, \"nativePath\">\n  ): Promise<string> {\n    return ensureNewNativePath_({ nativePath: this.nativePath, ...options })\n  }\n\n  /**\n   * @throws if errors\n   */\n  ensureNew_(opts: Partial<EnsureNewOptions> = {}): Promise<this> {\n    return this.ensureNewNativePath(opts).then(p => this.for(p))\n  }\n\n  /**\n   * @throws if errors\n   */\n  async renameYMDHMS_(subdir?: string): Promise<this> {\n    if (await this.clear().notExists()) {\n      throw new Error(\"Cannot rename: \" + this + \" doesn't exist.\")\n    }\n    const ts = fmtYMDHMS(await thenOrElse(this.mtime(), () => new Date()))\n    const destDir = mapOr(\n      subdir,\n      ea => this.parent().join(ea),\n      () => this.parent()\n    )\n    return this.mv_(destDir.join(this.name + \"-\" + ts + this.ext), {\n      overwrite: true\n    })\n  }\n\n  /**\n   * If `this` exists and has new contents for this current directory, rename it\n   * to a new file with the given base (and possibly a count, to ensure new\n   * overwriting).\n   *\n   * If `this` is empty, or already has the same contents as another file in\n   * this directory, return that file and unlink this file.\n   */\n  async saveIfNewOrDelete(base: string): PromiseMaybe<this> {\n    if (await this.clear().isEmpty()) {\n      // don't complain about removing a missing file:\n      await this.unlink(\"trace\")\n      return\n    }\n    const prior = await this.siblingWithSameContents()\n    if (prior != null) {\n      await this.unlink()\n      return prior\n    }\n    const dest = await this.sibling(base).ensureNew_()\n    return this.mv_(dest)\n  }\n\n  /**\n   * Make sure you encode `mode` in octal! 0o644\n   */\n  async chmod(mode: string | number): Promise<this> {\n    await fse.chmod(this.nativePath, mode)\n    return this.clear()\n  }\n\n  zreadline(): LineReader {\n    return fs\n      .createReadStream(this.nativePath)\n      .on(\"error\", (err: any) => {\n        throw new Error(\"Failed to read from \" + this + \": \" + err)\n      })\n      .pipe(createGunzip())\n      .on(\"error\", (err: any) => {\n        throw new Error(\"Failed to gunzip \" + this + \": \" + err)\n      })\n      .pipe(new LineReader())\n  }\n\n  // /**\n  //  * Just like `zcat`, this decompresses iff the file suffix is .gz, or returns\n  //  * the plain file contents if the file suffix is anything else.\n  //  */\n  // zcat(): PromiseMaybe<Buffer> {\n  //   if (!this.ext.endsWith(\".gz\")) {\n  //     return thenMap(this.readFile(), buf => buf.toString())\n  //   }\n  //   return this.trap(\"zcat\", async () => {\n  //     const wb = new WritableToBuffer()\n  //     await new Promise((res, rej) =>\n  //       pipeline(\n  //         fse.createReadStream(this.nativePath),\n  //         createGunzip(),\n  //         wb,\n  //         err => (err == null ? res() : rej(err))\n  //       )\n  //     )\n  //     return wb.buffer\n  //   })\n  // }\n\n  async siblingWithSameContents(): PromiseMaybe<this> {\n    return this.parent().childWithSameContents(this)\n  }\n\n  async childWithSameContents(target: this): PromiseMaybe<this> {\n    return time(\"fs.childWithSameContents\", async () => {\n      if ((await this.notExists()) || !(await this.isDirectory())) {\n        return\n      }\n      const targetSize = await target.size()\n      const children = await this.children()\n      const sameSize: this[] = []\n      for (const child of toA(children)) {\n        if ((await child.size()) === targetSize && !target.eql(child)) {\n          sameSize.push(child)\n        }\n      }\n      // Don't need to sha target if none are the same size:\n      if (isEmpty(sameSize)) {\n        return\n      }\n      const targetSha = await target.sha()\n      // Assume similar names are more likely to be the same. Try those first.\n      for (const child of sameSize\n        .sort((a, b) => diceCoeff(a.base, b.base))\n        .reverse()) {\n        if ((await child.sha()) === targetSha) {\n          return child\n        }\n      }\n      return\n    })\n  }\n\n  async applyWip<T>(\n    f: (destination: this) => Promise<T>,\n    minSizeBytes = 0,\n    ttlMs = 15 * secondMs\n  ): PromiseMaybe<T> {\n    const wip = this.wip()\n    try {\n      await wip.parent().mkdirp()\n\n      // If the wip file exists and is recent, try waiting for a bit to see if someone else built it:\n      if (\n        (await wip.clear().isRecent(ttlMs)) ||\n        (await this.clear().isRecent(ttlMs))\n      ) {\n        this.bflog().info(\n          \"applyWip(): recent WIP exists. Waiting for a bit to see if someone else will do my work.\"\n        )\n        if (\n          await untilTrue(() => this.clear().isNonEmpty(minSizeBytes), {\n            timeoutMs: ttlMs * 2,\n            timeBetweenMs: 500\n          })\n        ) {\n          this.bflog().info(\"applyWip(): yay, someone else did my work.\")\n          return\n        }\n      }\n      // Try to prevent race conditions:\n      await this.touch()\n      // note can't touch WIP file because of EXIFTOOL no clobber policy\n      await wip.unlink(\"trace\")\n      const result = await f(wip)\n      const isNonEmpty = await untilTrue(() => wip.clear().isNonEmptyFile(), {\n        timeoutMs: secondMs\n      })\n      if (isNonEmpty) {\n        await wip.unwip_() // throws errors if issues\n        return result\n      } else {\n        throw new Error(\"applyWip(): empty after apply for \" + this)\n      }\n    } catch (err) {\n      await wip.unlink()\n      await this.unlink()\n      throw err\n    }\n  }\n\n  /**\n   * @throws !!!\n   */\n  async applyIfEmpty_(\n    f: (destination: this) => Promise<any>,\n    minSizeBytes = 0\n  ): PromiseMaybe<this> {\n    if (await this.clear().isNonEmpty(minSizeBytes)) {\n      this.bflog().debug(\"applyIfEmpty(): non-empty\")\n    } else {\n      this.bflog().debug(\"applyIfEmpty(): empty, applying...\")\n      // throws if there is a problem:\n      await this.applyWip(f, minSizeBytes)\n    }\n    // Always touch (to prevent img cache from removing currently-used caches):\n    return this.touch()\n  }\n\n  firstMatchingLine(re: RegExp): PromiseMaybe<RegExpMatchArray> {\n    const d = new Deferred<Maybe<RegExpMatchArray>>(\n      \"firstMatchingLine(\" + this + \")\"\n    )\n    const r = fs.createReadStream(this.nativePath, { flags: \"r\" })\n    r.on(\"error\", (err: any) => {\n      if (err.errno === -2 || err.code === \"ENOENT\") {\n        d.maybeResolve(undefined)\n        r.close()\n      } else {\n        d.maybeReject(err)\n      }\n    })\n    r.on(\"close\", () => d.maybeResolve(undefined))\n    void onDataChunked(r, newlineRe, ea => {\n      const m = re.exec(ea)\n      if (m != null) {\n        d.maybeResolve(m)\n        r.close()\n      }\n    })\n    return d.promise\n  }\n\n  contemporary(b: BaseFile, maxDiffMs: number): Promise<boolean> {\n    return thenMap2Or(\n      this.statTimes(),\n      b.statTimes(),\n      (arr1, arr2) => {\n        for (const i of arr1) {\n          for (const j of arr2) {\n            if (closeTo(i, j, maxDiffMs)) {\n              return true\n            }\n          }\n        }\n        return false\n      },\n      () => false\n    )\n  }\n}\n\nexport function execDir(): BaseFile {\n  return BaseFile.for(process.execPath).parent()\n}\n", "import { compact } from \"../../fe/Array\"\nimport { mapOr } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { SyncOrAsync } from \"../../fe/OptAsync\"\nimport { filterAsync } from \"./Promise\"\n\nexport interface SyncPredicate<T> {\n  (t: T): boolean\n}\n\nexport interface Predicate<T> {\n  (t: T): SyncOrAsync<boolean>\n}\n\nexport const True: Predicate<any> = () => true\n\nexport function not<T>(p: SyncPredicate<T>): SyncPredicate<T> {\n  return (item: T) => {\n    return !p(item)\n  }\n}\n\nexport function and<T>(...arr: SyncPredicate<T>[]): SyncPredicate<T> {\n  return (item: T) => {\n    for (const ea of arr) {\n      if (!ea(item)) return false\n    }\n    return true\n  }\n}\n\nexport function or<T>(...arr: SyncPredicate<T>[]): SyncPredicate<T> {\n  return (item: T) => {\n    for (const ea of arr) {\n      if (ea(item)) return true\n    }\n    return false\n  }\n}\n\nexport function all<T>(arr: T[], p: SyncPredicate<T>): boolean {\n  for (const e of arr) {\n    if (!p(e)) return false\n  }\n  return true\n}\n\nexport function some<T>(arr: T[], p: SyncPredicate<T>): boolean {\n  for (const e of arr) {\n    if (p(e)) return true\n  }\n  return false\n}\n\nexport function none<T>(arr: T[], p: SyncPredicate<T>): boolean {\n  for (const e of arr) {\n    if (p(e)) return false\n  }\n  return true\n}\n\nexport function find<T>(arr: T[], p: SyncPredicate<T>): Maybe<T> {\n  for (const ea of arr) {\n    if (p(ea)) {\n      return ea\n    }\n  }\n  return\n}\n\nexport async function filter<T>(\n  arr: Maybe<Maybe<T>[]>,\n  p?: Predicate<T>\n): Promise<T[]> {\n  if (arr == null || p == null) return mapOr(arr, compact, () => [])\n  return filterAsync(arr, p)\n}\n\nexport async function apply<T>(\n  t: Maybe<T>,\n  p: Maybe<Predicate<T>>\n): PromiseMaybe<T> {\n  return t == null || p == null ? t : (await p(t)) ? t : undefined\n}\n", "import { map } from \"../fe/Maybe\"\nimport { SyncOrAsync } from \"../fe/OptAsync\"\nimport { Thunk } from \"../fe/Thunk\"\nimport { Logger } from \"./Logger\"\n\nexport class Elapsed {\n  private ts = Date.now()\n  constructor(\n    readonly l: Logger,\n    readonly listener?: (name: string, elapsedMs: number) => any\n  ) {}\n\n  elapsed(msg: string) {\n    const now = Date.now()\n    const diff = now - this.ts\n    this.ts = now\n    map(this.listener, ea => ea(msg, diff))\n    if (diff > 2) {\n      this.l.log(diff > 500 ? \"warn\" : diff > 100 ? \"info\" : \"debug\", msg, {\n        elapsedMs: diff\n      })\n    }\n  }\n}\n\nexport function elapsed<T>(t: Thunk<T>): { elapsedMs: number; result: T } {\n  const start = Date.now()\n  const result = t()\n  return { elapsedMs: Date.now() - start, result }\n}\n\nexport async function elapsedAsync<T>(\n  t: () => SyncOrAsync<T>\n): Promise<{ elapsedMs: number; result: T }> {\n  const start = Date.now()\n  const result = await t()\n  return { elapsedMs: Date.now() - start, result }\n}\n\nexport async function thenElapsed<T>(\n  p: Promise<T>\n): Promise<{ elapsedMs: number; result: T }> {\n  const start = Date.now()\n  const result = await p\n  return { elapsedMs: Date.now() - start, result }\n}\n", "import { mapNotEmpty, sortBy } from \"../../fe/Array\"\nimport { secondMs } from \"../../fe/Date\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { getOrSet } from \"../../fe/Map\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { mapFinite, round, sigFigs } from \"../../fe/Number\"\nimport { compactValues, fromEntries, omit, tap } from \"../../fe/Object\"\nimport { opt } from \"../../fe/Opt\"\nimport { SyncOrAsync } from \"../../fe/OptAsync\"\nimport { CountingSet } from \"../CountingSet\"\nimport { Elapsed } from \"../Elapsed\"\nimport { Logger, mkLogger } from \"../Logger\"\nimport { Average, AverageStats } from \"../math/Average\"\nimport { Pojo } from \"../Object\"\nimport { EndableRanks } from \"./Endable\"\nimport { EndableWrapper } from \"./EndableWrapper\"\n\nconst MinMs = 15\n\nexport class PromiseTimer {\n  private readonly errors = new CountingSet<string>()\n  private readonly times = new Map<string, Average>()\n\n  async time<T>(\n    desc: string,\n    p: () => SyncOrAsync<T>,\n    post?: (result: T | Error, elapsed: number) => void\n  ): Promise<T> {\n    const start = Date.now()\n    try {\n      const result = await p()\n      const elapsed = Date.now() - start\n      if (post != null) post(result, elapsed)\n      this.push(desc, elapsed)\n      if (elapsed > 2 * secondMs) {\n        mkLogger(\"time(\" + desc + \")\").warn(\"slow\", { elapsed })\n      }\n      return result\n    } catch (err) {\n      this.errors.incr(desc)\n      if (post != null) post(err, Date.now() - start)\n      throw err\n    }\n  }\n\n  get entriesBySumDesc() {\n    return sortBy([...this.times.entries()], ([, v]) => -v.sum)\n  }\n\n  stats(namePrefix: string) {\n    const arr = this.entriesBySumDesc.filter(([k]) => k.startsWith(namePrefix))\n    const merged = arr.reduce(\n      (agg, ea) => Average.merge(ea[1], agg),\n      new Average()\n    )\n    const stats = arr.map(\n      ([name, avg]) => [name, avg.stats()] as [string, AverageStats]\n    )\n    return fromEntries([[\"merged\", merged.stats()], ...stats])\n  }\n\n  mkElapsed(l: Logger) {\n    return new Elapsed(l, (s, ts) => this.push(s, ts))\n  }\n\n  push(name: string, elapsedMs: number) {\n    if (elapsedMs > MinMs) {\n      getOrSet(this.times, name, () => new Average()).push(elapsedMs)\n    }\n  }\n\n  weightedAvg(name: string): Maybe<number> {\n    return opt(this.times.get(name))\n      .map(avg => avg.weightedSampleAvg)\n      .get()\n  }\n\n  errorCounts() {\n    return this.errors.entriesByCountDesc()\n  }\n\n  callCounts(): { [name: string]: number } {\n    return [...this.times.entries()].reduce(\n      (o, [k, v]) => ({ ...o, [k]: v.n }),\n      {}\n    )\n  }\n\n  weightedAvgs(): { [name: string]: number } {\n    return compactValues(\n      [...this.times.entries()].reduce(\n        (o, [k, v]) => ({ ...o, [k]: mapFinite(v.weightedSampleAvg, round) }),\n        {}\n      )\n    ) as any\n  }\n\n  report(): { [name: string]: Pojo } {\n    // Sort by most time first:\n    return this.entriesBySumDesc.reduce(\n      (o, [k, v]) => ({\n        ...o,\n        [k]: {\n          sumSec: sigFigs(v.sum / secondMs, 3),\n          ...omit(v.stats(), \"sum\")\n        }\n      }),\n      {}\n    )\n  }\n}\n\nconst instance = lazy(() =>\n  tap(\n    new PromiseTimer(),\n    timer =>\n      new EndableWrapper(\n        \"PromiseTimer\",\n        () => {\n          const l = mkLogger(\"PromiseTimer\")\n          l.info(\"timings:\\n\", timer.report())\n          mapNotEmpty(timer.errorCounts(), err =>\n            l.warn(\"error counts:\\n\", err)\n          )\n        },\n        EndableRanks.service\n      )\n  )\n)\n\nexport function mkElapsed(name: string) {\n  return instance().mkElapsed(mkLogger(name))\n}\n\nexport function time<T>(\n  name: string,\n  p: () => SyncOrAsync<T>,\n  post?: (result: T | Error, elapsed: number) => void\n): Promise<T> {\n  return instance().time(name, p, post)\n}\n\nexport function timeStats(namePrefix: string) {\n  return instance().stats(namePrefix)\n}\n\nexport function timeReport() {\n  return instance().report()\n}\n\nexport function timedLazy<T>(\n  name: string,\n  thunk: () => SyncOrAsync<T>,\n  ttlMs?: number\n) {\n  return lazy(async () => time(name, thunk), ttlMs)\n}\n", "import { randomBytes } from \"crypto\"\nimport { blank } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isFunction } from \"../../fe/ObjectType\"\nimport { decuss } from \"../Cuss\"\nimport { identity } from \"../Object\"\nimport { splitEvery } from \"../String\"\n\nconst zero: any = BigInt(0)\n\nexport function encodeDigits(base: number, i: number, minLength = 0): number[] {\n  if (!isFinite(i) || base <= 1) return []\n\n  const digits: number[] = []\n  // use push and reverse instead of unshift to make sure we're prematurely\n  // optimizing all the things:\n  if (i === 0) {\n    digits.push(0)\n  } else {\n    while (i > 0) {\n      digits.push(i % base)\n      i = Math.floor(i / base)\n      // console.log(\"encodeDigits\", { i, base, digits })\n    }\n  }\n  while (digits.length < minLength) digits.push(0)\n  return digits.reverse()\n}\n\nexport class Radix {\n  readonly base: number\n  constructor(\n    readonly name: string,\n    readonly numerals: string,\n    readonly decodePreparser: (s: string) => string = identity\n  ) {\n    this.base = numerals.length\n  }\n\n  private digitsToNumerals(digits: number[]): string {\n    return digits.map(d => this.numerals[d]).join(\"\")\n  }\n\n  encode(num: number, minLength: number = 0): string {\n    if (!isFinite(num)) return \"\"\n    // r is a reversed array of chars:\n    const negate = num < 0\n    if (negate) {\n      num = Math.abs(num)\n      minLength-- // accommodate the sign\n    }\n    return (\n      (negate ? \"-\" : \"\") +\n      this.digitsToNumerals(encodeDigits(this.base, num, minLength))\n    )\n  }\n\n  encodeBigInt(bi: BigInt): string {\n    if (typeof bi !== \"bigint\") throw new Error(\"bad input\")\n    if (bi === zero) return this.numerals[0]\n\n    const digits: number[] = []\n    const b = BigInt(this.base)\n    let i: any = bi\n\n    while (i > zero) {\n      digits.push(Number(i % b))\n      i = i / b\n    }\n    return this.digitsToNumerals(digits.reverse())\n  }\n\n  encodeBuffer(buf: Buffer): string {\n    if (buf == null || buf.length === 0) return \"\"\n    const digits = [0]\n    for (let b of buf) {\n      digits.forEach((d, i) => {\n        // const b0 = b\n        b += d << 8\n        digits[i] = b % this.base\n        b = Math.floor(b / this.base)\n        // console.dir({ i, b0, b, d0: d, d: digits[i], digits })\n      })\n\n      while (b > 0) {\n        digits.push(b % this.base)\n        b = Math.floor(b / this.base)\n        // console.dir({ b, digits })\n      }\n    }\n    return this.digitsToNumerals(digits.reverse())\n  }\n\n  decode(s: Maybe<string>): Maybe<number> {\n    return map(this.decodeBigInt(s), ea => {\n      if (ea > BigInt(Number.MAX_SAFE_INTEGER)) {\n        throw new Error(\"decode(\" + s + \") is > 2^53\")\n      } else {\n        return Number(ea)\n      }\n    })\n  }\n\n  normalize(s: string): string {\n    return this.decodePreparser(s)\n  }\n\n  decodeBigInt(s: Maybe<string>): Maybe<bigint> {\n    if (s == null || blank(s)) return\n    s = isFunction(this.decodePreparser) ? this.decodePreparser(s) : s\n    const negate = s[0] === \"-\"\n    if (negate) {\n      s = s.slice(1)\n    }\n    const b = BigInt(this.base)\n    let acc = BigInt(0)\n    for (const ch of s) {\n      const idx = this.numerals.indexOf(ch)\n      if (idx < 0) {\n        return undefined\n      }\n      acc = acc * b + BigInt(idx)\n    }\n    return negate ? BigInt(-1) * acc : acc\n  }\n\n  randomChars(length: number): string {\n    // bits per char is Math.log2(this.base).\n\n    // we need bpc * length / 8 = random bytes.\n\n    // all these radix are < 256, so just fetch a couple extra bytes and trim:\n    return this.encodeBuffer(randomBytes(length + 3)).slice(1, length + 1)\n  }\n\n  safeRandomChars(length: number): string {\n    return decuss(() => this.randomChars(length))\n  }\n\n  /**\n   * UIDs are easier to parse or read if dashes break up the string.\n   *\n   * Reading 4-char groups is comfortable, 5 chars \"won-aye-six-gee-why\" is\n   * doable, I think, so split every 5?\n   *\n   * For GeoRadix, each char encodes 5 bits, so 20 chars is only 100 bits of\n   * entropy. 24 chars is 120. We need 32 chars for 160 bits, that's a lot.\n   */\n  randomUid(chars = 20, splitEveryN = 5, sepChar = \"-\"): string {\n    return splitEvery(this.randomChars(chars), splitEveryN).join(sepChar)\n  }\n\n  safeRandomUid(chars: number, splitEveryN = 5, sepChar = \"-\"): string {\n    return decuss(() => this.randomUid(chars, splitEveryN, sepChar))\n  }\n\n  tokenEql(a: string, b: string, minLen: number): boolean {\n    const an = this.normalizeToken(a)\n    const bn = this.normalizeToken(b)\n    return an.length >= minLen && an === bn\n  }\n\n  normalizeToken(a: string) {\n    return this.decodePreparser(a.trim())\n      .split(\"\")\n      .filter(ea => this.numerals.includes(ea))\n      .join(\"\")\n  }\n}\n\nexport const Hex = new Radix(\"hex\", \"0123456789abcdef\", s => s.toLowerCase())\n\n/**\n * URL-safe charset used for bitcoin and IPFS hashes\n * @see https://en.wikipedia.org/wiki/Base58\n */\nexport const Radix58 = new Radix(\n  \"Radix58\",\n  \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n)\n\n/**\n * Used by StringSimilarity.radixDiff\n */\nexport const RadixAlphaNum = new Radix(\n  \"RadixAlphaNum\",\n  \"0123456789abcdefghijklmnopqrstuvwxyz\",\n  s => s.toLowerCase()\n)\n\n/**\n * Base 32 charset for case-insensitive filesystems and human consumption\n * @see https://en.wikipedia.org/wiki/Geohash\n */\nexport const GeoRadix = new Radix(\n  \"GeoRadix\",\n  \"0123456789bcdefghjkmnpqrstuvwxyz\", // y no a?\n  s => s.toLowerCase()\n)\n\n/**\n * Base 32 charset for case-insensitive filesystems and human consumption.\n *\n * Similar glyphs include 0O, 1lI, 2z, 5S, 9g\n */\nexport const TokenRadix = new Radix(\n  \"TokenRadix\",\n  \"0123456789abcdefhjkmnpqrtuvwxy\",\n  s =>\n    s\n      .toLowerCase()\n      .replace(/[o]/g, \"0\")\n      .replace(/[il]/g, \"1\")\n      .replace(/[z]/g, \"2\")\n      .replace(/[s]/g, \"5\")\n      .replace(/[g]/g, \"9\")\n)\n\nexport const AlphaRadix = new Radix(\"AlphaRadix\", \"abcdefghjkmnpqrtuvwxyz\")\n\nexport const NumericRadix = new Radix(\"NumericRadix\", \"0123456789\", s =>\n  s\n    .toLowerCase()\n    .replace(/[o]/g, \"0\")\n    .replace(/[il]/g, \"1\")\n    .replace(/[z]/g, \"2\")\n    .replace(/[s]/g, \"5\")\n    .replace(/[g]/g, \"9\")\n)\n", "import { gunzipSync, gzipSync } from \"zlib\"\nimport { stepRange } from \"../../fe/Array\"\nimport { mapNotBlank } from \"../../fe/Blank\"\nimport { orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { absdiff } from \"../../fe/Number\"\nimport { zip } from \"../Array\"\nimport { hammRatioBigInt } from \"../Number\"\nimport { cosineSimilarity } from \"./Vector\"\n\nexport function hex2b64(hex: string): string {\n  return Buffer.from(hex, \"hex\").toString(\"base64\")\n}\n\nconst b64charset =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n\nexport function b64encode(i: number | BigInt): string {\n  if (typeof i === \"number\" && i < b64charset.length) {\n    return b64charset[i]\n  }\n  let hex = i.toString(16)\n  // Make sure we're padded to even characters:\n  if (hex.length % 2 === 1) {\n    hex = \"0\" + hex\n  }\n  return Buffer.from(hex, \"hex\").toString(\"base64\")\n}\n\nexport function b64decode(base64: string): BigInt {\n  return BigInt(\"0x0\" + Buffer.from(base64, \"base64\").toString(\"hex\"))\n}\n\nexport function b64encodeString(s: string): string {\n  return Buffer.from(s, \"utf8\").toString(\"base64\")\n}\n\nexport function b64decodeString(b64: string): string {\n  return Buffer.from(b64, \"base64\").toString(\"utf8\")\n}\n\n// use gzip rather than brotli as a head-fake to licensing\nexport function gz64encodeString(s: string): string {\n  return gzipSync(Buffer.from(s, \"utf8\")).toString(\"base64\")\n}\n\nexport function d(s: string): string {\n  return gunzipSync(Buffer.from(s, \"base64\")).toString(\"utf8\")\n}\n\nexport const gz64decodeString = d\n\n/**\n * hamm...ratio...operator\n */\nexport function b64hammRatio(\n  a: Maybe<string>,\n  b: Maybe<string>\n): Maybe<number> {\n  return mapNotBlank(a, ea1 =>\n    mapNotBlank(b, ea2 => hammRatioBigInt(b64decode(ea1), b64decode(ea2)))\n  )\n}\n\nexport function b64decodeSmall(s: string): number {\n  if (s == null || s.length === 0) return -1\n  const a = s.split(\"\")\n  let acc = 0\n  for (const c of a) {\n    const idx = b64charset.indexOf(c)\n    if (idx === -1) return -1\n    if (acc > 2 ** (52 - 6))\n      throw new Error(\"b64decodeSmall(\" + s + \"): overflow\")\n    acc = acc * 64 + idx\n  }\n  return acc\n}\n\nexport function uint8toB64(i: number[]): string {\n  return Buffer.from(Uint8ClampedArray.from(i).buffer).toString(\"base64\")\n}\n\nexport function uint6toB64(arr: number[]): string {\n  return arr.map(i => b64charset[i & 0b111111]).join(\"\")\n}\n\nexport function uint12toB64(arr: number[]): string {\n  const r: string[] = []\n  arr.forEach(i => {\n    r.push(b64encode((i >> 6) & 0b111111))\n    r.push(b64encode(i & 0b111111))\n  })\n  return r.join(\"\")\n}\n\nfunction toValues(b64str: string, bitdepth: 6 | 12 = 6): number[] {\n  const step = bitdepth / 6\n  return stepRange(0, b64str.length, step, i =>\n    b64decodeSmall(b64str.substr(i, step))\n  )\n}\n\n/**\n * Given two vectors of values, b64 encoded, where either 1 or two characters\n * encode a pixel value, return a value between 0 and 1, where 1 is a perfect\n * match.\n * @return [-1,1], 1 meaning perfect correlation, -1 meaning perfect\n * anti-correlation (the inverse of an image, for example)\n */\nexport function b64corr(\n  a: string,\n  b: string,\n  bitdepth: 6 | 12 = 6\n): Maybe<number> {\n  if (a === b) return 1\n  const x = toValues(a, bitdepth)\n  const y = toValues(b, bitdepth)\n  // cosine simularity assumes values are well-distributed around 0. b64 is\n  // only ever positive, so shift values to the left:\n  const mean = Math.pow(2, bitdepth - 1)\n  return cosineSimilarity(\n    x.map(i => i - mean),\n    y.map(i => i - mean)\n  )\n}\n\n/**\n * The larger the number, the larger the difference\n */\nexport function b64diff(a: string, b: string, bitdepth: 6 | 12 = 6): number {\n  if (a === b) return 0\n  return zip(toValues(a, bitdepth), toValues(b, bitdepth)).reduce(\n    (agg, ea) => orElse(absdiff(ea[0], ea[1]), 0) + agg,\n    0\n  )\n}\n", "import { lazy } from \"../fe/Lazy\"\nimport { d } from \"./math/b64\"\n\n// Created by CussMk on 2021-03-08T19:05:54.222Z\n// from 2,618 words\n\nexport const CussWords = lazy(() =>\n  d(\n    \"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\"\n  ).split(\",\")\n)\n", "import { flatten } from \"../fe/Array\"\n\nexport function l33t(s: string): string {\n  return s\n    .replace(/o/g, \"0\")\n    .replace(/[il]/g, \"1\")\n    .replace(/e/g, \"3\")\n    .replace(/a/g, \"4\")\n    .replace(/s/g, \"5\")\n    .replace(/b/g, \"6\")\n    .replace(/t/g, \"7\")\n    .replace(/g/g, \"9\")\n}\n\nexport function unl33t(s: string): string[] {\n  return un1eet(\n    s\n      .replace(/0/g, \"o\")\n      .replace(/3/g, \"e\")\n      .replace(/4/g, \"a\")\n      .replace(/5/g, \"s\")\n      .replace(/6/g, \"b\")\n      .replace(/7/g, \"t\")\n      .replace(/9/g, \"g\")\n  )\n}\n\nfunction un1eet(s: string): string[] {\n  const i = s.indexOf(\"1\")\n  if (i === -1) {\n    return [s]\n  } else {\n    const pre = s.substr(0, i)\n    const suffs = un1eet(s.substr(i + 1))\n    return flatten(suffs.map(ea => [pre + \"l\" + ea, pre + \"i\" + ea]))\n  }\n}\n", "import { filterInPlace, isNotEmpty, sortBy } from \"../fe/Array\"\nimport { getOrSet } from \"../fe/Map\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { Primitive } from \"../fe/Primitive\"\nimport { toA } from \"../fe/toA\"\nimport { remove } from \"./Array\"\nimport { sum } from \"./math/Vector\"\n\n/**\n * Multi-valued Map.\n * @see SetMap\n */\nexport class MultiMap<K, V> {\n  readonly store: Map<K, V[]>\n\n  constructor(store = new Map<K, V[]>()) {\n    this.store = store\n  }\n\n  get(key: K): V[] | undefined {\n    return this.store.get(key)\n  }\n\n  has(key: K): boolean {\n    return this.store.has(key)\n  }\n\n  /**\n   * @return the number of unique keys in this store\n   */\n  get keyCount(): number {\n    return this.store.size\n  }\n\n  /**\n   * @return the number of values in this store\n   */\n  get valueCount(): number {\n    return sum([...this.store.values()].map(ea => ea.length))\n  }\n\n  add(key: K, ...values: V[]): V[] {\n    const store = getOrSet(this.store, key, () => [])\n    store.push(...values)\n    return store\n  }\n\n  set(key: K, values: V[]) {\n    this.store.set(key, values)\n  }\n\n  delete(key: K, value?: V): boolean {\n    if (value == null) {\n      return this.store.delete(key)\n    } else {\n      const arr = this.store.get(key)\n      if (arr == null) {\n        return false\n      } else {\n        const result = remove(arr, value)\n        if (result && arr.length === 0) {\n          this.store.delete(key)\n        }\n        return result\n      }\n    }\n  }\n\n  clear(): this {\n    this.store.clear()\n    return this\n  }\n\n  keys(): IterableIterator<K> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<K> {\n      for (const [k, v] of self.store.entries()) {\n        if (v.length > 0) {\n          yield k\n        }\n      }\n    }\n    return iter()\n  }\n\n  values(): IterableIterator<V[]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<V[]> {\n      for (const [, v] of self.store.entries()) {\n        if (v.length > 0) {\n          yield v\n        }\n      }\n    }\n    return iter()\n  }\n\n  flatValues(): IterableIterator<V> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<V> {\n      for (const [, arr] of self.store.entries()) {\n        if (arr.length > 0) {\n          for (const ea of arr) {\n            yield ea\n          }\n        }\n      }\n    }\n    return iter()\n  }\n\n  entriesArray(): [K, V[]][] {\n    return [...this.store.entries()].filter(([, v]) => isNotEmpty(v))\n  }\n\n  entries(): IterableIterator<[K, V[]]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<[K, V[]]> {\n      for (const [k, v] of self.store.entries()) {\n        if (v.length > 0) {\n          yield [k, v]\n        }\n      }\n    }\n    return iter()\n  }\n\n  tuples(): IterableIterator<[K, V]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<[K, V]> {\n      for (const [k, v] of self.store.entries()) {\n        for (const ea of toA(v)) {\n          if (ea != null) yield [k, ea]\n        }\n      }\n    }\n    return iter()\n  }\n\n  filterInPlace(predicate: (key: K, value: V) => boolean): boolean {\n    let changed = false\n    for (const [k, arr] of this.store.entries()) {\n      const len = arr.length\n      filterInPlace(arr, v => predicate(k, v))\n      changed = changed || len !== arr.length\n    }\n    return changed\n  }\n}\n\n/**\n * Groups the given enumeration\n * @return a copy of arr, sorted by the given constraint\n */\nexport function groupBy<K extends Primitive, V>(\n  arr: V[],\n  f: (t: V) => Maybe<K>\n): MultiMap<K, V> {\n  const m = new MultiMap<K, V>()\n  arr.forEach(ea => map(f(ea), k => m.add(k, ea)))\n  return m\n}\n\nexport function groupByValues<K extends Primitive, V>(\n  arr: V[],\n  f: (t: V) => Maybe<K>\n): V[][] {\n  const g = groupBy(arr, f)\n  return sortBy(toA(g.values()), ea => f(ea[0]))\n}\n", "import { lazy } from \"../fe/Lazy\"\nimport { CussWords } from \"./CussWords\"\nimport { unl33t } from \"./Leet\"\nimport { MultiMap } from \"./MultiMap\"\nimport { stripDiacritics, stripEmoji } from \"./String\"\n\nconst cussTrie = lazy(() => asTrie(CussWords()))\n\n// uuid spec passes fastest with 3:\nconst TriePrefixLength = 3\n\nfunction asTrie(words: string[]) {\n  const trie = new MultiMap<string, string>()\n  const small: string[] = []\n  for (const ea of words) {\n    if (ea.length < TriePrefixLength) {\n      small.push(ea)\n    } else {\n      trie.add(ea.slice(0, TriePrefixLength), ea)\n    }\n  }\n  // console.log(\n  //   \"asTrie(): \" +\n  //     words.length +\n  //     \" words, \" +\n  //     trie.store.size +\n  //     \" prefixes, \" +\n  //     small.length +\n  //     \" too small\"\n  // )\n  return { trie, small }\n}\n\nexport function getCuss(s: string, naughtyWords?: string[]) {\n  const lc = stripEmoji(stripDiacritics(s.toLowerCase().normalize()))\n  const { small, trie } =\n    naughtyWords == null ? cussTrie() : asTrie(naughtyWords)\n  for (const w of [lc.replace(/[^a-z]/gi, \"\"), ...unl33t(lc)]) {\n    const smol = small.find(ea => w.includes(ea))\n    if (smol != null) return smol\n    for (let i = 0; i < w.length - (TriePrefixLength - 1); i++) {\n      const arr = trie.get(w.substr(i, TriePrefixLength))\n      if (arr != null) {\n        const sub = w.substr(i)\n        const bad = arr.find(ea => sub.startsWith(ea))\n        if (bad != null) {\n          return bad\n        }\n      }\n    }\n  }\n  return\n}\n\nexport function isCussy(s: string) {\n  return getCuss(s) != null\n}\n\nexport function decuss(f: () => string): string {\n  let retries = 10\n  let s = \"\"\n  do {\n    s = f()\n  } while (retries-- > 0 && isCussy(s.replace(/[^a-z]/gi, \"\")))\n\n  return s\n}\n", "import { commonPrefixLength, compactBlanks, count, sortBy } from \"../fe/Array\"\nimport { blank } from \"../fe/Blank\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { clamp, mapNumericOr, times, toInt } from \"../fe/Number\"\nimport { Primitive } from \"../fe/Primitive\"\nimport { toS } from \"../fe/toS\"\nimport { RadixAlphaNum } from \"./math/Radix\"\nimport { Array2D } from \"./Number\"\nimport { firstThunk } from \"./Object\"\nimport { intersection } from \"./Set\"\nimport { leftPad, stripDiacritics } from \"./String\"\n\n// export function commonPrefixChars(a: Maybe<string>, b: Maybe<string>): number {\n//   if (a == null || b == null) return 0\n//   const idx = a.split(\"\").findIndex((c, i) => c !== b[i])\n//   return idx === -1 ? a.length : idx\n// }\n\n/**\n * @return [0,1], where 0 means no common string, and 1 is equality\n */\nexport function commonSubstringRatio(a: string, b: string): number {\n  return [a, b].some(blank)\n    ? 0\n    : lcs(a, b).length / Math.max(a.length, b.length)\n}\n\n/**\n * @see https://en.wikipedia.org/wiki/Longest_common_substring_problem\n */\nexport function lcs(a: string, b: string): string {\n  if (a == null) return b\n  if (b == null) return a\n  a = a.normalize()\n  b = b.normalize()\n  if (a === b || b.includes(a)) return a\n  if (a.includes(b)) return b\n  const m = new Array2D(a.length)\n  let z = 0\n  let ret = \"\"\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < b.length; j++) {\n      if (a[i] === b[j]) {\n        if (i === 0 || j === 0) {\n          m.set(i, j, 1)\n        } else {\n          m.set(i, j, m.get(i - 1, j - 1) + 1)\n        }\n        if (m.get(i, j) >= z) {\n          z = m.get(i, j)\n          ret = a.substr(i - z + 1, z)\n        }\n      }\n    }\n  }\n  return ret\n}\n\n/**\n * Hamming distance. Note that `a` and `b` must be the same length.\n * @see https://en.wikipedia.org/wiki/Hamming_distance\n */\nexport function hamming(a: string, b: string): Maybe<number> {\n  if (a == null || b == null) return undefined\n  a = a.normalize()\n  b = b.normalize()\n  return a.length !== b.length\n    ? undefined\n    : a\n        .split(\"\")\n        .reduce((acc, ea, idx) => (ea === b.charAt(idx) ? acc : acc + 1), 0)\n}\n\n/**\n * Return the S\u00F8rensen\u2013Dice similarity index between two strings.\n * @see https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient\n * @return [0,1]. O for no match, 1 for full, case-insensitive match.\n */\nexport function diceCoeff(a: string, b: string): number {\n  const A = a.toUpperCase().normalize()\n  const B = b.toUpperCase().normalize()\n\n  return firstThunk<number>(\n    () => (A === B ? 1 : undefined),\n    () => (blank(a) !== blank(b) ? 0 : undefined),\n    () => (a.length === 1 && b.length === 1 ? 0 : undefined),\n    () => {\n      const aGrams = bigrams(A)\n      const bGrams = bigrams(B)\n      const intersections = nonUniqIntersection(aGrams, bGrams).length\n      return (2 * intersections) / (aGrams.length + bGrams.length)\n    }\n  )!\n}\n\n/**\n * Convert \"abcd\" to [\"ab\", \"bc\", \"cd\"]\n */\nexport function bigrams(s: string): string[] {\n  return s == null || s.length === 0\n    ? []\n    : s\n        .slice(0, -1)\n        .split(\"\")\n        .map((ea, i) => ea + s[i + 1])\n}\n\nexport function nonUniqIntersection<T extends Primitive>(a: T[], b: T[]): T[] {\n  const uniqIntersections = intersection(a, b)\n  const i: T[] = []\n  uniqIntersections.forEach(ea => {\n    const n = Math.min(\n      count(a, s => s === ea),\n      count(b, s => s === ea)\n    )\n    times(n, () => i.push(ea))\n  })\n  return i\n}\n\n/**\n * Tries to prevent numeric overflow:\n */\nfunction diffWithoutCommonPrefix(\n  a: string,\n  b: string,\n  f: (s: string) => number\n): number {\n  const cpc = commonPrefixLength(a, b)\n  return f(a.substr(cpc)) - f(b.substr(cpc))\n}\n\n/**\n * Return the value of the longest string of digits in `s`\n */\nfunction longestNumericString(s: string): Maybe<string> {\n  const digits = compactBlanks(toS(s).split(/[^\\d]+/))\n  return sortBy(digits, ea => -ea.length)[0]\n}\n\nexport function lnsDiff(a: string, b: string): number {\n  const [a1, b1] = [a, b]\n    .map(longestNumericString)\n    .map(ea => (blank(ea) ? \"\" : ea))\n  return diffWithoutCommonPrefix(a1, b1, s => toInt(s, { defaultValue: 0 })!)\n}\n\nconst notAlphaNumRe = /[^0-9a-z]+/gi\nexport function radixDiff(a: string, b: string): number {\n  const [a1, b1] = [a, b].map(s =>\n    stripDiacritics(s).replace(notAlphaNumRe, \"\").toLowerCase()\n  )\n  return diffWithoutCommonPrefix(a1, b1, s => RadixAlphaNum.decode(s)!)\n}\n\nexport function str(a: string, b: string) {\n  return {\n    pref: commonPrefixLength(a, b),\n    ham: hamming(a, b),\n    dice: diceCoeff(a, b),\n    lns: lnsDiff(a, b),\n    radixDiff: radixDiff(a, b)\n  }\n}\n\n/**\n * @return the number of non-lower-case characters in `s`\n */\nexport function lcdiff(s: string): number {\n  return count(\n    s.normalize().split(\"\"),\n    ea => ea.toLowerCase().localeCompare(ea) !== 0\n  )\n}\n\n/**\n * @return the weighted average of the character differences per character index\n */\nexport function positionalDiff(a: string, b: string) {\n  let result: Maybe<number>\n  for (let i = Math.max(a.length, b.length); i >= 0; i--) {\n    const aChar = mapNumericOr(a.charCodeAt(i), ea => ea, 256)\n    const bChar = mapNumericOr(b.charCodeAt(i), ea => ea, 256)\n    const diff = clamp(-256, 256, aChar - bChar)\n    if (result == null) result = diff\n    else result = (result + diff) / 2\n  }\n  return result\n}\n\nexport function paddedPositionalDiff(a: string, b: string, minLen = 8) {\n  return positionalDiff(leftPad(a, minLen, \" \"), leftPad(b, minLen, \" \"))\n}\n", "import { flatten } from \"../../fe/Array\"\nimport { toS } from \"../../fe/toS\"\nimport { isWin } from \"../Platform\"\nimport { newlineRe } from \"../String\"\n\nexport function crlf(s: string): string {\n  const result = s + \"\\n\"\n  return isWin ? result.replace(newlineRe, \"\\r\\n\") : result\n}\n\nexport function splitLines(...arr: string[]): string[] {\n  return flatten(arr.map(ea => toS(ea).split(newlineRe)))\n}\n", "import { Dirent, Stats } from \"fs\"\nimport { stat, unlink } from \"fs-extra\"\nimport { join, parse, sep } from \"path\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { SyncOrAsync } from \"../../fe/OptAsync\"\nimport { toA } from \"../../fe/toA\"\nimport { thenMap, thenOrElse } from \"../async/Promise\"\nimport { mkLogger } from \"../Logger\"\nimport { stripSuffix } from \"../String\"\nimport { ParsedFile, parseNativePath } from \"./Path\"\nimport { isSimpleDirent, readdir_, SimpleDirent } from \"./Readdir\"\nimport { SimpleFile } from \"./SimpleFile\"\n\n// DON'T REFERENCE POSIXFILE HERE, you'll have circular deps.\n\nexport class StatDirent implements Partial<Pick<Stats, \"size\" | \"mtimeMs\">> {\n  readonly isFile: boolean\n  readonly isDirectory: boolean\n  readonly size: Maybe<number>\n  readonly mtimeMs: Maybe<number>\n  // Allow the Stats instance to be GC'ed by copying what I need out of it:\n  constructor(readonly base: string, s: Stats | Dirent | SimpleDirent) {\n    if (isSimpleDirent(s)) {\n      // TODO: assert that base === s.basename\n      this.isFile = s.isFile\n      this.isDirectory = s.isDirectory\n    } else {\n      this.isFile = s.isFile()\n      this.isDirectory = s.isDirectory()\n      // isSymbolicLink is always false unless you use lstat, which we never use.\n    }\n    if (s instanceof Stats) {\n      this.size = s.size\n      this.mtimeMs = s.mtimeMs\n    }\n  }\n}\n\nconst logger = lazy(() => mkLogger(\"DirectoryEntry\"))\n\nexport class DirectoryEntry implements ParsedFile, SimpleFile {\n  /**\n   * Full path\n   */\n  readonly nativePath: string\n\n  /**\n   * @return extension (`.jpg` for `image.jpg`)\n   */\n  readonly ext: string\n\n  /**\n   * Should only be constructed by BaseFile\n   *\n   * @param dir The full parent directory path such as `/home/user/dir` or\n   * `c:\\\\path\\\\dir` for `/home/user/dir/file.txt` or `c:\\\\path\\\\dir\\\\file.txt`\n   */\n  constructor(readonly dir: string, readonly dirent: StatDirent) {\n    this.nativePath = join(this.dir, dirent.base)\n    this.ext = parseNativePath(dirent.base).ext\n  }\n\n  static async for(nativePath: string): PromiseMaybe<DirectoryEntry> {\n    const p = parseNativePath(nativePath)\n    try {\n      const s = await stat(nativePath)\n      return new DirectoryEntry(p.dir, new StatDirent(p.base, s))\n    } catch {\n      return\n    }\n  }\n\n  async join(...path: string[]) {\n    return DirectoryEntry.for(join(this.nativePath, ...path))\n  }\n\n  /**\n   * @return the full basename `image.jpg`\n   */\n  get base() {\n    return this.dirent.base\n  }\n\n  /**\n   * @return basename without the ext (`image` for `image.jpg`)\n   */\n  get name() {\n    return stripSuffix(this.base, this.ext)\n  }\n\n  get pathnames(): string[] {\n    return this.nativePath.split(sep)\n  }\n\n  toString() {\n    return this.nativePath\n  }\n\n  isFile() {\n    return this.dirent.isFile\n  }\n\n  isDirectory() {\n    return this.dirent.isDirectory\n  }\n\n  get isRoot() {\n    return this.dir === parse(this.dir).dir\n  }\n\n  parent(): SyncOrAsync<Maybe<this>> {\n    const p = parseNativePath(this.dir)\n    return p.dir === this.dir\n      ? this // root\n      : (new DirectoryEntry(p.dir, {\n          base: p.base,\n          isFile: false,\n          isDirectory: true,\n          mtimeMs: undefined as any,\n          size: undefined as any\n        }) as this)\n  }\n\n  async childNames() {\n    try {\n      return !this.isDirectory()\n        ? undefined\n        : (await readdir_(this.nativePath)).map(ea => ea.basename)\n    } catch (err) {\n      logger().warn(\n        \"childNames() failed to readdir(\" + this.nativePath + \")\",\n        err\n      )\n      return\n    }\n  }\n\n  async children() {\n    try {\n      if (!this.isDirectory()) return undefined\n      const arr = await readdir_(this.nativePath)\n      return arr.map(\n        ea =>\n          new DirectoryEntry(\n            this.nativePath,\n            new StatDirent(ea.basename, ea)\n          ) as this\n      )\n    } catch (err) {\n      logger().warn(\n        \"children() failed to readdir(\" + this.nativePath + \")\",\n        err\n      )\n      return\n    }\n  }\n\n  async visitDescendantFiles(f: (child: this) => any) {\n    for (const ea of toA(await this.children())) {\n      await (ea.isFile()\n        ? f(ea)\n        : ea.isDirectory()\n        ? ea.visitDescendantFiles(f)\n        : undefined)\n    }\n  }\n\n  async filterDescendantFiles(f: (child: this) => SyncOrAsync<boolean>) {\n    const arr: this[] = []\n    await this.visitDescendantFiles(async ea => {\n      if (true === (await f(ea))) arr.push(ea)\n    })\n    return arr\n  }\n\n  stat() {\n    return stat(this.nativePath).catch(() => undefined)\n  }\n\n  async size(): PromiseMaybe<number> {\n    return thenOrElse(this.dirent.size, () =>\n      thenMap(this.stat(), ea => ea.size)\n    )\n  }\n\n  async mtimeMs(): PromiseMaybe<number> {\n    return thenOrElse(this.dirent.mtimeMs, () =>\n      thenMap(this.stat(), ea => ea.mtimeMs)\n    )\n  }\n\n  unlink_() {\n    return unlink(this.nativePath)\n  }\n}\n", "import { mkdirp, readdir, stat } from \"fs-extra\"\nimport { join } from \"path\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { untilTrue } from \"../async/until\"\nimport { isBoolean } from \"../../fe/Boolean\"\nimport { thenElapsed } from \"../Elapsed\"\nimport { onClearCache, onFileChanged } from \"../event/EventEmitter\"\nimport { FifoCacheAsync } from \"../FifoCache\"\nimport { mkLogger } from \"../Logger\"\nimport { Settings } from \"../settings/Settings\"\nimport { sortByCaseInsensitive, splitEvery } from \"../String\"\nimport { CmdTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { shortFsStringSha } from \"./Hash\"\nimport { outputJsonGz_, readJsonGz_ } from \"./zcat\"\n\n/** horrible short field names to minimize json size */\nexport interface SimpleDirent {\n  /**  isFile */\n  isFile: boolean\n  /**  isDirectory */\n  isDirectory: boolean\n  /** full base name */\n  basename: string\n}\n\nexport const ReadDirCacheName = \"readdircache\"\n\nexport const readdirCacheDir = lazy(async () => {\n  const path = join(Settings.cacheDir.valueOrDefault, ReadDirCacheName)\n  await mkdirp(path)\n  return path\n}, minuteMs)\n\nexport async function cachedReadDirJson(nativePath: string) {\n  return join(\n    await readdirCacheDir(),\n    ...splitEvery(shortFsStringSha(nativePath) + \".json.gz\", 2, 3)\n  )\n}\n\nconst logger = lazy(() => mkLogger(\"Readdir\"))\n\nexport function isSimpleDirent(d: any): d is SimpleDirent {\n  return (\n    d != null &&\n    notBlank(d.basename) &&\n    isBoolean(d.isFile) &&\n    isBoolean(d.isDirectory)\n  )\n}\n\nlater(() => {\n  onClearCache(() => path2cache.prior()?.clear())\n  onFileChanged((nativePath?: string | undefined) => {\n    nativePath == null\n      ? path2cache.prior()?.clear()\n      : path2cache.prior()?.deleteIf(ea => ea.startsWith(nativePath))\n  })\n})\n\nconst path2cache = lazy(\n  () =>\n    new FifoCacheAsync<SimpleDirent[]>({\n      maxSize: 500,\n      timeoutMs: CmdTimeoutMs,\n      clearEveryMs: minuteMs\n    })\n)\n\n/**\n * @throws if readdir() fails.\n */\nexport async function readdir_(nativePath: string): Promise<SimpleDirent[]> {\n  const result = await path2cache().getOrSetAsync(nativePath, () =>\n    _readdir_(nativePath)\n  )\n  if (result == null) {\n    throw new Error(\"readdir() timeout for \" + nativePath)\n  } else {\n    return result\n  }\n}\n\nasync function _readdir_(nativePath: string): Promise<SimpleDirent[]> {\n  const cache = await cachedReadDirJson(nativePath)\n  try {\n    const mtime = (await stat(cache)).mtimeMs\n    if (\n      Date.now() - mtime <\n      Settings.readdirCacheSeconds.valueOrDefault * secondMs\n    ) {\n      // If the cache file exists, it may be in progress:\n      let prior: any\n\n      if (\n        await untilTrue(\n          async () => {\n            prior = await readJsonGz_(cache)\n            return (\n              prior != null &&\n              Array.isArray(prior) &&\n              prior.every(isSimpleDirent)\n            )\n          },\n          { timeoutMs: CmdTimeoutMs - secondMs, timeBetweenMs: 250 }\n        )\n      ) {\n        return prior!\n      }\n    }\n  } catch (err) {\n    if (err.code !== \"ENOENT\")\n      logger().debug(\"Failed to read from readdir cache\", err)\n  }\n  // NOTE: this may throw:\n  const r = await thenElapsed(readdir(nativePath, { withFileTypes: true }))\n\n  const arr = sortByCaseInsensitive(\n    r.result.map(ea => ({\n      basename: ea.name,\n      isFile: ea.isFile(),\n      isDirectory: ea.isDirectory()\n    })),\n    ea => ea.basename\n  )\n\n  if (r.elapsedMs >= 500) {\n    try {\n      // outputJson, vs writeJson, does a mkdirp beforehand:\n      await outputJsonGz_(cache, arr)\n      logger().debug(\"Wrote readdir cache for slow directory\", {\n        nativePath,\n        elapsedMs: r.elapsedMs\n      })\n    } catch (err) {\n      logger().debug(\"Failed to write to readdir cache\", err)\n    }\n  }\n  return arr\n}\n", "import crypto from \"crypto\"\nimport fs from \"fs\"\nimport { stringify } from \"../../fe/JSON\"\nimport { orElse } from \"../../fe/Maybe\"\nimport { thenCollect } from \"../../fe/Promise\"\nimport { GeoRadix, Radix58 } from \"../math/Radix\"\nimport { PushProgressObserver } from \"./ProgressObservers\"\n\n// Secure hash research:\n\n// SHA1 has known collisions. It should be expected for a nerd to have sample\n// images that collide on their laptop.\n\n// SHA2 224 and 256 uses 32 bit operations.  SHA-512/224 provides length\n// protection and is 20-50% faster than SHA224 on 64 bit hardware, but NodeJS'\n// crypto only supports SHA-512 (not the SHA-512/224 or SHA-512/256 variant),\n// which is simply SHA-512's leftmost N bits with a different initialization\n// vector.\n\n// I don't see why these SHA values would need to be externally consumed, so\n// people shouldn't care if the SHA in the db isn't a FIPS standard. I don't\n// want to pull in another native library dependency if I can help it.\n\n// ALSO: I don't need that many bits to ensure uniqueness! 160 was enough for\n// SHA1, 192 should be plenty, and only takes 32 base64 characters (and doesn't\n// waste chars on padding).\n\n// HOWEVER: versions pre-v0.3.5 used the most significant 224 bits, so when we\n// build SHAs of strings (like for volume UIDs), we maintain backward\n// compatibility by slicing MSB 224 bits. If we slice 192 bits and we use a\n// non-8-bit-divisible radix, the values change.\n\n// See https://news.ycombinator.com/item?id=10011472\n\n// `shasum -a 512224` implements SHA-512/224.\n// `shasum -a 512256` implements SHA-512/256.\n\nexport const HashBits = 192\n\n/**\n * @return a Buffer with the first 192 bits of a SHA512 digest.\n * @throws on read error\n */\nexport async function fileSha(\n  filenames: string[],\n  opts?: {\n    observer?: PushProgressObserver\n    msbits?: number\n  }\n): Promise<Buffer> {\n  const hash = crypto.createHash(\"sha512\")\n  let bytesRead = 0\n  const msb = orElse(opts?.msbits, HashBits) / 8\n  await thenCollect(\n    filenames,\n    filename =>\n      new Promise<void>((resolve, reject) => {\n        const input = fs.createReadStream(filename, { autoClose: true })\n        input.on(\"error\", (err: Error) => reject(err))\n        input.on(\"data\", (chunk: string | Buffer) => {\n          bytesRead += chunk.length\n          opts?.observer?.onProgress(bytesRead)\n          hash.update(chunk)\n        })\n        input.on(\"end\", () => resolve())\n      })\n  )\n  return hash.digest().slice(0, msb)\n}\n\nexport function stringSha(input: string, msbits = HashBits): Buffer {\n  return crypto\n    .createHash(\"sha512\")\n    .update(input)\n    .digest()\n    .slice(0, msbits / 8)\n}\n\n/**\n * Encoding of the SHA of `input`.\n */\nexport function shortStringSha(\n  input: string,\n  len = 9,\n  radix = Radix58,\n  msbits = 224 // < pre-v0.3.5 used 224 bits, so this keeps those SHAs stable\n): string {\n  return radix.encodeBuffer(stringSha(input, msbits)).substring(0, len)\n}\n\n// filesystem-safe short shas\nexport function shortFsStringSha(\n  input: string,\n  len = 24,\n  radix = GeoRadix,\n  msbits = 224 // < pre-v0.3.5 used 224 bits, so this keeps those SHAs stable\n): string {\n  return shortStringSha(input, len, radix, msbits)\n}\n\n// /**\n//  * Take the SHA of a readable\n//  */\n// export async function readableShaB64(reader: Readable): Promise<string> {\n//   const hash = crypto.createHash(\"sha512\")\n//   await  pipelinePromise([reader, hash])\n//   return sliced(hash.digest()).toString(\"base64\")\n// }\n\nexport function numericSha(obj: any, msbits = 48): number {\n  return parseInt(stringSha(stringify(obj), msbits).toString(\"hex\"), 16)\n}\n", "import { createReadStream } from \"fs\"\nimport { outputFile, stat } from \"fs-extra\"\nimport { Writable } from \"stream\"\nimport { promisify } from \"util\"\nimport { createBrotliDecompress, createGunzip, gzip } from \"zlib\"\nimport { isNotEmpty } from \"../../fe/Array\"\nimport { stringify } from \"../../fe/JSON\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { thenMap } from \"../../fe/Promise\"\nimport { toS } from \"../../fe/toS\"\nimport { mkLogger } from \"../Logger\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { Pipeline, pipelineAsync } from \"./Streams\"\nimport { WritableToBuffer } from \"./WritableToBuffer\"\n\nconst logger = lazy(() => mkLogger(\"zcat\"))\n\nexport async function zcat(\n  nativePath: string,\n  options?: { start?: number; end?: number }\n) {\n  try {\n    return thenMap(zCopyToBuffer_(nativePath, options), toS)\n  } catch (err) {\n    logger().warn(\"zcat failed to read \" + nativePath, err)\n    return undefined\n  }\n}\n\nexport async function zCopyTo_(\n  nativePath: string,\n  outputStream: Writable,\n  options?: { start?: number; end?: number }\n) {\n  const s = await stat(nativePath)\n  if (s.size === 0) return\n\n  const errs: Error[] = []\n  const p: Pipeline = [\n    createReadStream(nativePath, { autoClose: true, ...options }).on(\n      \"error\",\n      err => errs.push(err)\n    )\n  ]\n  if (nativePath.toLowerCase().endsWith(\".gz\")) {\n    p.push(createGunzip().on(\"error\", err => errs.push(err)))\n  } else if (nativePath.toLowerCase().endsWith(\".br\")) {\n    p.push(createBrotliDecompress().on(\"error\", err => errs.push(err)))\n  }\n  p.push(outputStream)\n  await pipelineAsync(p)\n  if (isNotEmpty(errs)) {\n    throw new WrappedError({\n      message: \"zReadFile(\" + nativePath + \") failed\",\n      cause: errs[0]\n    })\n  }\n}\n\n/**\n * `readFile`, but on-the-fly decompression for .gz and .br\n * @throws on error\n */\nexport async function zCopyToBuffer_(\n  nativePath: string,\n  options?: { start?: number; end?: number }\n): Promise<Buffer> {\n  const s = await stat(nativePath)\n  if (s.size === 0) return Buffer.from([])\n  const w = new WritableToBuffer()\n  await zCopyTo_(nativePath, w, options)\n  return await w.buffer\n}\n\nexport async function readJsonGz_(nativePath: string) {\n  return JSON.parse((await zCopyToBuffer_(nativePath)).toString())\n}\n\nconst async_gzip = promisify(gzip)\n\nexport async function outputJsonGz_(nativePath: string, obj: any) {\n  const json = stringify(obj)\n  const out = await async_gzip(json)\n  return outputFile(nativePath, out)\n}\n", "import { compactBlanks } from \"../../fe/Array\"\nimport { mapNotBlank } from \"../../fe/Blank\"\nimport { errorToS } from \"../../fe/Error\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { stripPrefix, uniqSubstr } from \"../String\"\nimport {\n  addErrorFlags,\n  DoNotSendErrorFlag,\n  FatalErrorFlag,\n  IgnorableErrorFlag,\n  NonRetriableErrorFlag,\n  PleaseSendErrorFlag,\n  RetriableErrorFlag,\n  stripErrorFlags\n} from \"./ErrorTypes\"\n\nfunction buildErrorMessage({\n  message,\n  cause,\n  retriable,\n  ignorable,\n  fatal,\n  doNotSend\n}: {\n  message: Maybe<string>\n  cause: Maybe<Error>\n  retriable: boolean\n  ignorable: boolean\n  fatal: boolean\n  doNotSend: boolean\n}): string {\n  const arr = [message]\n  mapNotBlank(stripPrefix(errorToS(cause), \"Error: \"), ea => arr.push(ea))\n  const s = uniqSubstr(compactBlanks(arr)).join(\": \")\n\n  fatal = fatal || s.includes(FatalErrorFlag)\n  retriable =\n    (retriable || s.includes(RetriableErrorFlag)) &&\n    !s.includes(NonRetriableErrorFlag)\n  doNotSend = doNotSend || !s.includes(PleaseSendErrorFlag)\n  ignorable = ignorable || s.includes(IgnorableErrorFlag)\n\n  return addErrorFlags(\n    stripErrorFlags(s),\n    fatal ? FatalErrorFlag : undefined,\n    doNotSend ? DoNotSendErrorFlag : undefined,\n    ignorable && !fatal ? IgnorableErrorFlag : undefined,\n    !retriable && !fatal ? NonRetriableErrorFlag : undefined,\n    retriable && !fatal ? RetriableErrorFlag : undefined\n  )\n}\n\nexport class WrappedError extends Error {\n  readonly cause?: Error\n  readonly retriable: boolean\n  readonly fatal: boolean\n  constructor({\n    cause,\n    message,\n    retriable = true,\n    ignorable = false,\n    fatal = false,\n    doNotSend = false\n  }: {\n    cause?: Error\n    message?: string\n    retriable?: boolean\n    ignorable?: boolean\n    fatal?: boolean\n    doNotSend?: boolean\n  }) {\n    super(\n      buildErrorMessage({\n        message,\n        cause,\n        retriable,\n        ignorable,\n        fatal,\n        doNotSend\n      })\n    )\n    this.cause = cause\n    if (cause != null) this.stack = cause.stack\n    this.retriable = retriable\n    this.fatal = fatal\n  }\n}\n", "import { Writable, WritableOptions } from \"stream\"\nimport { Deferred } from \"../async/Deferred\"\n\n/**\n * Concats the result of a stream's data into a `Buffer`\n */\nexport class WritableToBuffer extends Writable {\n  private readonly deferred = new Deferred<Buffer>(\"WritableToBuffer\")\n  private readonly _buf: Buffer[] = []\n\n  constructor(opts?: WritableOptions) {\n    super(opts)\n    this.on(\"finish\", () => {\n      this.deferred.resolve(this.data)\n    })\n    this.on(\"error\", err => {\n      this.deferred.reject(err)\n    })\n  }\n\n  get data(): Buffer {\n    return Buffer.concat(this._buf)\n  }\n\n  /**\n   * Final result. Will only be resolved on finish.\n   */\n  get buffer(): Promise<Buffer> {\n    return this.deferred.promise\n  }\n\n  _write(chunk: any, encoding: BufferEncoding, next: () => void) {\n    this._buf.push(\n      Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding)\n    )\n    next()\n  }\n}\n", "import { blank } from \"../../fe/Blank\"\nimport { later } from \"../../fe/Delay\"\nimport { onClearCache, onFileChanged } from \"../event/EventEmitter\"\nimport { FifoCache } from \"../FifoCache\"\nimport { BaseFile } from \"./BaseFile\"\n\nexport const InstanceCacheMaxSize = 64\n\nexport class FileCache<T extends BaseFile> extends FifoCache<T> {\n  constructor() {\n    super(InstanceCacheMaxSize)\n    // break circular deps:\n    later(() => onFileChanged(path => this.clearFromPath(path)))\n    later(() => onClearCache(() => this.clear()))\n    // Prevent memory leaks:\n    this.on(\"expire\", (_k, v) => v?.clear())\n  }\n\n  clearFromPath(fromPath?: string) {\n    // NOTE: We don't delete these values so we can clear them later:\n    // (tests will fail if this is changed from .visit to .deleteIf)\n    blank(fromPath)\n      ? this.clear()\n      : this.visit((k, v) => {\n          if (k.startsWith(fromPath)) {\n            v.clear()\n          }\n        })\n  }\n}\n\nexport class NoOpFileCache<T extends BaseFile> {\n  get(_key: string) {\n    return undefined\n  }\n  set(_key: string, _value: T) {\n    return this\n  }\n  getOrSet(_key: string, valueThunk: () => T): T {\n    return valueThunk()\n  }\n}\n", "import { Transform, TransformCallback } from \"stream\"\nimport { unrefDelay } from \"../../fe/Delay\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { newlineRe } from \"../../fe/String\"\nimport { toS } from \"../../fe/toS\"\n\nexport class LineReader extends Transform {\n  private _prior: Maybe<string>\n\n  constructor() {\n    super({ objectMode: false, autoDestroy: true })\n  }\n\n  async _transform(\n    chunk: any,\n    _encoding: BufferEncoding,\n    done: TransformCallback\n  ) {\n    const lines = (toS(this._prior) + toS(chunk)).split(newlineRe)\n    const last = lines.pop()\n    // if the last line is \"\", we ended with a newline, and we don't have a prior.\n    this._prior = last === \"\" ? undefined : last\n    for (const ea of lines) {\n      if (!this.push(ea)) {\n        await unrefDelay(1)\n      }\n    }\n    done()\n  }\n\n  _flush(done: TransformCallback): void {\n    if (this._prior != null) this.push(this._prior)\n    this._prior = undefined\n    done()\n  }\n}\n", "import { clearInterval, setInterval } from \"timers\"\nimport {\n  emitProgressEvt,\n  ProgressEvt,\n  ProgressEvtWithoutPct\n} from \"../../core/event/ProgressEvt\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe, MaybePromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { clamp, round } from \"../../fe/Number\"\nimport { throttle, Throttled } from \"../../fe/Throttle\"\nimport { thenMap } from \"../async/Promise\"\n\nconst DefaultThrottleMs = 500\n\nexport class PushProgressObserver {\n  private readonly start = Date.now()\n  private current?: number\n  private readonly emit: Throttled<void>\n  constructor(\n    readonly context: ProgressEvtWithoutPct,\n    readonly total: number,\n    readonly throttleMs: number = DefaultThrottleMs\n  ) {\n    this.emit = throttle(\n      () => {\n        emitProgressEvt({\n          ...this.context,\n          pct: this.pct,\n          elapsedMs: this.elapsedMs\n        })\n      },\n      this.throttleMs,\n      true\n    )\n  }\n\n  incrProgress(incremental: number) {\n    this.onProgress(incremental + orElse(this.current, 0))\n  }\n\n  onProgress(current?: number) {\n    this.current = clamp(\n      0,\n      this.total,\n      orElse(current, orElse(this.current, 0) + 1)\n    )\n    this.emit()\n  }\n\n  get pct() {\n    return round((100 * orElse(this.current, 0)) / this.total)\n  }\n\n  get elapsedMs() {\n    return Date.now() - this.start\n  }\n}\n\nexport class PullProgressObserver {\n  private readonly start = Date.now()\n  private timer?: NodeJS.Timer\n  private readonly onInterval: Throttled<any>\n\n  constructor(\n    readonly ctx: Pick<ProgressEvt, \"path\" | \"op\">,\n    readonly total: number,\n    readonly progress: () => Maybe<number> | MaybePromiseMaybe<number>,\n    readonly throttleMs: number = DefaultThrottleMs\n  ) {\n    this.onInterval = throttle(\n      () => thenMap(this.progress(), ea => this.emit(ea)),\n      this.throttleMs\n    )\n    this.timer = setInterval(() => this.onInterval(), DefaultThrottleMs)\n  }\n\n  observe<T>(p: Promise<T>): Promise<T> {\n    // we throw this promise chain away:\n    p.then(() => this.completed()).catch(() => this.end())\n    return p\n  }\n\n  private emit(current: Maybe<number>) {\n    map(current, ea =>\n      emitProgressEvt({\n        ...this.ctx,\n        pct: (100 * clamp(0, this.total, ea)) / this.total,\n        elapsedMs: Date.now() - this.start\n      })\n    )\n  }\n\n  completed() {\n    if (Date.now() - this.start > DefaultThrottleMs) {\n      this.emit(this.total)\n    }\n    this.end()\n  }\n\n  end() {\n    map(this.timer, ea => clearInterval(ea))\n    this.timer = undefined\n  }\n}\n", "import { notBlank } from \"../../fe/Blank\"\nimport { clamp, round } from \"../../fe/Number\"\nimport { within } from \"../Number\"\nimport { eventEmitter } from \"./EventEmitter\"\n\n// \"ProgressEvent\" is part of lib.dom. Let's not collide.\nexport interface ProgressEvt {\n  path: string\n  op: string\n  pct: number\n  elapsedMs?: number\n}\n\nexport type ProgressEvtWithoutPct = Pick<ProgressEvt, \"path\" | \"op\">\n\nexport function isProgressEvt(o: any): o is ProgressEvt {\n  return (\n    o != null && notBlank(o.path) && notBlank(o.op) && within(0, 100, o.pct)\n  )\n}\n\nconst EventName = \"progress\"\n\nexport function emitProgressEvt(p: ProgressEvt) {\n  if (isProgressEvt(p)) {\n    eventEmitter.emit(EventName, {\n      ...p,\n      pct: round(clamp(0, 100, p.pct))\n    })\n  }\n}\n\nexport function onProgressEvt(listener: (p: ProgressEvt) => any) {\n  eventEmitter.on(EventName, listener)\n}\n\nexport function removeProgressEvtListener(listener: (p: ProgressEvt) => any) {\n  return eventEmitter.removeListener(EventName, listener)\n}\n", "import { Maybe } from \"./MaybeTypes\"\n\nexport interface Throttled<T> {\n  (...args: any[]): Maybe<T>\n  count(): number\n}\n\nexport function throttle<T>(\n  f: (...args: any[]) => T,\n  waitMs: number,\n  initialWait = false\n): Throttled<T> {\n  let next = initialWait ? Date.now() + waitMs : 0\n  let count = 0\n  const r: any = (...args: any[]) => {\n    const now = Date.now()\n    if (now >= next) {\n      next = now + waitMs\n      count++\n      return f(...args)\n    } else {\n      return\n    }\n  }\n  r.count = () => count\n  return r\n}\n", "import { dirname, join } from \"path\"\nimport { cwd } from \"process\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { SimpleAppName } from \"../AppName\"\nimport { uniqInPlace } from \"../Array\"\nimport { isDocker, isElectron, isMac } from \"../Platform\"\nimport { hasChildren, ancestors } from \"./Ancestors\"\n\nexport const execDir = lazy(() => dirname(process.execPath))\n\nexport namespace ProjectPath {\n  export const Root = lazy(() => {\n    const projectDirs = [\"icc\", \"migrations\", \"public\", \"views\"] // < no tools in server!\n    const dirs: string[] = []\n    if (isDocker()) {\n      dirs.push(\"/ps/app\")\n    }\n    if (isElectron) {\n      dirs.push(\n        join(execDir(), \"resources\"), // win electron\n        join(execDir(), \"..\", \"Resources\") // mac electron\n      )\n    }\n    dirs.push(...compactBlanks([execDir(), cwd(), __dirname]))\n    uniqInPlace(dirs)\n    for (const dir of dirs) {\n      if (hasChildren(dir, projectDirs)) return dir\n      // don't go too far up:\n      for (const parent of ancestors(dir).slice(0, 4)) {\n        if (hasChildren(parent, projectDirs)) return parent\n        const npx = join(dir, \"node_modules\", \"photostructure\")\n        if (hasChildren(npx, projectDirs)) return npx\n      }\n    }\n    throw new Error(\"Failed to find project root. Looked in \" + dirs)\n  })\n  const pathTo = (child: string) => lazy(() => join(Root(), child))\n  export const Bin = pathTo(\"bin\") // only present in docker and node\n  export const ICC = pathTo(\"icc\")\n  export const Migrations = pathTo(\"migrations\")\n  export const Public = pathTo(\"public\")\n  export const Tools = pathTo(\"tools\")\n  export const Views = pathTo(\"views\")\n\n  export async function isInDMG(projectPathRoot = Root()) {\n    if (!isMac) return false\n\n    // If PhotoStructure.app has a sibling called .background with a\n    // nobg-background.tiff, we're still in the DMG, but that will break if we\n    // change the DMG background. We could also check to see that we live in an\n    // Applications directory, but that's also not guaranteed.\n\n    // if (root.includes(`/Applications/${SimpleAppName}.app`)) {\n    //   logger().debug(\"notInDMG(): we're in an Applications dir, excellent.\")\n    //   return\n    // }\n\n    const dmgRE = new RegExp(\n      `^\\\\/Volumes\\\\/${SimpleAppName}[^\\\\/]*\\\\/${SimpleAppName}.app\\\\/`,\n      \"i\"\n    )\n    return dmgRE.exec(projectPathRoot) != null\n  }\n}\n", "import { readdirSync } from \"fs\"\nimport { dirname } from \"path\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\n\nexport function ancestors(path: string): string[] {\n  const arr = []\n  while (path !== dirname(path)) {\n    path = dirname(path)\n    arr.push(path)\n  }\n  return arr\n}\n\nexport function childrenSync(path: string): string[] {\n  try {\n    return readdirSync(path)\n  } catch (err) {\n    return []\n  }\n}\nexport function hasChildren(path: string, childNames: string[]): boolean {\n  const actual = childrenSync(path)\n  return childNames.every(ea => actual.includes(ea))\n}\n\nexport function ancestorWithChildren(\n  path: string,\n  childNames: string[]\n): Maybe<string> {\n  return ancestors(path).find(ea => hasChildren(ea, childNames))\n}\n", "import { notBlank } from \"../../fe/Blank\"\nimport { Latch } from \"../../fe/Latch\"\n\nexport function onDataChunked(\n  r: NodeJS.ReadableStream,\n  sep: string | RegExp,\n  onData: (data: string) => any\n): Latch {\n  const c = new Chunker(sep, onData, true)\n  c.read(r)\n  return c.done\n}\n\n/**\n * Handles data streams that may come in with disjoint chunks (like `[\"hel\",\n * \"lo\\n\"]`)\n */\nexport class Chunker {\n  private incompleteChunk = \"\"\n  readonly done = new Latch()\n\n  constructor(\n    readonly sep: string | RegExp,\n    readonly onData: (data: string) => any,\n    readonly filterBlanks = true\n  ) {}\n\n  onChunk(chunk: string | Buffer) {\n    if (chunk == null) return\n    const s = this.incompleteChunk + chunk.toString()\n    const split = s.split(this.sep)\n    // If s is not terminated by a separator, the last element in the array will\n    // be non-blank. If the string ends in a separator, an empty string will be\n    // the last element of the array, and this \"clears out\" incompleteChunk (as\n    // we'd want), so both cases are handled appropriately here:\n    this.incompleteChunk = split.pop()!\n    split.forEach(ea => {\n      if (!this.filterBlanks || notBlank(ea)) {\n        this.onData(ea)\n      }\n    })\n  }\n\n  clear() {\n    this.onChunk(\"\")\n    if (notBlank(this.incompleteChunk)) this.onData(this.incompleteChunk)\n    this.incompleteChunk = \"\"\n  }\n\n  read(r: NodeJS.ReadableStream) {\n    r.on(\"data\", ea => this.onChunk(ea))\n    r.on(\"end\", () => {\n      this.clear()\n      void this.done.resolve()\n    })\n    return this\n  }\n}\n", "import { compact } from \"../fe/Array\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe, MaybePromiseMaybe } from \"../fe/MaybeTypes\"\nimport { toA } from \"../fe/toA\"\nimport { concat } from \"./Array\"\n\nexport function hasAll<K>(m: Map<K, any> | Set<K>, arr: K[]): boolean {\n  return arr.every(ea => m.has(ea))\n}\n\nexport function flatMap<T, K, V>(iter: T[], f: (t: T) => [K, V][]): Map<K, V> {\n  return new Map<K, V>(concat(...iter.map(ea => f(ea))))\n}\n\nexport function compactMap<K, V>(\n  m: Iterable<Maybe<[Maybe<K>, Maybe<V>]>>\n): Map<K, V> {\n  const arr = compact(m).filter(([k, v]) => k != null && v != null) as [K, V][]\n  return new Map<K, V>(arr)\n}\n\nexport function toMap<T, K, V>(\n  i: Maybe<Iterable<Maybe<T>>>,\n  f: (entry: T) => Maybe<[Maybe<K>, Maybe<V>]>\n): Map<K, V> {\n  return compactMap(compact(i).map(f))\n}\n\nexport async function toMapAsync<T, K, V>(\n  iterable: Maybe<Iterable<Maybe<T>>>,\n  f: (entry: T) => MaybePromiseMaybe<[Maybe<K>, Maybe<V>]>\n): Promise<Map<K, V>> {\n  if (iterable == null) return new Map()\n  const entries = await Promise.all(compact(toA(iterable)).map(ea => f(ea)))\n  return compactMap(entries)\n}\n\nexport function toObj<T>(m: Map<string, T>): { [key: string]: T } {\n  const obj = {}\n  for (const [k, v] of m) {\n    obj[k] = v\n  }\n  return obj\n}\n\nexport function filter<K, V>(\n  m: Map<K, V>,\n  f: (key: K, value: V) => boolean\n): Map<K, V> {\n  return new Map<K, V>([...m.entries()].filter(([k, v]) => f(k, v)))\n}\n\n/**\n * Only retain the entries in m where f() returns true.\n */\nexport function filterInPlace<K, V>(\n  m: Map<K, V>,\n  retainIfTrue: (key: K, value: V) => boolean\n): void {\n  ;[...m.entries()].forEach(([k, v]) => retainIfTrue(k, v) || m.delete(k))\n}\n\nexport function pickKeys<K, V>(m: Map<K, V>, keys: K[]): Map<K, V> {\n  return filter(m, k => keys.indexOf(k) >= 0)\n}\n\n/**\n * Return the first value associated to the key that matches the given predicate\n */\nexport function getLike<K, V>(\n  m: Map<K, V>,\n  predicate: (k: K) => boolean\n): Maybe<V> {\n  return map(\n    [...m.entries()].find(([k]) => predicate(k)),\n    ([, v]) => v\n  )\n}\n\nexport function inverse<K, V>(m: Map<K, V>): Map<V, K> {\n  return new Map([...m.entries()].map(([k, v]) => [v, k] as [V, K]))\n}\n", "import _p from \"process\"\nimport { arrayEql, isEmpty, isNotEmpty, sortBy, uniq } from \"../fe/Array\"\nimport { notBlank } from \"../fe/Blank\"\nimport { secondMs } from \"../fe/Date\"\nimport { stringify } from \"../fe/JSON\"\nimport { lazy } from \"../fe/Lazy\"\nimport { orElse } from \"../fe/Maybe\"\nimport { PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { gt0, toInt } from \"../fe/Number\"\nimport { onlyReqValued } from \"../fe/Object\"\nimport { thenTap } from \"../fe/Promise\"\nimport { toA } from \"../fe/toA\"\nimport { toS } from \"../fe/toS\"\nimport { ending } from \"./async/Endable\"\nimport { thenMap } from \"./async/Promise\"\nimport { stdout, stdoutResult } from \"./child/ChildProcess\"\nimport { parseFixed } from \"./Fixed\"\nimport { wmic } from \"./fs/PathTo\"\nimport { mkLogger } from \"./Logger\"\nimport { start } from \"./NodeEnv\"\nimport { isWin } from \"./Platform\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\nimport { pwshJsonDate, wmiDate } from \"./WinDate\"\n\nexport interface ProcEntry {\n  pid: number\n  start: Date\n  cmd: string\n}\n\nconst logger = lazy(() => mkLogger(\"Ps\"))\n\nfunction isProcEntry(pe: any): pe is ProcEntry {\n  return pe != null && gt0(pe.pid) && pe.start != null && notBlank(pe.cmd)\n}\n\nexport async function ps(): Promise<ProcEntry[]> {\n  const procs = await (isWin ? psWin() : psPosix())\n  return orElse(\n    sortBy(procs.filter(isProcEntry), ea => ea.pid),\n    []\n  )\n}\n\nexport async function pidInfo(pid: number): PromiseMaybe<ProcEntry> {\n  return thenMap(pidInfos([pid]), arr => toA(arr).find(ea => ea.pid === pid))\n}\n\nexport async function existingPids(pids: number[]): PromiseMaybe<number[]> {\n  if (isEmpty(pids) || arrayEql([_p.pid], pids)) return toA(pids)\n  return thenMap(pidInfos(pids), arr => arr.map(ea => ea.pid))\n}\n\nexport async function notExistingPids(pids: number[]): PromiseMaybe<number[]> {\n  if (isEmpty(pids)) return []\n  return thenMap(existingPids(pids), arr => {\n    const alive = [_p.pid, ...arr]\n    return pids.filter(ea => !alive.includes(ea))\n  })\n}\n\nexport async function pidInfos(pids: number[]): PromiseMaybe<ProcEntry[]> {\n  const arr = toA(pids).filter(gt0)\n  if (isEmpty(arr)) throw new Error(\"Invalid pids: \" + stringify(pids))\n\n  return thenTap(\n    thenMap(isWin ? pidInfoWin(arr) : pidInfoPosix(arr), infos =>\n      infos.filter(ea => isProcEntry(ea) && arr.includes(ea.pid))\n    ),\n    result => logger().debug(\"pidInfo()\", { pids: arr, result })\n  )\n}\n\nfunction win2pe(arr: any[]): ProcEntry[] {\n  return arr.map((entry: any) => ({\n    pid: entry.Id,\n    start: pwshJsonDate(entry.StartTime),\n    cmd: entry.ProcessName\n  })) as ProcEntry[]\n}\n\nconst PsWinCmd = \"Get-Process\"\nconst PsWinSelectObj = \"| Select-Object -Property Id,ProcessName,StartTime\"\n\nasync function psWin(): Promise<ProcEntry[]> {\n  if (PowerShell.instance().ended) return psWinWmic()\n  const result = await PowerShell.instance().executeJsonToA(\n    [PsWinCmd, PsWinSelectObj].join(\" \")\n  )\n  return result == null ? psWinWmic() : win2pe(result)\n}\n\nfunction pidToS(pids: number[]): string {\n  return uniq([...pids.filter(gt0), _p.pid]).join(\",\")\n}\n\nasync function pidInfoWin(pids: number[]): PromiseMaybe<ProcEntry[]> {\n  if (ending() || PowerShell.instance().ended) return psWinWmic(pids)\n  const cmd = [\n    PsWinCmd,\n    \"-Id\",\n    // PowerShell wants the IDs joined by comma:\n    pidToS(pids),\n    \"-ErrorAction SilentlyContinue\", // I expect it not to find some pids\n    PsWinSelectObj\n  ].join(\" \")\n  return thenMap(PowerShell.instance().executeJsonToA(cmd), ea => win2pe(ea))\n}\n\nconst stdoutOpts = {\n  maxBuffer: 1024 * 1024, // windows process lists can be enormous\n  timeout: 15 * secondMs, // ps sometimes takes a long time\n  ignoreExitCode: true,\n  ignoreStderr: true\n}\n\nconst headers: (\"CommandLine\" | \"CreationDate\" | \"ProcessId\")[] = [\n  \"CommandLine\",\n  \"CreationDate\",\n  \"ProcessId\"\n]\n\n// NOTE: only used if powershell is shut down\nexport async function psWinWmic(pids?: number[]): Promise<ProcEntry[]> {\n  const args = [\"process\"]\n  if (isNotEmpty(pids)) {\n    // wmic wants multiple PIDs as or clauses, like\n    // wmic process where \"ProcessId=11308 or ProcessId=9416\"\n    const processIdClause = uniq([...pids.filter(gt0), _p.pid])\n      .map(ea => `ProcessId=${ea}`)\n      .join(\" or \")\n    args.push(\"where\", processIdClause)\n  }\n  args.push(\"get\", headers.join(\",\"))\n  const result = await stdoutResult(wmic(), args, stdoutOpts)\n  const results = onlyReqValued(\n    parseFixed(headers, result.result).map(ea => ({\n      pid: toInt(ea.ProcessId, { defaultValue: -1 })!,\n      start: wmiDate(ea.CreationDate),\n      cmd: toS(ea.CommandLine)\n    }))\n  )\n  if (!results.find(ea => ea.pid === _p.pid)) {\n    results.push({\n      pid: _p.pid,\n      start: new Date(start),\n      cmd: \"node \" + _p.title\n    })\n  }\n  return results\n}\n\nfunction psStdout2ProcEntry(result: string): ProcEntry[] {\n  return parseFixed(\n    [\"PID\", { greedyLeft: true, text: \"STARTED\" }, \"COMMAND\"],\n    result\n  ).map(ea => ({\n    pid: toInt(ea.PID, { defaultValue: -1 })!,\n    start: new Date(ea.STARTED),\n    cmd: toS(ea.COMMAND)\n  }))\n}\n\nasync function psPosix(): Promise<ProcEntry[]> {\n  return psStdout2ProcEntry(\n    await stdout(\"ps\", [\"-ewwwo\", \"pid,lstart,command\"], stdoutOpts)\n  )\n}\n\n/**\n * @param pid the pid to look for\n * @return an array of either just this process, or the process and the requested pid.\n */\nasync function pidInfoPosix(pids: number[]): Promise<ProcEntry[]> {\n  const r = await stdoutResult(\n    \"ps\",\n    // we include the current pid to prevent either `ps` or the fixed parser\n    // from grumping at us:\n    [\"-p\", pidToS(pids), \"-wwwo\", \"pid,lstart,command\"],\n    {\n      ...stdoutOpts,\n      ignoreExitCode: true\n    }\n  )\n  return psStdout2ProcEntry(r.result)\n}\n", "import { toS } from \"../fe/toS\"\n\nexport type IndexedString = [string, number]\n\n/**\n * Given a RegExp and string, return all first-capture-groups and their starting\n * index.\n */\nexport function captures(regex: RegExp, str: string): IndexedString[] {\n  const result: IndexedString[] = []\n  let m: RegExpExecArray | null\n  while ((m = regex.exec(str)) != null) {\n    // This is necessary to avoid infinite loops with zero-width matches\n    if (m.index === regex.lastIndex) {\n      regex.lastIndex++\n    } else {\n      result.push([m[1], m.index])\n    }\n  }\n  return result\n}\n\nexport function escapeRegExp(s: string) {\n  return toS(s).replace(/[-.,\\\\^$*+?()|[\\]{}]/g, \"\\\\$&\")\n}\n\nexport function matchQuotes(s: string) {\n  return s.replace(/[\u2018\u2019']/g, \"[\u2018\u2019']\").replace(/[\u201C\u201D\u201E\u201D\u00AB\u00BB\u3003\"]/g, `[\u201C\u201D\u201E\u201D\u00AB\u00BB\u3003\"]`)\n}\n\nexport function joinPatterns(arr: string[], flags?: string): RegExp {\n  const result = []\n  for (const ea of arr) {\n    try {\n      new RegExp(ea)\n      result.push(ea)\n    } catch {\n      result.push(escapeRegExp(ea))\n    }\n  }\n  return new RegExp(result.join(\"|\"), flags)\n}\n", "import { count, filterInPlace, range, sortBy } from \"../fe/Array\"\nimport { blank, notBlank } from \"../fe/Blank\"\nimport { lazy } from \"../fe/Lazy\"\nimport { map, orElse } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { times } from \"../fe/Number\"\nimport { fromEntries, values } from \"../fe/Object\"\nimport { toA } from \"../fe/toA\"\nimport { toS } from \"../fe/toS\"\nimport { mkLogger } from \"./Logger\"\nimport { escapeRegExp } from \"./RegExp\"\nimport { diff } from \"./Set\"\nimport { padReplace } from \"./String\"\n\nexport interface Header<T> {\n  text: string & keyof T\n  greedyLeft?: boolean\n}\n\nclass IndexedHeader<T> {\n  readonly text: string & keyof T\n  readonly greedyLeft: boolean\n  indexOf?: number\n  leftIdx?: number\n  rightIdx?: number\n  constructor(readonly h: Header<T> | (string & keyof T)) {\n    this.text = orElse(h[\"text\"], toS(h))\n    this.greedyLeft = orElse(h[\"greedyLeft\"], false)\n  }\n\n  toEntry(row: string): [string, string] {\n    return [this.text, row.substring(this.leftIdx!, this.rightIdx).trim()]\n  }\n}\n\nconst logger = lazy(() => mkLogger(\"Fixed\"))\n\nexport type Headers<T> = (Header<T> | (string & keyof T))[]\n\n/**\n * Parse fixed-width input into an array of objects\n */\nexport function parseFixed<T>(\n  headers: Headers<T>,\n  table: string,\n  warnIfMissingHeaders = true\n): T[] {\n  return new Fixed(headers, table, warnIfMissingHeaders).entries\n}\n\nexport class Fixed<T> {\n  readonly headers: IndexedHeader<T>[]\n  readonly headerRow: string\n  readonly rows: string[]\n  readonly col2blanks: Map<number, number>\n  readonly entries: T[]\n\n  constructor(\n    headers: Headers<T>,\n    table: string,\n    readonly warnIfMissingHeaders = true\n  ) {\n    const rows = table.split(/[\\r\\n]{1,2}/)\n    this.headerRow = rows[0]\n    this.rows = rows.slice(1)\n    const maxrowlen = Math.max(...this.rows.map(ea => ea.length))\n    this.col2blanks = new Map(\n      times(\n        maxrowlen,\n        col => [col, count(this.rows, ea => blank(ea[col]))] as [number, number]\n      )\n    )\n    this.headers = this.extractHeaders(headers.map(ea => new IndexedHeader(ea)))\n    this.entries = this.rows\n      .map(row => this.headers.map(h => h.toEntry(row)))\n      .map(arr => fromEntries(arr))\n      // Remove rows that have all blank values:\n      .filter(row => values(row).some(notBlank))\n  }\n\n  private extractHeaders(headers: IndexedHeader<T>[]): IndexedHeader<T>[] {\n    let headerLine = this.headerRow\n    // We only want to find each header once.\n    // First order the headers by length, desc, so we find longest matches first:\n    sortBy(headers, ea => -ea.text.length)\n    // logger().trace(\"extractHeaders()\", headers)\n    // then for each header, remove the text from the headerline as we find them\n    // so we have no header index collisions for substring matches:\n    headers.forEach(ea => {\n      const re = new RegExp(`\\\\b${escapeRegExp(ea.text)}\\\\b`, \"i\")\n      const match = re.exec(headerLine)\n      if (match == null) {\n        if (this.warnIfMissingHeaders)\n          logger().warn(\"extractHeaders(): Failed to find header!\", {\n            re,\n            headerLine\n          })\n      } else {\n        ea.indexOf = match.index\n        headerLine = padReplace(headerLine, match.index, ea.text.length, \" \")\n      }\n    })\n    const present = headers.filter(ea => ea.indexOf != null)\n    const byAppearance = sortBy(present, ea => ea.indexOf!)\n    // logger().trace(\"extractHeaders()\", { byAppearance })\n\n    // OK, the left index is the leftmost blank column as the left idx.\n    byAppearance.forEach((header, idx) => {\n      const from = header.indexOf!\n      const prior = byAppearance[idx - 1]\n      // length - 1 because end is exclusive\n      const to = idx === 0 ? 0 : prior.indexOf! + prior.text.length - 1\n      const [l, r] = header.greedyLeft ? [to, from] : [from, to]\n      header.leftIdx = map(this.firstBlankColumn(l, r), ea => ea + 1)\n      if (idx === 0 && header.leftIdx == null) {\n        header.leftIdx = 0\n      }\n      // logger().trace(\"extractHeaders(): finding leftIdx\", { from, to, header })\n      if (header.leftIdx == null) {\n        logger().warn(\n          \"no blank column for \" +\n            header.text +\n            \" between \" +\n            from +\n            \" and \" +\n            to\n        )\n      }\n    })\n    filterInPlace(byAppearance, ea => ea.leftIdx != null)\n\n    // We don't need to set the rightId of the last header, so slice(0, -1):\n    byAppearance.slice(0, -1).forEach((header, idx) => {\n      const next = byAppearance[idx + 1]\n      header.rightIdx = next.leftIdx! - 1\n    })\n    const missingHeaders = toA(\n      diff(\n        headers.map(ea => ea.text),\n        byAppearance.map(ea => ea.text)\n      )\n    )\n    if (missingHeaders.length > 0) {\n      logger().warn(\"Missing headers\", { missingHeaders })\n    }\n    return byAppearance\n  }\n\n  /**\n   * @param fromIdx inclusive\n   * @param toIdx exclusive\n   */\n  private firstBlankColumn(fromIdx: number, toIdx: number): Maybe<number> {\n    return range(fromIdx, toIdx).find(\n      idx => this.col2blanks.get(idx) === this.rows.length\n    )\n  }\n}\n", "// import { env } from \"process\"\n\n// import { compactBlanks } from \"../../fe/Array\"\n// import { firstTruePromise } from \"../async/Promise\"\n// import { stdout } from \"../child/ChildProcess\"\n// import { secondMs } from \"../date/Date\"\n// import { isWin } from \"../settings/Settings\"\n// import { mkLogger } from \"../Logger\"\n// import { BaseFile } from \"./BaseFile\"\n// import { map } from \"../../fe/Maybe\"\n\n// /**\n//  * PATHs on Windows seem to be fairly regularly screwed up. Try to find the\n//  * given system utility\n//  */\n// export async function pathTo(\n//   binaryName: string,\n//   testArgs: string[],\n//   systemrootSubpath: string[] = isWin ? [\"System32\"] : []\n// ): Promise<string> {\n//   const logger = mkLogger(\"pathTo(\" + binaryName + \")\")\n//   try {\n//     await stdout(binaryName, testArgs, { timeout: 10 * secondMs })\n//     logger.info(\"found in the PATH\")\n//     return binaryName\n//   } catch (err) {\n//     logger.warn(\"missing from PATH, I'll try SYSTEMROOT.\" + err)\n//   }\n//   const dirs = compactBlanks(\n//     isWin\n//       ? [env.SYSTEMROOT, \"C:\\\\Windows\"]\n//       : [\"/bin\", \"/usr/bin\", \"/sbin\", \"/usr/sbin\"]\n//   )\n//   const path = await firstTruePromise(\n//     ea => ea.executable(),\n//     ...dirs.map(ea => () =>\n//       BaseFile.for(ea).join(...systemrootSubpath, binaryName)\n//     )\n//   )\n//   if (path == null) {\n//     logger.error(\"missing! (looked in \" + dirs + \")\")\n//     throw new Error(\"Cannot find required system process '\" + binaryName + \"'.\")\n//   }\n\n//   try {\n//     await stdout(path.nativePath, testArgs, { timeout: 10 * secondMs })\n//     return path.nativePath\n//   } catch (err) {\n//     logger.error(path + \" doesn't seem to be valid\")\n//     throw new Error(\n//       \"Cannot find required system process 'fsutil' (looked in SYSTEMROOT)\"\n//     )\n//   }\n// }\n\n// TODO: INLINE\n\nexport const wmic = () => \"wmic\"\nexport const fsutil = () => \"fsutil\"\nexport const nslookupWin = () => \"nslookup\"\nexport const pingWin = () => \"ping\"\nexport const arpWin = () => \"arp\"\n\n// export const wmic = lazy(() => pathTo(\"wmic\", [\"OS\", \"GET\", \"localdatetime\"], [\"System32\", \"wbem\"]) )\n// export const fsutil = lazy(() => pathTo(\"fsutil\", []))\n// export const nslookupWin = lazy(() => pathTo(\"nslookup\", [\"127.0.0.1\"]))\n// export const pingWin = lazy(() => pathTo(\"ping\", [\"-n\", \"1\", \"localhost\"]))\n// export const arpWin = lazy(() => pathTo(\"arp\", [\"-a\"]))\n", "import { dayMs, minuteMs } from \"../fe/Date\"\nimport { allDefined } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { toInt } from \"../fe/Number\"\nimport { opt } from \"../fe/Opt\"\nimport { within } from \"./Number\"\n\nconst wmi = /((?:19|20)\\d\\d)([01]\\d)([0123]\\d)([012]\\d)([012345]\\d)([012345]\\d)\\.(\\d{6})([+-]\\d{3})?/\n/**\n * yyyymmddHHMMSS.mmmmmmsUUU or 20190415124112.947119-420\n *\n * @see https://msdn.microsoft.com/en-us/library/aa387237(v=vs.85).aspx\n */\nexport function wmiDate(s: string): Maybe<Date> {\n  const m = wmi.exec(s)\n  if (m == null) return\n  const arr = m.slice(1, 8).map(ea => toInt(ea))\n  if (!allDefined(arr)) return undefined\n  const [year, mon, day, hour, min, sec, micros] = arr as number[]\n  const offset = toInt(m[8], { defaultValue: 0 })!\n\n  // console.dir({ s, m, year, mon, day, hour, min, sec, micros, offset })\n  return new Date(\n    Date.UTC(year, mon - 1, day, hour, min, sec, micros / 1000) -\n      offset * minuteMs\n  )\n}\n\nconst WinDateRe = /Date\\((\\d+)\\)/\n\n/**\n * PowerShell renders Dates in JSON structures as \"/Date(1552014999676)/\"\n */\nexport function pwshJsonDate(s: string): Maybe<Date> {\n  return opt(s)\n    .flatMap(ea => WinDateRe.exec(ea))\n    .flatMap(ea => ea[1])\n    .flatMap(toInt)\n    .filter(ea => within(0, Date.now() + dayMs, ea))\n    .map(ea => new Date(ea))\n    .get()\n}\n", "import { resolve } from \"path\"\nimport { env } from \"process\"\nimport { notBlankOr } from \"../fe/Blank\"\nimport { appData } from \"./AppData\"\nimport { AppName } from \"./AppName\"\n\n/**\n * @return PS_CONFIG_DIR or ${appData()}/PhotoStructure\n */\nexport function userData() {\n  return notBlankOr(env.PS_CONFIG_DIR, () =>\n    resolve(appData(), AppName().toLowerCase())\n  )\n}\n", "import { strEnum, StrEnumKeys } from \"../fe/StrEnum\"\n\n// From https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.processpriorityclass?view=netframework-4.8\n\n// AboveNormal Specifies that the process has priority higher than Normal but\n// lower than High.\n\n// BelowNormal Specifies that the process has priority above Idle but below\n// Normal.\n\n// High Specifies that the process performs time-critical tasks that must be\n// executed immediately, such as the Task List dialog, which must respond\n// quickly when called by the user, regardless of the load on the operating\n// system. The threads of the process preempt the threads of normal or idle\n// priority class processes. Use extreme care when specifying High for the\n// process's priority class, because a high priority class application can use\n// nearly all available processor time.\n\n// Idle Specifies that the threads of this process run only when the system is\n// idle, such as a screen saver. The threads of the process are preempted by the\n// threads of any process running in a higher priority class. This priority\n// class is inherited by child processes.\n\n// Normal Specifies that the process has no special scheduling needs.\n\nexport const PriorityClasses = strEnum(\n  \"AboveNormal\",\n  \"Normal\",\n  \"BelowNormal\",\n  \"Idle\"\n)\n\nexport type PriorityClass = StrEnumKeys<typeof PriorityClasses>\n\nexport const NiceLevel = Object.freeze({\n  AboveNormal: -1,\n  Normal: 0,\n  BelowNormal: 9,\n  Idle: 19\n})\n", "import { Maybe } from \"../fe/MaybeTypes\"\nimport { tap } from \"../fe/Object\"\n\nexport class TTLSet<T> implements Set<T> {\n  readonly [Symbol.toStringTag]: \"Set\"\n  private readonly expireListeners: ((k: T) => void)[] = []\n\n  // Maps entries to insertion time values. Entries should expire after ttlMs.\n  private readonly delegate = new Map<T, number>()\n\n  constructor(readonly ttlMs: number) {}\n\n  get size(): number {\n    this.vacuum()\n    return this.delegate.size\n  }\n\n  add(value: T, ttlMs: number = this.ttlMs): this {\n    this.delegate.set(value, Date.now() + (ttlMs - this.ttlMs))\n    return this\n  }\n\n  addIfMissing<R>(value: T, onMissing: () => R): Maybe<R> {\n    const prior = this.delegate.get(value)\n    if (prior == null || this.isEntryExpired(value, prior)) {\n      this.add(value)\n      return onMissing()\n    } else {\n      return\n    }\n  }\n\n  clear(): this {\n    this.delegate.clear()\n    return this\n  }\n\n  delete(value: T): boolean {\n    return this.delegate.delete(value)\n  }\n\n  forEach(callbackfn: (value: T, index: T, set: Set<T>) => void): void {\n    for (const [value, ctime] of this.delegate) {\n      if (!this.isEntryExpired(value, ctime)) {\n        callbackfn(value, value, this)\n      }\n    }\n  }\n\n  has(value: T): boolean {\n    return !this.isEntryExpired(value, this.delegate.get(value))\n  }\n\n  readonly keys = this.values.bind(this)\n\n  values(): IterableIterator<T> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<T> {\n      for (const [k, v] of self.delegate.entries()) {\n        if (!self.isEntryExpired(k, v)) {\n          yield k\n        }\n      }\n    }\n    return iter()\n  }\n\n  entries(): IterableIterator<[T, T]> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    function* iter(): IterableIterator<[T, T]> {\n      for (const [k, v] of self.delegate.entries()) {\n        if (!self.isEntryExpired(k, v)) {\n          yield [k, k]\n        }\n      }\n    }\n    return iter()\n  }\n\n  toA(): T[] {\n    this.vacuum()\n    return [...this.delegate.keys()]\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values()\n  }\n\n  on(_event: \"expire\", listener: (k: T) => void) {\n    this.expireListeners.push(listener)\n  }\n\n  /**\n   * ctime is the create time associated to the key.\n   */\n  private isEntryExpired(key: T, ctime?: number): boolean {\n    return tap(ctime == null || ctime + this.ttlMs <= Date.now(), expired => {\n      if (ctime != null && expired) {\n        this.expireListeners.forEach(ea => ea(key))\n        this.delegate.delete(key)\n      }\n    })\n  }\n\n  /**\n   * remove all expired entries\n   */\n  private vacuum() {\n    this.delegate.forEach((entry: number, key: T) => {\n      this.isEntryExpired(key, entry)\n    })\n  }\n}\n", "import { minuteMs, secondMs } from \"../fe/Date\"\nimport { later } from \"../fe/Delay\"\nimport { lazy } from \"../fe/Lazy\"\nimport { orElse } from \"../fe/Maybe\"\nimport { toS } from \"../fe/toS\"\nimport { stdoutResult } from \"./child/ChildProcess\"\nimport { onClearCache } from \"./event/EventEmitter\"\nimport { mkLogger } from \"./Logger\"\nimport { mapGt0 } from \"./Number\"\nimport { isWin } from \"./Platform\"\nimport { NiceLevel, PriorityClass, PriorityClasses } from \"./PriorityClass\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\nimport { Settings } from \"./settings/Settings\"\nimport { TTLSet } from \"./TTLSet\"\n\nconst logger = lazy(() => mkLogger(\"Renice\"))\n\nlater(() => onClearCache(() => reniced.prior()?.clear()))\n\nconst reniced = lazy(() => new TTLSet<number>(minuteMs))\n\nexport async function renice(pid: number) {\n  if (reniced().has(pid)) return\n  reniced().add(pid)\n\n  // both the batch cluster observer and child services renice, which makes sync-file get\n  // double-renice-d. That's twice as nice as it needs to be.\n  const validPc = Settings.processPriority.valueOrDefault as PriorityClass\n\n  return mapGt0(pid, async () => {\n    try {\n      await (isWin\n        ? reniceWin(pid, validPc)\n        : renicePosix(pid, orElse(NiceLevel[validPc], NiceLevel.BelowNormal)))\n      logger().info(\"Renice pid \" + pid + \" to \" + validPc)\n    } catch (err) {\n      // Probably because the process already ended:\n      logger().info(\"Failed to renice pid \" + pid + \"\", err)\n      return\n    }\n  })\n}\n\nasync function reniceWin(pid: number, pc: PriorityClass) {\n  return mapGt0(pid, _pid =>\n    PriorityClasses.mapValid(pc, _pc =>\n      PowerShell.instance().execute(\n        `(Get-Process -Id ${pid}).PriorityClass = \"${pc}\"`,\n        ea => ea\n      )\n    )\n  )\n}\n\nasync function renicePosix(pid: number, nice = 19) {\n  return stdoutResult(\"renice\", [nice, \"-p\", pid].map(toS), {\n    timeout: 10 * secondMs,\n    isIgnorableError: () => true,\n    ignoreExitCode: true,\n    maxRetries: 0\n  })\n}\n", "import { SpawnOptions } from \"child_process\"\nimport _p from \"process\"\nimport { later } from \"../../fe/Delay\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport {\n  compactValues,\n  filter,\n  omit,\n  sortedKeys,\n  StringValued,\n  values\n} from \"../../fe/Object\"\nimport { childProcLocale } from \"../Locale\"\nimport { nodeEnv } from \"../NodeEnv\"\nimport { mapEntries } from \"../Object\"\nimport { isDocker, isElectron } from \"../Platform\"\nimport { Setting } from \"../settings/Setting\"\nimport {\n  pathWithDefaults,\n  persistedSettings,\n  Settings\n} from \"../settings/Settings\"\n\nconst SettingsKeys = lazy(() => new Set(values(Settings).map(ea => ea.key)))\n\nexport function psenv(): StringValued {\n  const set = SettingsKeys()\n  return sortedKeys(filter(_p.env, k => k === \"NODE_ENV\" || set.has(k)))\n}\n\nexport const settingsForChildProcs = lazy(\n  () => persistedSettings().filter(ea => ea.hasValue()) as Setting<any>[]\n)\n\nfunction onSettingsChange() {\n  settingsForChildProcs.unset()\n}\n\nconst sensitiveEnvRE = lazy(() => {\n  try {\n    return new RegExp(Settings.sensitiveEnvRegExp.valueOrDefault, \"i\")\n  } catch (err) {\n    console.error(\n      `Invalid setting for \"sensitiveEnvRegExp\": ${err}. Using default value.`\n    )\n    return new RegExp(Settings.sensitiveEnvRegExp.defaultValue, \"i\")\n  }\n})\n\nlater(() => {\n  Settings.sensitiveEnvRegExp.addListener(() => {\n    sensitiveEnvRE.unset()\n    sanitizedEnv.unset()\n  })\n\n  for (const ea of persistedSettings()) {\n    ea.addListener(onSettingsChange)\n  }\n})\n\nexport const sanitizedEnv = lazy(() => {\n  const re = sensitiveEnvRE()\n  return mapEntries(_p.env, (k, v) => (re.exec(k) != null ? undefined : v))\n})\n\nexport function childEnvSettings() {\n  return settingsForChildProcs().reduce((prev, ea) => ea.maybeAddToEnv(prev), {\n    NODE_ENV: nodeEnv, // < shouldn't be necessary, but ensures it's set properly\n    // Pass on the \"isDocker\" flag:\n    ...(isDocker() ? { PS_IS_DOCKER: \"1\" } : {}),\n    // Pass on the \"isElectron\" flag:\n    ...(isElectron ? { ELECTRON_RUN_AS_NODE: \"1\", PS_IS_ELECTRON: \"1\" } : {})\n  })\n}\n\nexport type SpawnOptionsWithLocale = SpawnOptions & { forceCLocale?: boolean }\n\nexport function spawnOptions(maybeOpts?: SpawnOptionsWithLocale): SpawnOptions {\n  const opts: SpawnOptionsWithLocale = orElse(maybeOpts, {})\n  const forceCLocale = orElse(opts.forceCLocale, true)\n  return {\n    ...omit(opts, \"forceCLocale\"),\n    env: childEnv(opts.env, forceCLocale),\n    detached: false,\n    shell: false\n    // NOTE: don't use windowsHide: true, it doesn't work!\n  }\n}\n\nexport function childEnv(\n  overrides: Maybe<StringValued>,\n  forceCLocale: boolean\n) {\n  const e: StringValued = compactValues({\n    // Include all (non-sensitive) env values, because things like `gio` need\n    // GNOME* and DBUS* variables set:\n    ...sanitizedEnv(),\n    PATH: pathWithDefaults(),\n    ...(forceCLocale ? childProcLocale() : {}),\n    ...childEnvSettings(),\n    ...orElse(overrides, {}) // < env param wins\n  })!\n\n  // children must not log to stdout:\n  Settings.logStdout.deleteFromEnv(e)\n\n  // and only the parent should tail logs:\n  Settings.tailLogs.deleteFromEnv(e)\n\n  return e\n}\n", "import _p from \"process\"\nimport { compact } from \"../fe/Array\"\nimport { blank } from \"../fe/Blank\"\nimport { secondMs } from \"../fe/Date\"\nimport { lazy } from \"../fe/Lazy\"\nimport { firstDefined, map } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { fromEntries } from \"../fe/Object\"\nimport { thenOpt } from \"../fe/OptAsync\"\nimport { firstDefinedLater } from \"./async/Later\"\nimport { thenMap } from \"./async/Promise\"\nimport { stdout } from \"./child/ChildProcess\"\nimport { Pojo } from \"./Object\"\nimport { isMac, isPosix, isWin } from \"./Platform\"\nimport { PowerShell } from \"./pwsh/PowerShell\"\nimport { equalsIgnoreCase } from \"./String\"\n\nexport const defaultLocale = \"en\"\n\n/**\n * @see https://en.wikipedia.org/wiki/ISO_639\n */\nexport const locale = lazy(async () => {\n  return lc2locale(\n    await firstDefinedLater(\n      () => extractLocale(),\n      () => (isWin ? localeWin() : undefined),\n      () => (isMac ? localeMac() : undefined),\n      () => (isPosix ? localePosix() : undefined)\n    )\n  )\n})\n\n// See https://wiki.archlinux.org/index.php/Locale\nfunction extractLocale(env: Pojo = _p.env) {\n  return firstDefined<string>(\n    env.LC_ALL,\n    env.LC_MESSAGES,\n    env.LANG,\n    env.LANGUAGE\n  )\n}\n\n// Like \"en_US.UTF-8\"\nconst regex = /^([a-z]{2,3})(?:(?:[_-])([a-z]{2,3}))?/i\n\nexport function lc2locale(lc: Maybe<string>): string {\n  // Some people set their locale to \"C\":\n  if (blank(lc) || equalsIgnoreCase(\"c\", lc) || equalsIgnoreCase(\"posix\", lc)) {\n    return defaultLocale\n  } else {\n    // locales can be en_US or en-US. standardize on dash:\n    const m = regex.exec(lc)\n    if (m == null) return defaultLocale\n    return compact([m[1], m[2]]).join(\"-\")\n  }\n}\n\nexport function localeWin() {\n  return thenMap(\n    PowerShell.instance().executeJson(\n      \"Get-WinSystemLocale | Select-Object -Property Name\"\n    ),\n    ea => ea.Name\n  )\n}\n\nconst opts = {\n  timeout: 10 * secondMs\n}\n\nexport function localeMac() {\n  return thenOpt(\n    stdout(\"defaults\", [\"read\", \"-globalDomain\", \"AppleLocale\"], opts)\n  )\n    .flatMap(lc2locale)\n    .get()\n}\n\nconst nonEmpty = /^([a-z_]+)\\s*=\\s*\"(.+)\"$/i\n\nexport function localePosix() {\n  return thenOpt(stdout(\"locale\", [], opts))\n    .flatMap(result =>\n      result.split(\"\\n\").map(\n        ea => map(ea.match(nonEmpty), m => [m[1], m[2]] as [string, string]) // < SITS: TS\n      )\n    )\n    .flatMap(fromEntries)\n    .flatMap(extractLocale)\n    .flatMap(lc2locale)\n    .get()\n}\n\nexport function childProcLocale() {\n  return {\n    LANG: \"C\",\n    LC_ALL: \"C\"\n  }\n}\n", "import { map, orElse } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\n\nexport type SyncOrAsync<T> = T | Promise<T>\n\nexport type MaybeSyncOrAsync<T> = Maybe<SyncOrAsync<Maybe<T>>>\nexport type MaybeNullSyncOrAsync<T> = Maybe<SyncOrAsync<MaybeNull<T>>>\nexport type MaybeOptAsync<T> =\n  | MaybeSyncOrAsync<T>\n  | Maybe<SyncOrAsync<OptAsync<T>>>\n\n/**\n * @see http://www.scala-lang.org/api/current/scala/Option.html\n */\nexport class OptAsync<A> {\n  constructor(private readonly a: Maybe<() => MaybeOptAsync<A>>) {}\n\n  private async _map<T>(\n    f: (a: A) => SyncOrAsync<T>,\n    ifNone: () => SyncOrAsync<T>\n  ): Promise<T> {\n    const opt = this.a != null ? await this.a() : undefined\n    const a = isOptAsync<A>(opt) ? await opt.get() : opt\n    return a != null ? f(a) : ifNone()\n  }\n\n  /**\n   * @return true if the option is an instance of Some, false otherwise\n   */\n  async isDefined() {\n    return this._map(\n      () => true,\n      () => false\n    )\n  }\n\n  /**\n   * @return true if the option is None, false otherwise\n   */\n  async isEmpty(): Promise<boolean> {\n    return this._map(\n      () => false,\n      () => true\n    )\n  }\n\n  /**\n   * @return the option's value.\n   */\n  async get(): Promise<Maybe<A>> {\n    return this._map(\n      ea => ea,\n      () => undefined as any\n    )\n  }\n\n  /**\n   * @return the option's value.\n   */\n  async getRequired(): Promise<A> {\n    return this._map(\n      ea => ea,\n      () => {\n        throw new Error(\"unexpectedly undefined\")\n      }\n    )\n  }\n\n  /**\n   * @return true if this option is nonempty and the predicate `p` returns true\n   * when applied to this Option's value.\n   */\n  async exists(p: (a: A) => SyncOrAsync<boolean>): Promise<boolean> {\n    return this._map(p, () => false)\n  }\n\n  /**\n   * @return a `Some` containing the result of applying `f` to this `Option`'s value\n   * if this `Option` is nonempty.\n   */\n  map<B>(f: (a: A) => SyncOrAsync<B>): OptAsync<B> {\n    return new OptAsync<B>(async () => this._map(f, () => undefined as any))\n  }\n\n  /**\n   * @return the result of applying `f` to this `Option`'s value if this\n   * `Option` is nonempty. By supporting `undefined` or `B`, we make caller's\n   * lives a little easier--we'll wrap the result in an `Option` for you.\n   */\n  flatMap<B>(f: (a: A) => MaybeOptAsync<B>): OptAsync<B> {\n    return new OptAsync<B>(async () => this._map(f as any, () => undefined))\n  }\n\n  /**\n   * @return this `Option` if it is both nonempty\n   * and applying the predicate `p` to this `Option`'s value returns true.\n   */\n  filter(p: (a: A) => SyncOrAsync<boolean>): OptAsync<A> {\n    return new OptAsync<A>(async () =>\n      this._map(\n        async ea => ((await p(ea)) ? ea : undefined),\n        () => undefined as any\n      )\n    )\n  }\n\n  /**\n   * @return this `Option` if it is both nonempty\n   * and applying the predicate `p` to this `Option`'s value returns true.\n   */\n  catch(onError: (err: Error | any) => Maybe<SyncOrAsync<A>>): OptAsync<A> {\n    return new OptAsync<A>(() => this.get().catch(async err => onError(err)))\n  }\n\n  /**\n   * Apply the given procedure `f` to the `Option`'s value\n   * if this `Option` is nonempty.\n   * @return this (for fluent or chaining calls)\n   */\n  forEach(f: (a: A) => void): OptAsync<A> {\n    return new OptAsync<A>(async () => {\n      const a = await this.get()\n      await map(a, f)\n      return a\n    })\n  }\n\n  /**\n   * @return this `Option`'s value if this `Option` is nonempty,\n   * otherwise return the result of evaluating `f`.\n   */\n  async getOrElse(f: () => SyncOrAsync<A>): Promise<A> {\n    return orElse(await this.get(), f)\n  }\n\n  /**\n   * @return this `Option`'s value if this `Option` is nonempty,\n   * otherwise return the result of evaluating `f`.\n   */\n  orElse(f: () => SyncOrAsync<Maybe<A | OptAsync<A>>>): OptAsync<A> {\n    return new OptAsync<A>(async () => {\n      const a = await this.get()\n      const result = a == null ? await f() : a\n      return isOptAsync(result) ? result.get() : result\n    })\n  }\n}\n\nfunction isOptAsync<A>(a: any): a is OptAsync<A> {\n  return a instanceof OptAsync\n}\n\nexport function thenOpt<T>(o: MaybeOptAsync<T>): OptAsync<T> {\n  return isOptAsync(o) ? o : new OptAsync(() => o)\n}\n", "import { isTrue } from \"../../fe/Boolean\"\nimport { Maybe, MaybePromiseMaybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { MaybeSyncOrAsync } from \"../../fe/OptAsync\"\n\nexport interface Later<T> {\n  (): Promise<T>\n}\n\nexport namespace Later {\n  export const and = async (\n    ...arr: Later<Maybe<boolean>>[]\n  ): Promise<boolean> => {\n    for (const ea of arr) {\n      if (!isTrue(await ea())) return false\n    }\n    return true\n  }\n  export const or = async (\n    ...arr: Later<Maybe<boolean>>[]\n  ): Promise<boolean> => {\n    for (const ea of arr) {\n      if (isTrue(await ea())) return true\n    }\n    return false\n  }\n}\n\nexport interface LaterMaybe<T> {\n  (): PromiseMaybe<T>\n}\n\nexport interface MaybeLaterMaybe<T> {\n  (): MaybePromiseMaybe<T>\n}\n\n/**\n * Wrap a Later to get a promise that will be resolved or rejected when the\n * returned thunk is called.\n */\nexport function laterPromise<T>(\n  later: () => T | Promise<T>\n): { promise: Promise<T>; later: Later<T> } {\n  // We could use Deferred here, but I want to minimize cross-dependencies.\n  let resolve: (t: T | Promise<T>) => void\n  let reject: (error: any) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return {\n    promise,\n    later: async () => {\n      try {\n        const r = await later()\n        resolve(r)\n        return r\n      } catch (err) {\n        reject(err)\n        throw err\n      }\n    }\n  }\n}\n\nexport async function firstDefinedLater<T>(\n  ...arr: Maybe<() => MaybeSyncOrAsync<T>>[]\n): PromiseMaybe<T> {\n  if (arr == null) return\n  for (const ea of arr) {\n    if (ea == null) continue\n    const result = await ea()\n    if (result != null) return result\n  }\n  return\n}\n", "import { isError, shortStack } from \"../../fe/Error\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { isObject } from \"../../fe/ObjectType\"\nimport { isPrimitive, isPrimitiveArray } from \"../../fe/Primitive\"\nimport { mapEntries } from \"../Object\"\n\nexport const ContextLines = 24\n\n/**\n * Prepare a log entry's `meta` for serialization\n */\nexport function prepMeta(meta: any, levels = 2): any {\n  if (levels <= 0) return meta\n  if (meta == null) {\n    return undefined\n  }\n  if (isPrimitiveArray(meta)) {\n    return meta\n  }\n  if (Array.isArray(meta)) {\n    return arr2log(meta)\n  }\n  if (isPrimitive(meta)) {\n    return meta\n  }\n  if (isError(meta)) {\n    return { ...meta, stack: shortStack(meta.stack) }\n  }\n  if (isObject(meta)) {\n    return mapEntries(meta, (_, v) => prepMeta(v, levels - 1))\n  }\n\n  // Otherwise give up:\n  return meta\n}\n\n/**\n * Summarize an array to json for logging\n */\nexport function arr2log(\n  a: Maybe<any[]>,\n  transform: (t: any) => any = prepMeta\n) {\n  if (a == null) {\n    return undefined\n  } else if (a.length <= ContextLines) {\n    return a.map(transform)\n  } else {\n    return [\n      ...a.slice(0, ContextLines).map(transform),\n      `\u2026 (${a.length} total items)`\n    ]\n  }\n}\n", "import { fromEntries } from \"../../fe/Object\"\nimport { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\n\n/**\n * These are driven by the `console` API\n */\nexport const LogLevels = strEnum(\"error\", \"warn\", \"info\", \"debug\", \"trace\")\nexport type LogLevel = StrEnumKeys<typeof LogLevels>\n\nconst LevelToIndex = fromEntries(LogLevels.values.map((k, i) => [k, i]))\n\nexport function levelIndex(logLevel: string): number {\n  return LevelToIndex[logLevel] ?? LevelToIndex.trace\n}\n", "import { sortBy } from \"../../fe/Array\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { fromEntries, values } from \"../../fe/Object\"\nimport { BoundedList } from \"../BoundedList\"\nimport { LogEntry } from \"./LogEntry\"\nimport { LogLevel, LogLevels } from \"./LogLevel\"\n\nexport const SentLogLevels = lazy(() =>\n  LogLevels.values.filter(ea => ea !== LogLevels.trace)\n)\n\nconst MaxPerLevel = 48\n\n// https://github.com/Microsoft/TypeScript/issues/24220#issuecomment-449325451\ntype Level2Recent = { [l in LogLevel]: BoundedList<LogEntry> }\n\n/**\n * These are log entries that were *not* written to the log file (but will be\n * interesting if we want to \"send recent logs\".\n *\n * They are flushed to the logfile by log.error or by calling\n * writeRecentLogEntries()\n */\nconst recentLogEntriesByLevel = lazy<Level2Recent>(() =>\n  fromEntries(\n    SentLogLevels().map(ea => [ea, new BoundedList<LogEntry>(MaxPerLevel)])\n  )\n)\n\nexport function clearRecentLogEntries() {\n  values(recentLogEntriesByLevel()).forEach(ea => ea.clear())\n}\n\nexport function addRecentLogEntry(le: LogEntry) {\n  recentLogEntriesByLevel()[le.l]?.push(le)\n}\n\nexport function recentLogEntries() {\n  const arr: LogEntry[] = []\n  for (const bl of values(recentLogEntriesByLevel())) {\n    arr.push(...bl.toA())\n  }\n  return sortBy(arr, ea => ea.ts)\n}\n", "import { Logger } from \"batch-cluster\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { asError, errorToVerbose } from \"../../fe/Error\"\nimport { stringify } from \"../../fe/JSON\"\nimport { mapOr, orElse } from \"../../fe/Maybe\"\nimport { omit } from \"../../fe/Object\"\nimport { NoOp } from \"../../fe/Thunk\"\nimport { toS } from \"../../fe/toS\"\nimport {\n  isFatalError,\n  isIgnorableError,\n  isRetriableError\n} from \"../error/ErrorTypes\"\nimport { Try } from \"../Object\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { logFilter } from \"./LogFilter\"\nimport { LogLevel } from \"./LogLevel\"\nimport { prepMeta } from \"./LogMeta\"\nimport { addRecentLogEntry } from \"./RecentLogs\"\n\nexport function ms2level(elapsedMs: number, errorMs: number): LogLevel {\n  return elapsedMs >= errorMs\n    ? \"error\"\n    : elapsedMs >= errorMs / 2\n    ? \"warn\"\n    : elapsedMs >= errorMs / 4\n    ? \"info\"\n    : \"debug\"\n}\n\nexport interface SimpleLogger {\n  /**\n   * Implementations of `log` can rely on a wrapper class (probably\n   * `ContextualLogger`) to call `enabled` for any given log invocation.\n   */\n  log(level: LogLevel, context: string, msg: string, meta?: any): void\n\n  flush(): Promise<void>\n\n  end(): any\n}\n\nexport const NoOpLogger: SimpleLogger & Logger = {\n  log: NoOp,\n  flush: () => Promise.resolve(),\n  end: NoOp,\n  error: NoOp,\n  warn: NoOp,\n  info: NoOp,\n  debug: NoOp,\n  trace: NoOp\n}\n\n// TODO: MOVE TO ../../fe/Try.ts\nasync function tryAsync<T>(f: () => T | Promise<T>) {\n  try {\n    return await f()\n  } catch {\n    return\n  }\n}\n\nexport function safeLogger(logger: SimpleLogger): SimpleLogger {\n  return {\n    log: (level: LogLevel, context: string, msg: string, meta?: any) =>\n      Try(() => logger.log(level, context, msg, meta)),\n    flush: () => tryAsync(() => logger.flush()),\n    end: () => tryAsync(() => logger.end())\n  }\n}\n\nconst ctxRe = /^[a-z]*/i\n\n/**\n * Delegates to a SimpleLogger, applying filters, and exposing level-specific\n * log methods.\n */\nexport class ContextualLogger implements SimpleLogger, Logger {\n  readonly filterContext: string\n  constructor(\n    readonly context: string,\n    readonly loggers: () => SimpleLogger[]\n  ) {\n    this.filterContext = mapOr(\n      ctxRe.exec(toS(this.context)),\n      ea => ea[0],\n      () => this.context\n    )\n  }\n\n  addContext(s: string) {\n    return new ContextualLogger(this.context + s, this.loggers)\n  }\n\n  throw(\n    e: string | Error,\n    meta?: { fatal?: boolean; retriable?: boolean; ignorable?: boolean } & any\n  ): never {\n    const fatal = isFatalError(e) || meta?.fatal\n    const nonRetriable = meta?.retriable === false\n    const retriable = !nonRetriable && isRetriableError(e)\n    const ignorable = isIgnorableError(e) || meta?.ignorable\n    meta =\n      meta == null\n        ? undefined\n        : prepMeta(omit(meta, \"fatal\", \"retriable\", \"ignorable\"))\n    const err = new WrappedError({\n      cause: asError(e),\n      message: compactBlanks([\n        this.context,\n        meta == null ? undefined : stringify(meta)\n      ]).join(\" \"),\n      fatal,\n      retriable,\n      ignorable\n    })\n    this.log(ignorable === true ? \"warn\" : \"error\", errorToVerbose(e), meta)\n    throw err\n  }\n\n  tap<T>(o: { level?: LogLevel; msg: string; result: T; meta?: any }): T {\n    this.log(orElse(o.level, \"debug\"), o.msg, { result: o.result, ...o.meta })\n    return o.result\n  }\n\n  log(level: LogLevel, message: string, meta?: any): void {\n    meta = prepMeta(meta)\n    // Loggers (ConsoleLogger and LogWriter) don't check enabled.\n    if (logFilter().enabled(level, this.context)) {\n      for (const ea of this.loggers()) {\n        ea.log(level, this.context, message, meta)\n      }\n    } else {\n      if (level !== \"trace\") {\n        addRecentLogEntry({\n          ts: Date.now(),\n          l: level as any,\n          ctx: this.context,\n          msg: message,\n          meta\n        })\n      }\n    }\n  }\n\n  async flush() {\n    for (const ea of this.loggers()) {\n      await ea.flush()\n    }\n  }\n\n  async end() {\n    for (const ea of this.loggers()) {\n      await ea.end()\n    }\n  }\n\n  // Using fat arrows force the methods to stay bound to this instance:\n\n  readonly error = (msg: string, args?: any) => {\n    this.log(\"error\", msg, args)\n  }\n\n  readonly warn = (msg: string, args?: any) => {\n    this.log(\"warn\", msg, args)\n  }\n\n  readonly info = (msg: string, args?: any) => {\n    this.log(\"info\", msg, args)\n  }\n\n  readonly debug = (msg: string, args?: any) => {\n    this.log(\"debug\", msg, args)\n  }\n\n  readonly trace = (msg: string, args?: any) => {\n    this.log(\"trace\", msg, args)\n  }\n}\n", "export const DefaultLensMakes = [\n  \"7artisans\",\n  \"Bower\",\n  \"Canon\",\n  \"Carl Zeiss\",\n  \"Cosina\",\n  \"Fuji\",\n  \"Fujifilm\",\n  \"Goerz\",\n  \"Hasselblad\",\n  \"Hirox\",\n  \"Hoya\",\n  \"Konica\",\n  \"Leica\",\n  \"Leidolf\",\n  \"Lensbaby\",\n  \"Meike\",\n  \"Meopta\",\n  \"Minolta\",\n  \"Neewer\",\n  \"Nikon\",\n  \"Olympus\",\n  \"Opteka\",\n  \"Panasonic\",\n  \"Pentacon\",\n  \"Pentax\",\n  \"Ricoh\",\n  \"Rodenstock\",\n  \"Rokinon\",\n  \"Ross\",\n  \"Samsung\",\n  \"Samyang\",\n  \"Seiko\",\n  \"Sigma\",\n  \"Silor\",\n  \"Soligor\",\n  \"Sony\",\n  \"Sunpak\",\n  \"Tamron\",\n  \"Tiffen\",\n  \"Tokina\",\n  \"Topcon\",\n  \"Venus\",\n  \"Voigtl\u00E4nder\",\n  \"Wray\",\n  \"Yongnuo\",\n  \"Zhong Yi\",\n  \"Zuiko\"\n]\n", "export const SidecarExts = [\"EXIF\", \"EXV\", \"MIE\", \"XMP\"]\n", "import { delimiter } from \"path\"\nimport { env } from \"process\"\nimport {\n  compactBlankish,\n  filterInPlace,\n  flatten,\n  mapNotEmpty,\n  uniq\n} from \"../../fe/Array\"\nimport { blankish, mapNotBlank, notBlank } from \"../../fe/Blank\"\nimport { toBoolean } from \"../../fe/Boolean\"\nimport { stringify } from \"../../fe/JSON\"\nimport { map, mapOr, orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { clamp, toFloat, toInt } from \"../../fe/Number\"\nimport { StringValued } from \"../../fe/Object\"\nimport { opt } from \"../../fe/Opt\"\nimport { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\nimport { Thunk, tot } from \"../../fe/Thunk\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { eql } from \"../Eql\"\nimport { mkLogger } from \"../Logger\"\nimport { isProd } from \"../NodeEnv\"\nimport { camel2snake } from \"../StringCase\"\n\nexport function envkey(name: string): string {\n  return \"PS_\" + camel2snake(name).toUpperCase()\n}\n\n// LIMIT DEPS TO FE AND BASE CLASSES! #NODEPLOOPS\n\n// only exposed for tests\n// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\nexport const envAtStartup = opt({ ...env })\n  .map(ea => (isProd ? Object.freeze(ea) : ea))\n  .get()!\n\nexport const SettingCategories = strEnum(\n  // System settings:\n  \"Paths\",\n  \"Logging\",\n  \"Networking\",\n  \"Processes\",\n  \"Tools\",\n  \"Updates\",\n  \"Desktops\",\n  \"Volumes\",\n  // Library settings:\n  \"Db\",\n  \"HealthChecks\",\n  \"Filters\",\n  \"Previews\",\n  \"Reporting\",\n  \"Deduping\",\n  \"Sidecars\",\n  \"Sync\",\n  \"Tagging\",\n  \"Web\",\n  \"Subscriptions\"\n)\nexport type SettingCategory = StrEnumKeys<typeof SettingCategories>\n\nexport const LibraryCategories: ReadonlyArray<SettingCategory> = Object.freeze([\n  SettingCategories.Db,\n  SettingCategories.HealthChecks,\n  SettingCategories.Filters,\n  SettingCategories.Previews,\n  // desire to report errors or how many per day is OK.\n  // we include reporting in the library because their email won't change\n  SettingCategories.Reporting,\n  SettingCategories.Deduping,\n  SettingCategories.Sidecars,\n  SettingCategories.Sync,\n  SettingCategories.Tagging,\n  SettingCategories.Web,\n  SettingCategories.Subscriptions\n])\n\n// System is everything not library:\nexport const SystemCategories: ReadonlyArray<SettingCategory> = Object.freeze(\n  SettingCategories.values.filter(ea => !LibraryCategories.includes(ea))\n)\n\nexport interface BaseSettingOpts<T> {\n  readonly envAliases?: string[]\n  readonly category: SettingCategory\n  readonly description: string\n  readonly exampleValue?: Thunk<Maybe<T>>\n  readonly transient?: boolean // defaults to false\n  readonly advanced?: Thunk<boolean>\n}\n\ninterface Converters<T> {\n  readonly toEnv: (value: Maybe<T>) => Maybe<string>\n  readonly fromEnv: (value: Maybe<string>) => Maybe<T>\n}\n\nexport interface DefaultValued<T> {\n  defaultValue: T | Thunk<T>\n}\n\nexport type SettingOpts<T> = BaseSettingOpts<T> & DefaultValued<T>\n\nexport interface SavedSetting {\n  key: string\n  value: any\n}\n\nexport interface SettingListener<T> {\n  (newValue: Maybe<T>): any\n}\n\nconst notBlankToS = (s: Maybe<any>) =>\n  notBlank(s) && s !== \"undefined\" ? toS(s).trim() : undefined\n\n/**\n * Supports env-overridden preferences that can be persisted to a file.\n *\n * 1. Setting an environment variable or command-line argument must not be\n *    persisted to the settings file, as that would become the default value.\n * 2. Settings file values should not override the command-line or environment's\n *    values, as that would cause the env or CLI value to be ignored.\n *\n * SO: we have to be able to distinguish between env or cli values and persisted\n * values.\n */\nexport class Setting<T> {\n  private _name!: string\n  private _key!: string\n  private _persist = false\n  private _value: Maybe<T>\n  private readonly listeners: SettingListener<T>[] = []\n\n  constructor(readonly opts: SettingOpts<T> & Converters<T>) {}\n\n  hasValue() {\n    return this._value != null\n  }\n\n  isUnset() {\n    return !this.hasValue()\n  }\n\n  // Only for tests or temporary value setting (see LogFilter.withLogLevel)\n  getState() {\n    return { value: this._value, persist: this._persist }\n  }\n\n  setState(s: ReturnType<this[\"getState\"]>) {\n    this._persist = s.persist\n    this._value = s.value\n  }\n\n  /**\n   * Read the value from the given `pojo` or the ENV.\n   *\n   * THIS DOESN'T CHANGE ANY STATE. If you want to import from the env, use\n   * `importFromEnv`.\n   */\n  readFromEnv(pojo?: StringValued) {\n    const _env = orElse(pojo, env)\n    for (const k of [this.key, ...toA(this.opts.envAliases)]) {\n      const v = map(_env[k], ea => this.opts.fromEnv(ea))\n      if (v != null) return v\n    }\n    return\n  }\n\n  /**\n   * Should only be used directly by tests, as env shouldn't be wiggling around\n   * after a process starts.\n   */\n  importFromEnv(environment: StringValued = env): Maybe<T> {\n    if (this._persist) return\n    return map(this.readFromEnv(environment), value => {\n      // We don't need to convert it back and forth from the ENV, as we just did that:\n      // return (this._value = value)\n      return this.setValue(value)\n    })\n  }\n\n  importFromFile(value: Maybe<T>): Maybe<T> {\n    if (this.hasValue() && !this._persist) return\n    // We don't need to set persist here: only if the user changes the value.\n    return this.setValue(value)\n  }\n\n  addListener(l: SettingListener<T>) {\n    this.listeners.push(l)\n    if (this._persist) {\n      // SITS: this allows the call to addListener() reference classes or\n      // instances that haven't been parsed yet:\n      setImmediate(() => l(this.value))\n    }\n  }\n\n  removeListener(l: SettingListener<T>) {\n    filterInPlace(this.listeners, ea => ea === l)\n  }\n\n  private onChange() {\n    const v = this.value\n    this.listeners.forEach(ea => ea(v))\n  }\n\n  get name(): string {\n    return this._name\n  }\n\n  _setName(name: string) {\n    if (this._name != null) throw new Error(\"cannot set name twice\")\n    this._name = name\n    this._key = envkey(name)\n    this.importFromEnv()\n  }\n\n  get persist(): boolean {\n    return this._persist\n  }\n\n  /**\n   * This is the environment variable name for this setting:\n   */\n  get key(): string {\n    return this._key\n  }\n\n  get category(): SettingCategory {\n    return this.opts.category\n  }\n\n  get categoryType(): \"system\" | \"library\" {\n    return LibraryCategories.includes(this.category) ? \"library\" : \"system\"\n  }\n\n  get transient(): boolean {\n    return this.opts.transient === true\n  }\n\n  /**\n   * Is this setting an \"advanced\" option (and can be initially hidden)?\n   */\n  get advanced(): boolean {\n    return mapOr(\n      this.opts.advanced,\n      ea => ea(),\n      () => true\n    )\n  }\n\n  get value(): Maybe<T> {\n    return this._value\n  }\n\n  /**\n   * Set the value for the current process, and persist this value in the\n   * settings.toml.\n   */\n  set value(t: Maybe<T>) {\n    this._persist = true\n    this.setValue(t)\n  }\n\n  maybeSetValue(t: Maybe<T>) {\n    if (t != null) this.value = t\n  }\n\n  set valueAndEnv(t: Maybe<T>) {\n    this.value = t\n    this.addToEnv(env, t)\n  }\n\n  /**\n   * @return the env value encoding `this.valueOrDefault`\n   */\n  get envValueOrDefault(): Maybe<string> {\n    return this.opts.toEnv(this.valueOrDefault)\n  }\n\n  /**\n   * Set the value for the current process, but don't persist this value in the\n   * settings.toml. Should be used when the value set temporarily by environment\n   * variables.\n   */\n  set tmpValue(t: Maybe<T>) {\n    this._persist = false\n    // Allow these options to pass through to child processes:\n    this.addToEnv(env, t)\n    this.setValue(t)\n  }\n\n  set tmpValueIfUnset(t: Maybe<T>) {\n    if (this.isUnset()) this.tmpValue = t\n  }\n\n  private setValue(t: Maybe<T>) {\n    const prior = this._value\n    const toEnv = this.opts.toEnv(t)\n    const fromEnv = this.opts.fromEnv(toEnv)\n    this._value = fromEnv\n    if (!eql(prior, this._value)) this.onChange()\n    return this._value\n  }\n\n  get defaultValue(): T {\n    return tot(this.opts.defaultValue)\n  }\n\n  get exampleValue(): T {\n    return opt(this.opts.exampleValue)\n      .flatMap(ea => ea())\n      .filter(notBlank)\n      .getOrElse(() => this.defaultValue)\n  }\n\n  get valueOrDefault(): T {\n    // inlined orElse because this is called so frequently:\n    return this.value != null ? this.value : this.defaultValue\n  }\n\n  maybeAddToEnv<SV extends StringValued>(pojo?: SV, overrideValue?: T): SV {\n    const e = orElse(pojo, env)\n    // If we don't have a value, let the child take the default, or the\n    // persisted value. This fixes\n    // https://gitlab.com/photostructure/photostructure/issues/202\n    if (this.hasValue()) {\n      e[this.key] = notBlankToS(\n        this.opts.toEnv(orElse(overrideValue, this.valueOrDefault))\n      )\n    }\n    return e as SV\n  }\n\n  addToEnv<SV extends StringValued>(pojo?: SV, overrideValue?: T): SV {\n    const e = orElse(pojo, env)\n    e[this.key] = notBlankToS(\n      this.opts.toEnv(orElse(overrideValue, this.valueOrDefault))\n    )\n    return e as SV\n  }\n\n  deleteFromEnv<SV extends StringValued>(pojo?: SV): SV {\n    const e = orElse(pojo, env) as SV\n    delete e[this.key]\n    map(this.opts.envAliases, arr =>\n      arr.forEach(ea => {\n        delete e[ea]\n      })\n    )\n    return e\n  }\n\n  valueToPersist(savedValue: Maybe<T>): Maybe<T> {\n    return this._persist ? this._value : savedValue\n  }\n\n  unset() {\n    this._value = undefined\n    this._persist = false\n    this.deleteFromEnv()\n    this.onChange()\n    mkLogger(\"Settings.\" + this.name).info(\".unset()\")\n    return this\n  }\n\n  addToJSON() {\n    return {}\n  }\n\n  toJSON() {\n    return {\n      key: this.key,\n      value: this.value,\n      defaultValue: this.opts.defaultValue\n    }\n  }\n}\n\nexport class MaybeStringSetting extends Setting<Maybe<string>> {\n  constructor(\n    opts: BaseSettingOpts<Maybe<string>> & Partial<SettingOpts<Maybe<string>>>\n  ) {\n    super({\n      toEnv: notBlankToS,\n      fromEnv: notBlankToS,\n      defaultValue: undefined,\n      ...opts\n    })\n  }\n\n  hasValue() {\n    return notBlank(this.value)\n  }\n}\n\nfunction trim(s: Maybe<string>) {\n  return s == null ? undefined : s.trim()\n}\n\nexport class StringSetting extends Setting<string> {\n  constructor(opts: SettingOpts<string>) {\n    super({\n      toEnv: trim,\n      fromEnv: trim,\n      ...opts\n    })\n  }\n\n  hasValue() {\n    return notBlank(this.value)\n  }\n}\n\nfunction asValidValue(s: Maybe<string>, validValues: string[]): Maybe<string> {\n  const l = toS(s).toLowerCase()\n  return validValues.find(ea => ea.toLowerCase() === l)\n}\n\nexport class StringEnumSetting extends Setting<string> {\n  readonly validValues: string[]\n\n  constructor(opts: SettingOpts<string> & { validValues: string[] }) {\n    super({\n      toEnv: s => asValidValue(s, opts.validValues),\n      fromEnv: s => asValidValue(s, opts.validValues),\n      ...opts\n    })\n    // NOTE: do not compactBlanks! A blank may be a valid value!\n    this.validValues = opts.validValues\n    const dv = this.defaultValue\n    // Allow defaultValue to be undefined:\n    if (dv != null && !this.validValues.includes(this.defaultValue)) {\n      throw new Error(\n        `validValues, ${this.validValues}, doesn't include defaultValue, ${opts.defaultValue}`\n      )\n    }\n  }\n  addToJSON() {\n    return { validValues: this.validValues }\n  }\n}\n\nfunction _split(s: Maybe<string>): Maybe<string[]> {\n  return mapNotBlank(toS(s).trim(), str => {\n    if (str.startsWith(\"[\") && str.endsWith(\"]\")) {\n      try {\n        return flatten(JSON.parse(str)).map(toS)\n      } catch {\n        //\n      }\n    }\n    // broken pipe kept for backward compatibility:\n    for (const ea of [\"\u00A6\", delimiter]) {\n      if (str.includes(ea)) {\n        return str.split(ea)\n      }\n    }\n    return [str]\n  })\n}\n\nexport function splitStringArray(s: Maybe<string>): Maybe<string[]> {\n  return blankish(s) ? undefined : mapNotEmpty(_split(s), _uniqNonBlanks)\n}\n\nfunction _join(arr: Maybe<string[]>): Maybe<string> {\n  return mapNotEmpty(_uniqNonBlanks(arr), stringify)\n}\n\nfunction _uniqNonBlanks(arr: Maybe<string[]>) {\n  return uniq(compactBlankish(arr))\n}\n\nexport class StringArraySetting extends Setting<string[]> {\n  constructor(\n    opts: BaseSettingOpts<string[]> & Partial<DefaultValued<string[]>>\n  ) {\n    super({\n      defaultValue: [],\n      fromEnv: splitStringArray,\n      toEnv: _join,\n      ...opts\n    })\n  }\n\n  push(...values: string[]) {\n    this.value = _uniqNonBlanks([...this.valueOrDefault, ...values])\n  }\n\n  get values(): string[] {\n    return _uniqNonBlanks(this.valueOrDefault)\n  }\n\n  set values(arr: string[]) {\n    this.value = _uniqNonBlanks(arr)\n  }\n\n  removeValueFromEnv(v: string) {\n    map(this.value, arr => (this.tmpValue = arr.filter(ea => ea !== v)))\n  }\n}\n\nfunction parseStringEnum(\n  str: Maybe<string>,\n  validValues: string[]\n): Maybe<string[]> {\n  return filterStringEnum(splitStringArray(str), validValues)\n}\n\nfunction filterStringEnum(\n  arr: Maybe<Maybe<string>[]>,\n  validValues: string[]\n): Maybe<string[]> {\n  if (arr == null) return undefined\n  // PERF: unrolled\n  const result: string[] = []\n  for (const ea of arr) {\n    const r = asValidValue(ea, validValues)\n    if (r != null) result.push(r)\n  }\n  return result\n}\n\nexport class StringEnumsSetting extends Setting<string[]> {\n  readonly validValues: string[]\n  constructor(\n    opts: BaseSettingOpts<string[]> & {\n      defaultValue: string[]\n      validValues: string[]\n    }\n  ) {\n    super({\n      fromEnv: s => parseStringEnum(s, opts.validValues),\n      toEnv: arr => map(arr, ea => stringify(uniq(ea))),\n      ...opts\n    })\n    this.validValues = opts.validValues\n  }\n\n  asValidValues(o: any) {\n    return filterStringEnum(o, this.validValues)\n  }\n\n  addToJSON() {\n    return { validValues: this.validValues }\n  }\n}\n\nexport class IntegerSetting extends Setting<number> {\n  constructor(opts: SettingOpts<number>) {\n    super({\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toInt\n    })\n  }\n}\n\nexport class MaybeIntegerSetting extends Setting<Maybe<number>> {\n  constructor(opts: BaseSettingOpts<Maybe<number>>) {\n    super({\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toInt,\n      defaultValue: undefined\n    })\n  }\n}\n\nexport class FloatSetting extends Setting<number> {\n  constructor(opts: SettingOpts<number>) {\n    super({\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toFloat\n    })\n  }\n}\n\nexport class BoundedIntegerSetting extends Setting<number> {\n  constructor(\n    readonly options: SettingOpts<number> & { min: number; max: number }\n  ) {\n    super({\n      ...options,\n      toEnv: notBlankToS,\n      fromEnv: (value: Maybe<string>) =>\n        opt(value)\n          .flatMap(parseInt)\n          .map(ea => clamp(options.min, options.max, ea))\n          .get()\n    })\n  }\n  addToJSON() {\n    return { minValue: this.options.min, maxValue: this.options.max }\n  }\n}\n\nexport class BoundedFloatSetting extends Setting<number> {\n  constructor(\n    readonly options: SettingOpts<number> & { min: number; max: number }\n  ) {\n    super({\n      ...options,\n      toEnv: notBlankToS,\n      fromEnv: (value: Maybe<string>) =>\n        opt(value)\n          .flatMap(parseFloat)\n          .map(ea => clamp(options.min, options.max, ea))\n          .get()\n    })\n  }\n  addToJSON() {\n    return { minValue: this.options.min, maxValue: this.options.max }\n  }\n}\n\nexport class BooleanSetting extends Setting<boolean> {\n  constructor(opts: SettingOpts<boolean>) {\n    super({\n      ...opts,\n      toEnv: notBlankToS,\n      fromEnv: toBoolean\n    })\n  }\n}\n", "import { toS } from \"../fe/toS\"\n\nexport function camel2snake(s: string): string {\n  return toS(s)\n    .replace(/([A-Z])([a-z])/g, (_, a, b) => \"_\" + a.toLowerCase() + b)\n    .replace(/[A-Z]+|[0-9]+/g, ea => \"_\" + ea)\n    .replace(/^_/, \"\")\n}\n\nexport function camel2words(s: string): string {\n  return toS(s)\n    .replace(/([A-Z])([a-z])/g, (_, a, b) => \" \" + a.toLowerCase() + b)\n    .replace(/[A-Z]+|[0-9]+/g, ea => \" \" + ea)\n    .trim()\n}\n", "import { compactBlanks } from \"../../fe/Array\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { secondMs } from \"../../fe/Date\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { SyncOrAsync } from \"../../fe/OptAsync\"\nimport { toS } from \"../../fe/toS\"\nimport { isTest } from \"../NodeEnv\"\nimport { Settings } from \"../settings/Settings\"\nimport { levelIndex, LogLevel, LogLevels } from \"./LogLevel\"\n\nexport interface LogFilter {\n  highlight(context: string): boolean\n\n  /**\n   * @return true iff the given level and context are not configured to be\n   * squelched/omitted from downstream log writers.\n   */\n  enabled(level: LogLevel, context?: string): boolean\n  /**\n   * The level index that is enabled by default (ignoring context-specific overrides)\n   */\n  readonly defaultLevelIndex: number\n  silent: boolean\n}\n\nexport namespace PermissiveLogFilter {\n  export const highlight = () => false\n  export const silent: boolean = false\n  export const enabled = () => !silent\n  export const defaultLevelIndex = levelIndex(\"trace\")\n}\n\nconst LogLevelRe = /^(?:(.+?):)?(error|warn|info|debug|trace)$/i\n\ninterface LogLevelContext {\n  prefix: string\n  levelIndex: number\n}\n\nexport class LogFilterImpl implements LogFilter {\n  silent = false\n  defaultLevelIndex!: number\n  private readonly contexts: LogLevelContext[] = []\n\n  /**\n   * Parse out directives like LOG=ExifTag:debug,FileIterator:info,warn\n   */\n  constructor(e?: Maybe<string>) {\n    this.setup(e)\n  }\n\n  setup(e?: Maybe<string>) {\n    this.contexts.length = 0\n    let defaultLevelIndex = levelIndex(Settings.logLevel.defaultValue)\n    const log = notBlank(e) ? e : Settings.logLevel.valueOrDefault\n    compactBlanks(log.split(\",\")).forEach(ea => {\n      const match = LogLevelRe.exec(ea.trim())\n      if (match == null) {\n        if (!isTest) {\n          console.error(\"LogFilterImpl: Ignoring '\" + ea + \"' from \" + e)\n        }\n      } else {\n        const prefix = toS(match[1]).toLowerCase()\n        const idx = levelIndex(match[2])\n        if (blank(prefix)) {\n          defaultLevelIndex = idx\n        } else {\n          this.contexts.push({ prefix, levelIndex: idx })\n        }\n      }\n    })\n    this.defaultLevelIndex = defaultLevelIndex\n  }\n\n  private contextOverride(context?: string): Maybe<LogLevelContext> {\n    if (this.contexts.length === 0 && blank(context)) return\n    const s = toS(context).toLowerCase()\n    return this.contexts.find(ea => s.startsWith(ea.prefix))\n  }\n\n  enabled(level: LogLevel, context?: string): boolean {\n    if (this.silent) return false\n    const li = levelIndex(level)\n    // PERF: unrolled from Opt\n    if (li <= this.defaultLevelIndex) {\n      return true\n    }\n    const co = this.contextOverride(context)\n    const result = co != null && li <= co.levelIndex\n    return result\n  }\n\n  highlight(context: string) {\n    // PERF: unrolled from Opt\n    const co = this.contextOverride(context)\n    return co != null && co.levelIndex >= this.defaultLevelIndex\n  }\n}\n\nlet _logFilter: Maybe<LogFilterImpl>\n\nexport function logFilter(): LogFilter {\n  if (_logFilter == null) {\n    _logFilter = new LogFilterImpl()\n    Settings.logLevel.addListener(() => _logFilter!.setup())\n  }\n  return _logFilter\n}\n\nexport const defaultLogLevel = lazy(\n  () => LogLevels.values[logFilter().defaultLevelIndex],\n  5 * secondMs\n)\n\nexport function silently<T>(f: () => T): T {\n  try {\n    logFilter().silent = true\n    return f()\n  } finally {\n    logFilter().silent = false\n  }\n}\n\nexport async function silentlyAsync<T>(f: () => PromiseLike<T>): Promise<T> {\n  try {\n    logFilter().silent = true\n    return await f()\n  } finally {\n    logFilter().silent = false\n  }\n}\n\nexport async function withLogLevel<T>(\n  logLevel: LogLevel,\n  f: () => SyncOrAsync<T>\n): Promise<T> {\n  const prior = Settings.logLevel.getState()\n  Settings.logLevel.tmpValue = logLevel\n  try {\n    return await f()\n  } finally {\n    Settings.logLevel.setState(prior)\n  }\n}\n\n/**\n * Apply `f()` if the given logLevel is enabled.\n */\nexport function ifLog<T>(logLevel: LogLevel, f: () => T): Maybe<T> {\n  return logFilter().enabled(logLevel) ? f() : undefined\n}\n", "import { last } from \"../fe/Array\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { Comparable, gte, lt } from \"../fe/Primitive\"\n\nexport class SortedArray<T> {\n  readonly store: T[] = []\n\n  constructor(readonly valueOf: (t: T) => Maybe<Comparable>) {}\n\n  get length() {\n    return this.store.length\n  }\n\n  add(t: Maybe<T>) {\n    if (t == null) {\n      return\n    }\n    const v = this.valueOf(t)\n    if (v == null) {\n      return\n    }\n    if (this.store.length === 0) {\n      this.store.push(t)\n      return\n    }\n    // use lt versus lte to preserve .add() order\n    if (lt(v, this.valueOf(this.store[0]))) {\n      this.store.unshift(t)\n      return\n    }\n    for (let i = this.store.length - 1; i >= 0; i--) {\n      if (gte(this.valueOf(t), this.valueOf(this.store[i]))) {\n        this.store.splice(i + 1, 0, t)\n        return\n      }\n    }\n    // this backstop should never need to be called:\n    this.store.unshift(t)\n  }\n\n  /**\n   * Remove all the entries less than the given entry\n   */\n  shiftLt(c: Comparable): T[] {\n    if (this.length === 0) return []\n    let count = 0\n    if (lt(this.valueOf(last(this.store)!), c)) {\n      // the whole store is shift-able:\n      count = this.store.length\n    } else {\n      // look from the head:\n      while (lt(this.valueOf(this.store[count]), c)) {\n        count++\n      }\n    }\n    const result = count === 0 ? [] : this.splice(0, count)\n    // console.log(\"shiftLt(\" + c + \"):\", {\n    //   count,\n    //   result: result.map(this.valueOf),\n    //   store: this.store.map(this.valueOf)\n    // })\n    return result\n  }\n\n  /**\n   * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n   * @param start The zero-based location in the array from which to start removing elements.\n   * @param deleteCount The number of elements to remove.\n   */\n  splice(start: number, deleteCount?: number): T[] {\n    return this.store.splice(start, deleteCount)\n  }\n}\n", "import { env } from \"process\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { Settings } from \"../settings/Settings\"\nimport { ColoredLogFormatter } from \"./ColoredLogFormatter\"\nimport { PlaintextLogFormatter } from \"./PlaintextLogFormatter\"\n\nconst setupListener = lazy(() => {\n  Settings.logColor.addListener(() => DefaultLogFormatter.unset())\n})\n\nexport const DefaultLogFormatter = lazy(() => {\n  if (env.NO_COLOR != null) Settings.logColor.tmpValue = false\n  setupListener()\n  return Settings.logColor.valueOrDefault\n    ? new ColoredLogFormatter({ processName: () => \"\" })\n    : new PlaintextLogFormatter()\n})\n", "import { inspect } from \"util\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { Thunk } from \"../../fe/Thunk\"\nimport { toS } from \"../../fe/toS\"\nimport { blue, cyan, darkGrey, redBright, yellow, yellowBright } from \"../Chalk\"\nimport { isTest } from \"../NodeEnv\"\nimport { colorProcessName, processName } from \"../ServiceNames\"\nimport { dateForLog } from \"./LogCommon\"\nimport { LogEntry } from \"./LogEntry\"\nimport { logFilter } from \"./LogFilter\"\nimport { FormatterOptions, LogFormatter } from \"./LogFormatter\"\nimport { LogLevel } from \"./LogLevel\"\nimport { ContextLines, prepMeta } from \"./LogMeta\"\n\nexport class ColoredLogFormatter implements LogFormatter {\n  private readonly logLevels = {\n    trace: \"trace\",\n    debug: darkGrey(\"debug\"),\n    info: cyan(\"info \"),\n    error: redBright(\"error\"),\n    warn: yellowBright(\"warn \")\n  }\n\n  static defaultInspectOptions: Thunk<FormatterOptions> = () => ({\n    showHidden: false,\n    depth: 4,\n    colors: true,\n    compact: true,\n    customInspect: true,\n    maxArrayLength: ContextLines + 1,\n    processName: processName\n  })\n  private readonly inspectOptions: FormatterOptions\n  constructor(inspectOptions: Partial<FormatterOptions> = {}) {\n    this.inspectOptions = {\n      ...ColoredLogFormatter.defaultInspectOptions(),\n      ...inspectOptions\n    }\n    if (isTest) {\n      this.inspectOptions.breakLength = 255\n    }\n  }\n\n  formatMeta(meta?: Maybe<any[]>) {\n    if (meta == null) return undefined\n    const m = prepMeta(meta)\n    return m == null ? undefined : inspect(m, this.inspectOptions)\n  }\n\n  formatLogEntry(le: LogEntry): string {\n    const contextColor = logFilter().highlight(le.ctx) ? yellow : blue\n    return compactBlanks([\n      dateForLog(le.ts),\n      colorProcessName(\n        orElse(le.from, () => this.inspectOptions.processName())\n      ),\n      this.logLevels[le.l],\n      contextColor(le.ctx),\n      le.msg,\n      this.formatMeta(le.meta)\n    ])\n      .map(ea => toS(ea))\n      .join(\" \")\n  }\n\n  format(\n    level: LogLevel,\n    context: string,\n    message: string,\n    meta?: any\n  ): string {\n    return this.formatLogEntry({\n      ts: Date.now(),\n      l: level,\n      from: processName(),\n      ctx: context,\n      msg: message,\n      meta\n    })\n  }\n}\n", "import { Duration } from \"luxon\"\nimport { darkGrey, yellow } from \"../Chalk\"\nimport { isTest } from \"../NodeEnv\"\nimport { Settings } from \"../settings/Settings\"\n\nconst start = Date.now()\n\nexport function dateForLog(ts: number) {\n  const result = Settings.logElapsedMs.valueOrDefault\n    ? // inlined the msToHMS to prevent logging from pulling in Date:\n      Duration.fromMillis(ts - start).toFormat(\"hhhh:mm:ss.SSS\")\n    : new Date(ts).toISOString()\n\n  if (Settings.logColor.valueOrDefault) {\n    return Settings.logElapsedMs.valueOrDefault\n      ? yellow(result)\n      : darkGrey(result)\n  } else {\n    return result\n  }\n}\n\nexport const DefaultLogFlushMs = isTest ? 250 : 750\n", "import { inspect, InspectOptions } from \"util\"\nimport { compactBlanks } from \"../../fe/Array\"\nimport { map } from \"../../fe/Maybe\"\nimport { fromEntries } from \"../../fe/Object\"\nimport { toS } from \"../../fe/toS\"\nimport { processName } from \"../ServiceNames\"\nimport { rightPad, stripAnsiEsc } from \"../String\"\nimport { dateForLog } from \"./LogCommon\"\nimport { LogEntry } from \"./LogEntry\"\nimport { LogFormatter } from \"./LogFormatter\"\nimport { LogLevel, LogLevels } from \"./LogLevel\"\n\nexport class PlaintextLogFormatter implements LogFormatter {\n  constructor(\n    readonly inspectOptions: InspectOptions = {\n      colors: false,\n      depth: 4,\n      compact: true,\n      customInspect: true\n    }\n  ) {}\n\n  readonly paddedLogLevels = fromEntries(\n    LogLevels.values.map(ea => [ea, rightPad(ea, 5, \" \")])\n  )\n\n  formatLogEntry(le: LogEntry): string {\n    return compactBlanks([\n      dateForLog(le.ts),\n      processName(),\n      this.paddedLogLevels[le.l],\n      stripAnsiEsc(le.ctx),\n      stripAnsiEsc(le.msg),\n      map(le.meta, ea => inspect(ea, this.inspectOptions))\n    ])\n      .map(ea => toS(ea))\n      .join(\" \")\n  }\n\n  format(\n    level: LogLevel,\n    context: string,\n    message: string,\n    meta?: any\n  ): string {\n    return this.formatLogEntry({\n      ts: Date.now(),\n      l: level,\n      from: processName(),\n      ctx: context,\n      msg: message,\n      meta\n    })\n  }\n}\n", "import { sortByInPlace } from \"../../fe/Array\"\nimport { LogLevel } from \"./LogLevel\"\n\n/**\n * field names are abbreviated as they are encoded in JSON on disk.\n */\nexport interface LogEntry {\n  /**\n   * timestamp\n   */\n  ts: number\n  /**\n   * log level\n   */\n  l: LogLevel\n  /**\n   * context\n   */\n  ctx: string\n  /** message */\n  msg: string\n  meta?: any[]\n  from?: string\n}\n\nexport function logEntrySorter(ea: LogEntry) {\n  return ea?.ts\n}\n\nexport function sortLogEntriesInPlace(arr: LogEntry[]) {\n  sortByInPlace(arr, ea => ea.ts)\n}\n", "import { SortedArray } from \"../SortedArray\"\nimport { DefaultLogFormatter } from \"./DefaultLogFormatter\"\nimport { DefaultLogFlushMs } from \"./LogCommon\"\nimport { LogEntry, logEntrySorter } from \"./LogEntry\"\n\n// Separated from LogTail to break require chains\n\nlet _logTailEnabled = false\n\nexport function logTailEnabled() {\n  return _logTailEnabled\n}\n\nexport function setLogTailEnabled(b: boolean) {\n  _logTailEnabled = b\n}\n\nconst logEntries = new SortedArray<LogEntry>(logEntrySorter)\n\nexport function pushLogEntries(...arr: LogEntry[]) {\n  // PERF: for loop instead of .forEach\n  for (const ea of arr) {\n    // don't use Settings.logTail:\n    if (_logTailEnabled) {\n      logEntries.add(ea)\n    } else {\n      console.log(DefaultLogFormatter().formatLogEntry(ea))\n    }\n  }\n}\n\n/**\n * @param ttl if zero, pop everything (we're shutting down)\n */\nexport function popExpiredLogEntries(ttl = DefaultLogFlushMs * 2) {\n  return logEntries.shiftLt(Date.now() - ttl)\n}\n", "import { lazy } from \"../../fe/Lazy\"\nimport { processName } from \"../ServiceNames\"\nimport { logFilter } from \"./LogFilter\"\nimport { SimpleLogger } from \"./Logger\"\nimport { LogLevel } from \"./LogLevel\"\nimport { pushLogEntries } from \"./LogTailEntries\"\n\n/**\n * Works in concert with LogTail so both local and remote log messages are mixed\n * together.\n */\nexport class ConsoleLogger implements SimpleLogger {\n  static readonly instance = lazy(() => new ConsoleLogger())\n\n  log(level: LogLevel, context: string, msg: string, meta?: any) {\n    pushLogEntries({\n      ts: Date.now(),\n      l: level,\n      from: processName(),\n      ctx: context,\n      msg,\n      meta\n    })\n  }\n\n  enabled(level: LogLevel, context: string): boolean {\n    return logFilter().enabled(level, context)\n  }\n\n  async flush() {\n    // no op\n  }\n\n  end() {\n    // no op\n  }\n}\n", "import _fs = require(\"fs\")\nimport { join } from \"path\"\nimport { clearInterval } from \"timers\"\nimport { compact, compactBlanks } from \"../../fe/Array\"\nimport { fmtIsoDate, secondMs } from \"../../fe/Date\"\nimport { unrefDelay } from \"../../fe/Delay\"\nimport { stringify } from \"../../fe/JSON\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { thenMap } from \"../../fe/Promise\"\nimport { addLoggerEndable, Endable } from \"../async/Endable\"\nimport { Promises } from \"../async/Promises\"\nimport { setUnrefInterval } from \"../async/Timers\"\nimport { splitLines } from \"../fs/CRLF\"\nimport { ensureNewNativePath_, gzip_, nameWithoutCount } from \"../fs/Path\"\nimport { SimpleFile } from \"../fs/SimpleFile\"\nimport { endStream } from \"../fs/Streams\"\nimport { zcat } from \"../fs/zcat\"\nimport { mapParsed } from \"../JSON\"\nimport { processName } from \"../ServiceNames\"\nimport { Settings } from \"../settings/Settings\"\nimport { stripAnsiEsc } from \"../String\"\nimport { ConsoleLogger } from \"./ConsoleLogger\"\nimport { DefaultLogFlushMs } from \"./LogCommon\"\nimport { LogEntry } from \"./LogEntry\"\nimport { ContextProvider } from \"./LogFormatter\"\nimport { SimpleLogger } from \"./Logger\"\nimport { LogLevel } from \"./LogLevel\"\nimport { clearRecentLogEntries, recentLogEntries } from \"./RecentLogs\"\n\nexport type WritableStream = NodeJS.WritableStream\n\nexport class CaptureLogger implements SimpleLogger {\n  readonly logEntries: LogEntry[] = []\n  log(level: LogLevel, context: string, message: string, meta?: any) {\n    this.logEntries.push({\n      ts: Date.now(),\n      l: level,\n      ctx: context,\n      msg: message,\n      meta\n    })\n  }\n\n  enabled() {\n    return true\n  }\n\n  end() {\n    // no-op\n  }\n\n  async flush() {\n    // no-op\n  }\n}\n\nexport interface LogWriterOptions {\n  maxLinesPerFile: number\n  errorLogger: SimpleLogger\n  flushEveryMs: number\n}\n\n/**\n * Writes to logDir/YYYY-MM-DD/name-00N.log\n */\nexport class LogWriter implements SimpleLogger, Endable {\n  readonly name: string\n  ended = false\n  private readonly mutex = new Promises()\n  private readonly opts: Required<LogWriterOptions & ContextProvider>\n  private _linesSinceRotate: number = 0\n  private _currentFile: Maybe<string>\n  private _stream: Maybe<WritableStream>\n  private readonly pendingWrites: string[] = []\n  private flushInterval: Maybe<NodeJS.Timer>\n  private _startIndex = 0\n\n  // gzipping the logfiles should not take longer than 10 seconds (assuming logs\n  // are on fast local disk)\n  readonly endTimeoutMs = 15 * secondMs\n\n  constructor(\n    readonly logDir: string,\n    options: Partial<LogWriterOptions & ContextProvider> = {}\n  ) {\n    this.name = \"LogWriter(\" + logDir + \")\"\n    this.opts = {\n      maxLinesPerFile: 250000, // ~ 10-20 Mb\n      errorLogger: ConsoleLogger.instance(),\n      flushEveryMs: DefaultLogFlushMs,\n      processName: processName,\n      ...options\n    }\n    this.flushInterval = setUnrefInterval(\n      () => this.maybeFlush(),\n      this.opts.flushEveryMs\n    )\n    addLoggerEndable(this)\n  }\n\n  log(level: LogLevel, context: string, msg: string, meta?: any) {\n    if (this.ended && level === \"error\") {\n      // If it's bad, send the message someplace, at least.\n      this.opts.errorLogger.log(level, context, msg, meta)\n    } else {\n      const entry: LogEntry = { ts: Date.now(), l: level, ctx: context, msg }\n      if (meta != null) entry.meta = meta\n      if (level === \"error\") {\n        // If we push entry before this, the recentLogEntries show out of order:\n        this.writeRecentLogEntries()\n        void this.flush()\n      }\n      this.pendingWrites.push(stringify(entry) + \"\\n\")\n    }\n  }\n\n  // must not be async (so this.log can stay sync)\n  writeRecentLogEntries() {\n    this.pendingWrites.push(\n      ...recentLogEntries().map(ea => stringify(ea) + \"\\n\")\n    )\n    // we don't want to write these entries more than once:\n    clearRecentLogEntries()\n  }\n\n  readonly end = lazy(async () => {\n    this.ended = true\n    map(this.flushInterval, clearInterval)\n    this.flushInterval = undefined\n    await this.flush()\n    return this.mutex.serial(\"close\", () => {\n      return this._closeCurrent()\n    })\n  })\n\n  private readonly maybeFlush = () =>\n    this.mutex.maybeRun(\"maybeFlush\", () => this._flush())\n\n  readonly shouldRotate = () =>\n    this._stream == null || this._linesSinceRotate >= this.opts.maxLinesPerFile\n\n  async flush() {\n    await this.mutex.serial(\"flush\", () => this._flush())\n  }\n\n  private async _flush() {\n    const toFlush = [...this.pendingWrites]\n    this.pendingWrites.length = 0\n    while (toFlush.length > 0) {\n      if (this.shouldRotate()) await this._rotate()\n      const stream = this._stream\n      if (stream == null) {\n        this.opts.errorLogger.log(\n          \"error\",\n          \"LogWriter.flush()\",\n          \"this._rotate() returned an empty stream\"\n        )\n        return\n      }\n      const remainingCapacity =\n        this.opts.maxLinesPerFile - this._linesSinceRotate\n      const lines = toFlush.splice(0, remainingCapacity)\n      this._linesSinceRotate += lines.length\n      stream.write(lines.join(\"\"))\n    }\n    return\n  }\n\n  private errback(source: string) {\n    return (err: any) =>\n      this.opts.errorLogger.log(\"error\", \"Caught error from \" + source, err)\n  }\n\n  private async _rotate(): Promise<void> {\n    await this._closeCurrent()\n    this._currentFile = await ensureNewNativePath_({\n      nativePath: join(\n        this.logDir,\n        fmtIsoDate(new Date()),\n        stripAnsiEsc(this.opts.processName()) + \".log\"\n      ),\n      emptyIsNew: true,\n      startIndex: ++this._startIndex,\n      requireNumber: true,\n      leftPad: 3 // we're in trouble if we're writing more than 100 log files a day.\n    })\n    this._stream = _fs\n      .createWriteStream(this._currentFile)\n      .on(\"error\", this.errback(\"file write stream\"))\n    return\n  }\n\n  private async _closeCurrent() {\n    // not this.end(), because we don't want to flush:\n    const priorStream = this._stream\n    this._stream = undefined\n    this._linesSinceRotate = 0\n    const priorFile = this._currentFile\n    this._currentFile = undefined\n\n    await endStream(priorStream)\n    if (Settings.logCompression.valueOrDefault) {\n      // let logtail see the result of the file:\n      await unrefDelay(this.opts.flushEveryMs)\n      await map(priorFile, gzip_)\n    }\n  }\n}\n\nexport async function readLogEntries(\n  f: SimpleFile,\n  options?: { start?: number; end?: number }\n): PromiseMaybe<LogEntry[]> {\n  const from = nameWithoutCount(f.name)\n  return thenMap(zcat(f.nativePath, options), s =>\n    compact(\n      compactBlanks(splitLines(s)).map(ea =>\n        mapParsed(ea, le => ({ ...le, from } as LogEntry))\n      )\n    )\n  )\n}\n", "import { lazy } from \"../fe/Lazy\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { end } from \"./async/Endable\"\nimport { ConsoleLogger } from \"./log/ConsoleLogger\"\nimport { ContextualLogger, SimpleLogger } from \"./log/Logger\"\nimport { LogWriter } from \"./log/LogWriter\"\nimport { Settings } from \"./settings/Settings\"\n\n//\n// This file integrates PhotoStructure with the log package.\n//\n\n// the logger is a process singleton. This should only be called at the\n// beginning of the process, and sets up the directory for the logger.\n\n// mkLogger() should always point to the current value of the process logger.\n\nconst rootLoggers = lazy<SimpleLogger[]>(() => [ConsoleLogger.instance()])\n\nexport function currentFileLogger(): Maybe<LogWriter> {\n  return rootLoggers().find(ea => ea instanceof LogWriter) as LogWriter\n}\n\nexport function setupLogger() {\n  const logDir = Settings.logDir.valueOrDefault\n  let fl = currentFileLogger()\n  if (fl == null || fl.logDir !== logDir) {\n    void end(fl)\n    fl = new LogWriter(logDir)\n  }\n  const arr: SimpleLogger[] = [fl]\n  if (Settings.logStdout.valueOrDefault || Settings.tailLogs.valueOrDefault) {\n    arr.push(ConsoleLogger.instance())\n  }\n  rootLoggers.set(arr)\n}\n\nexport function writeRecentLogEntries() {\n  return currentFileLogger()?.writeRecentLogEntries()\n}\n\nexport type Logger = ContextualLogger // TODO: inline?\n\nexport function mkLogger(context: string): ContextualLogger {\n  return new ContextualLogger(context, rootLoggers)\n}\n", "import { isNotEmpty } from \"../../fe/Array\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { MaybeSyncOrAsync } from \"../../fe/OptAsync\"\nimport { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\nimport { magenta } from \"../Chalk\"\nimport { isEnvTrue } from \"../Env\"\nimport { mkLogger } from \"../Logger\"\nimport { MultiMap } from \"../MultiMap\"\nimport { isSingleSpecTests, isTest } from \"../NodeEnv\"\nimport { firstGt0 } from \"../Number\"\nimport { Try } from \"../Object\"\nimport { thenOrTimeout } from \"./thenOrTimeout\"\nimport { setUnrefInterval } from \"./Timers\"\n\nconst logger = lazy(() => mkLogger(magenta(\"Endable\")))\n\nexport interface Endable {\n  readonly name: string\n  readonly ended: boolean\n  readonly endTimeoutMs?: number\n  end(): Promise<any> | any\n}\n\nconst endablesByRank = new MultiMap<EndableRank, Endable>()\n\nsetUnrefInterval(() => vacuumEndables(), 1 * minuteMs)\n\nconst DefaultTimeoutMs = 5 * secondMs\n\nexport const EndableRanks = strEnum(\n  \"first\",\n  \"service\",\n  \"predb\",\n  \"db\",\n  \"postdb\",\n  \"logger\"\n)\nexport type EndableRank = StrEnumKeys<typeof EndableRanks>\n\n/**\n * \"First\" endables have no dependant services.\n */\nexport function addFirstEndable<T extends Endable>(endable: T): T {\n  return addEndable(EndableRanks.first, endable)\n}\n\n/**\n * These are services that \"first\" endables depend on, but may require other services.\n */\nexport function addServiceEndable<T extends Endable>(endable: T): T {\n  return addEndable(EndableRanks.service, endable)\n}\n\n/**\n * These are final cleanup tasks once the services are shut down, like a db\n * backup.\n */\nexport function addPreDbEndable<T extends Endable>(endable: T): T {\n  return addEndable(EndableRanks.predb, endable)\n}\n\n/**\n * Final services that services depend on, like closing the DB.\n */\nexport function addDbEndable<T extends Endable>(endable: T): T {\n  // closing the db should be instant, use the default timeout:\n  return addEndable(EndableRanks.db, endable)\n}\n\n/**\n * Final services that need to run after the db has closed (like releasing the\n * opened-by lock)\n */\nexport function addPostDbEndable<T extends Endable>(endable: T): T {\n  // closing the db should be instant, use the default timeout:\n  return addEndable(EndableRanks.postdb, endable)\n}\n\n/**\n * Final-final ending-endable, reserved for the logger.\n */\nexport function addLoggerEndable<T extends Endable>(endable: T): T {\n  return addEndable(EndableRanks.logger, endable)\n}\n\n/**\n * Add an endable with an arbitrary end rank\n */\nexport function addEndable<T extends Endable>(\n  rank: EndableRank,\n  endable: T\n): T {\n  EndableRanks.validOrElse(rank, () => {\n    throw new Error(\"internal error: invalid rank \" + rank)\n  })\n  endablesByRank.add(rank, endable)\n  return endable\n}\n\nlet _ending = false\n\nexport function ending(): boolean {\n  return _ending\n}\n\nexport function setEnding(value: boolean) {\n  if (isTest) {\n    _ending = value\n  } else {\n    throw new Error(\"cannot set ending\")\n  }\n}\n\nexport function endAll(...arr: Maybe<Endable>[]) {\n  return Promise.all(arr.map(ea => end(ea)))\n}\n\nexport async function end(e: MaybeSyncOrAsync<Endable>, endTimeoutMs?: number) {\n  const endable = await e\n  if (endable == null || endable.ended) return\n  const timeoutMs =\n    isTest && isEnvTrue(\"SINGLE_SPEC_TESTS\")\n      ? 100\n      : firstGt0(endTimeoutMs, endable.endTimeoutMs, DefaultTimeoutMs)!\n  logger().debug(endable.name + \" ending...\", { timeoutMs })\n  return thenOrTimeout(\n    endable.end(),\n    timeoutMs,\n    () => logger().warn(endable.name + \".end() timed out\"),\n    () => logger().debug(endable.name + \".end() completed\")\n  ).catch(err => {\n    // the logger might throw errors at the very end:\n    Try(() => logger().warn(endable.name + \".end() rejected: \" + err))\n  })\n}\n\nfunction vacuumEndables() {\n  endablesByRank.filterInPlace((_, v) => !v.ended)\n  logger().debug(\n    \"vacuumEndables()\",\n    endablesByRank.entriesArray().map(([k, v]) => [k, v.map(ea => ea.name)])\n  )\n}\n\nexport const endEndables = lazy(async () => {\n  const endTimeoutMs = isSingleSpecTests() ? 250 : undefined\n\n  logger().info(\"endEndables()\", { isTest, isSingleSpecTests })\n  if (!isTest) _ending = true\n  vacuumEndables()\n  for (const rank of EndableRanks.values) {\n    const arr = orElse(endablesByRank.get(rank), [])\n    if (isNotEmpty(arr)) {\n      logger().debug(\"endEndables(): ending \" + rank)\n      await Promise.all(arr.map(ea => end(ea, endTimeoutMs)))\n    }\n  }\n})\n", "import { Command, program } from \"commander\"\nimport p from \"process\"\nimport { Pojo } from \"../../core/Object\"\nimport { ServiceName, setServiceName } from \"../../core/ServiceNames\"\nimport { version } from \"../../core/Version\"\nimport { mapNotBlankOr } from \"../../fe/Blank\"\nimport { map } from \"../../fe/Maybe\"\nimport { addFooter, CliDesc } from \"./CliConstants\"\n\nexport interface CommandPlugin {\n  beforeParse(cmd: Command): Command\n  afterParse(opts: Pojo): void\n}\n\nexport class CLI {\n  private readonly plugins: CommandPlugin[] = []\n\n  /**\n   * @param args if non-empty, passed to `Command.arguments()`\n   */\n  constructor(\n    readonly serviceName: keyof typeof CliDesc & ServiceName,\n    readonly args?: string,\n    readonly additionalDescription?: string\n  ) {\n    setServiceName(serviceName)\n  }\n\n  add(...plugins: CommandPlugin[]) {\n    this.plugins.push(...plugins)\n    return this\n  }\n\n  async parse() {\n    let cmd = addFooter(\n      program.description(\n        CliDesc[this.serviceName] +\n          mapNotBlankOr(\n            this.additionalDescription,\n            ea => \"\\n\\n\" + ea,\n            () => \"\"\n          )\n      ) as Command\n    )\n\n    map(this.args, ea => {\n      cmd = cmd.arguments(ea)\n    })\n\n    for (const ea of this.plugins) {\n      cmd = ea.beforeParse(cmd)\n    }\n\n    cmd.version(\n      version,\n      \"--version\",\n      \"Output the version number (spoiler: it's \" + version + \")\"\n    )\n\n    cmd.parse(p.argv)\n\n    const opts = cmd.opts()\n\n    for (const ea of this.plugins) {\n      await ea.afterParse(opts)\n    }\n\n    return cmd\n  }\n}\n", "import { Command } from \"commander\"\nimport { stdout } from \"process\"\nimport { wrap } from \"../../fe/String\"\n\nconst year = new Date().getFullYear()\n\nexport const descriptionFooter = `Please visit <https://photostructure.com/support/> for detailed usage and configuration instructions.\n\nCopyright \u00A9 2017-${year}, PhotoStructure Inc.\n\nRunning this software indicates your agreement to all the terms of this license: <https://photostructure.com/eula/>`\n\nexport const CliDesc = {\n  main:\n    \"PhotoStructure's main process manager. Runs and manages web and sync services.\",\n  info: \"Configuration, file metadata and import diagnostics tool. \",\n  list: \"List all paths in a Library.\",\n  logcat: \"Chronologically sort and pretty-print PhotoStructure logfiles.\",\n  logtail:\n    \"View the log messages of currently-running PhotoStructure processes. (Like `tail -f`).\",\n  web: \"PhotoStructure's web service. Automatically started by main.\",\n  sync:\n    \"PhotoStructure's directory synchronization service. Automatically started by main.\",\n  \"sync-file\":\n    \"PhotoStructure's file synchronization service. Automatically started by sync.\"\n}\n\nexport function addFooter(c: Command): Command {\n  return c.on(\"--help\", () => {\n    console.log(\n      \"\\n\" +\n        wrap(descriptionFooter, {\n          maxLineLen: stdout.columns ?? 78,\n          prefix: \"\"\n        }).join(\"\\n\") +\n        \"\\n\"\n    )\n  })\n}\n", "import { sep } from \"path\"\nimport {\n  commonPrefixLength,\n  flatten,\n  mapNotEmpty,\n  sort,\n  sortBy\n} from \"../../fe/Array\"\nimport { blank, notBlank, notBlankOr } from \"../../fe/Blank\"\nimport { secondMs, unixtime } from \"../../fe/Date\"\nimport { lazy, MemoizedThunk } from \"../../fe/Lazy\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { StringValued } from \"../../fe/Object\"\nimport { opt } from \"../../fe/Opt\"\nimport { thenOpt } from \"../../fe/OptAsync\"\nimport { ensurePrefix } from \"../../fe/String\"\nimport { toA } from \"../../fe/toA\"\nimport { toS } from \"../../fe/toS\"\nimport { contextFilter, greatestBy } from \"../Array\"\nimport { sortByAsync, thenMap, thenMapOr } from \"../async/Promise\"\nimport { stdout } from \"../child/ChildProcess\"\nimport { emitFileChanged } from \"../event/EventEmitter\"\nimport { mkLogger } from \"../Logger\"\nimport { Radix58 } from \"../math/Radix\"\nimport { groupBy } from \"../MultiMap\"\nimport { isMac, isWin } from \"../Platform\"\nimport { Settings } from \"../settings/Settings\"\nimport { equalsIgnoreCase } from \"../String\"\nimport { isSidecarExt } from \"../tags/FileExts\"\nimport { nativePath2uri, uri2nativePath } from \"../uri/FileURI\"\nimport { toURI, URI } from \"../uri/URI\"\nimport { isUri } from \"../uri/UriNormalization\"\nimport { mountpoints } from \"../volumes/Mountpoints\"\nimport { BaseFile } from \"./BaseFile\"\nimport { DirectoryEntry } from \"./DirectoryEntry\"\nimport { FileCache } from \"./FileCache\"\nimport { fileSha } from \"./Hash\"\nimport { hidden } from \"./Hidden\"\nimport { ignorableDirectory, ignorableFile, ignorablePath } from \"./Ignorable\"\nimport { hasNoMedia } from \"./NoMedia\"\nimport { containedByNativePath, nameWithoutCount, resolve } from \"./Path\"\nimport { SimpleFile } from \"./SimpleFile\"\n\nconst cache = new FileCache<PosixFile>()\n\nexport function groupByMountpoint(paths: PosixFile[], mounts: PosixFile[]) {\n  return groupBy(paths, path =>\n    map(path.bestMountpoint(mounts), ea => ea.nativePath)\n  )\n}\n\nfunction sortFiles(paths: PosixFile[]) {\n  return sortBy(paths, ea => ea.nativePath)\n}\n\nexport function uniquePrefixes(paths: PosixFile[]) {\n  return contextFilter(\n    sortFiles(paths),\n    // This also does a uniq():\n    (ea, _idx, last) => last == null || !ea.isDescendantOf(last)\n  )\n}\n\n/**\n * Given a set of paths and a set of mountpoints, coalesce any paths from the\n * same mountpoint that overlap.\n */\nexport function coalesce(paths: PosixFile[], mounts: PosixFile[]): PosixFile[] {\n  const byMountpoint = groupByMountpoint(paths, mounts)\n  return sortFiles(flatten(toA(byMountpoint.values()).map(uniquePrefixes)))\n}\n\n/**\n * Ensures a given path is only \"posix-ized\" once, and holds promises for more\n * expensive information about the file, like inode stats, SHA1, and EXIF tags.\n */\nexport class PosixFile extends BaseFile implements SimpleFile {\n  protected readonly pflog = lazy(() =>\n    mkLogger(\"PosixFile(\" + this.nativePath + \")\")\n  )\n\n  protected constructor(readonly nativePath: string, dirent?: DirectoryEntry) {\n    super(nativePath, dirent)\n    // cache.set(nativePath, this)\n  }\n\n  static forDirectoryEntry(de: DirectoryEntry) {\n    return this.for(de.nativePath, de)\n  }\n\n  static for(\n    nativePathOrFile: string | BaseFile | PosixFile,\n    dirent?: DirectoryEntry\n  ): PosixFile {\n    if (blank(nativePathOrFile)) throw new Error(\"unexpectedly empty path\")\n    if (nativePathOrFile instanceof PosixFile) {\n      return nativePathOrFile\n    }\n    if (nativePathOrFile instanceof BaseFile) {\n      return this.for(nativePathOrFile.nativePath, dirent)\n    }\n    if (isUri(nativePathOrFile)) throw new Error(\"use forUri\")\n\n    // PERF: resolve() is expensive.\n    const prior = cache.get(nativePathOrFile)\n    if (prior != null) return prior\n    const resolvedPath = resolve(nativePathOrFile)\n\n    return cache.getOrSet(\n      resolvedPath,\n      () => new PosixFile(resolvedPath, dirent)\n    )\n\n    // return new PosixFile(resolve(pathOrFile), dirent)\n  }\n\n  static forPosix(path: string): PosixFile {\n    return this.for(path.replace(/\\//g, sep))\n  }\n\n  static forUri(uri: string, mountpoint?: string): PromiseMaybe<PosixFile> {\n    return thenMap(uri2nativePath(uri, mountpoint), nativePath =>\n      this.for(nativePath)\n    )\n  }\n\n  for(path: string, dirent?: DirectoryEntry): this {\n    return PosixFile.for(path, dirent) as this\n  }\n\n  clear(): this {\n    super.clear()\n    this.uriObject.unset()\n    this.uri.unset()\n    this.fileuri.unset()\n    this.mountpoint.unset()\n    this.etag.unset()\n    this.sidecars.unset()\n    return this\n  }\n\n  readonly uriObject = lazy(() => nativePath2uri(this.nativePath))\n  readonly uri = lazy(() => thenMap(this.uriObject(), toS))\n  readonly fileuri = lazy(() => URI.file(this.nativePath).toString())\n\n  readonly mountpoint = lazy(() => {\n    if (isWin && this.nativePath.startsWith(\"\\\\\\\\\")) {\n      return this.for(this.nativePath.split(\"\\\\\").slice(0, 4).join(\"\\\\\"))\n    }\n    return thenMap(mountpoints(), arr =>\n      this.bestMountpoint(arr.map(ea => this.for(ea)))\n    )\n  })\n\n  bestMountpoint(mounts: (this | string)[]): Maybe<this> {\n    return greatestBy(\n      mounts\n        .filter(ea => containedByNativePath(this.nativePath, ea.toString()))\n        .map(ea => PosixFile.for(ea) as this),\n      mount =>\n        opt(commonPrefixLength(this.pathnames, mount.pathnames))\n          .filter(len => len >= mount.pathnames.length) // if the mountpoint isn't an ancestor, this isn't from that mountpoint.\n          .get()\n    )\n  }\n\n  /**\n   * @return true iff this file or directory doesn't exist, and the mountpoint\n   * is currently mounted, or some parent directory exists.\n   */\n  async isDeleted(uri?: URI | string): PromiseMaybe<boolean> {\n    uri = await notBlankOr(uri, () => this.uri() as any)\n    if (this.isUNC) {\n      return this.pflog().tap({\n        result: undefined,\n        msg: \"isDeleted(): UNC not supported\"\n      })\n    }\n\n    // We know it's not deleted if this exists!\n    if (await this.exists()) {\n      return this.pflog().tap({\n        result: false,\n        msg: \"isDeleted(): file exists\"\n      })\n    }\n\n    if (uri == null) {\n      return this.pflog().tap({\n        result: undefined,\n        level: \"warn\",\n        msg: \"isDeleted(): missing URI\"\n      })\n    }\n\n    // So at this point, we know this file doesn't exist.\n\n    uri = toURI(uri)\n\n    if (uri.isRootPath()) {\n      // don't descend any farther, we're at (least a prior) mountpoint\n      return this.pflog().tap({\n        result: undefined,\n        msg: \"isDeleted(): uri isRootPath\",\n        meta: { uri }\n      })\n    }\n\n    // Is the uri relevant to this path?\n\n    if (toS(uri.pathBase).normalize() !== this.base.normalize()) {\n      return this.pflog().tap({\n        level: \"warn\",\n        result: undefined,\n        msg: \"isDeleted(): uri isn't correct\",\n        meta: { uri, expectedBase: this.base, uriBase: uri.pathBase }\n      })\n    }\n\n    // If we can make any claim about a parent, we know I've been deleted.\n\n    const parentDeleted = await this.parent().isDeleted(uri.parent())\n\n    if (parentDeleted == null) {\n      return this.pflog().tap({\n        result: undefined,\n        msg: \"isDeleted(): parent().isDeleted was undefined\",\n        meta: { uri }\n      })\n    } else {\n      return this.pflog().tap({\n        result: true,\n        msg:\n          \"isDeleted(): parent was either deleted or not deleted, which means I am deleted.\",\n        meta: { parentDeleted, uri }\n      })\n    }\n  }\n\n  readonly etag = lazy(() =>\n    thenMap(this.stat(), s =>\n      [s.size, s.mtime.getTime()].map(n => Radix58.encode(n)).join(\"-\")\n    )\n  )\n\n  async httpHeaders(): Promise<StringValued> {\n    return {\n      ETag: await this.etag(),\n      \"Last-Modified\": await this.lastModifiedUtc()\n    }\n  }\n\n  async hide(): PromiseMaybe<this> {\n    const out = await (isWin\n      ? stdout(\"attrib\", [\"+h\", this.nativePath], {\n          timeout: 10 * secondMs\n        }).catch(err => err)\n      : isMac\n      ? stdout(\"chflags\", [\"hidden\", this.nativePath], {\n          timeout: 10 * secondMs\n        }).catch(err => err)\n      : \"\")\n    if (notBlank(out)) {\n      this.pflog().warn(\"hide(\" + this.nativePath + \") failed: \" + out)\n      return undefined\n    } else {\n      return this.clear()\n    }\n  }\n\n  /**\n   * Is the nearest directory hidden? (This lets us only check folders)\n   */\n  ignorableParent() {\n    return this.trapOr(\"ignorableParent\", () =>\n      this.nearestDir().then(d => d.ignorable())\n    )\n  }\n\n  /**\n   * @throws on error\n   */\n  async mkNoMedia_() {\n    if (await this.isFile()) {\n      throw new Error(\"mkNoMedia(): \" + this + \" is a file.\")\n    }\n    await this.mkdirp_() // < throws on error\n    const f = this.join(\".NoMedia\")\n    if ((await f.isNotDirectory()) && (await f.isEmpty())) {\n      await f.writeTxt_(\n        [\n          `This directory's contents are excluded from PhotoStructure libraries.`,\n          ``,\n          `See <https://photostructure.com/nomedia/> for details.`\n        ].join(\"\\n\")\n      )\n      emitFileChanged(this.nativePath)\n    }\n  }\n\n  /**\n   * @return this, not the .NoMedia file, so the method can be chained.\n   */\n\n  async mkNoMedia(): PromiseMaybe<this> {\n    try {\n      await this.mkNoMedia_()\n      return this\n    } catch (err) {\n      this.pflog().warn(\"Could not add .NoMedia file to \" + this, err)\n      return undefined\n    }\n  }\n\n  hasNoMedia(): PromiseMaybe<boolean> {\n    return hasNoMedia(this)\n  }\n\n  ignorableCheap() {\n    return ignorablePath(this.nativePath)\n  }\n\n  async ignorable() {\n    return (await this.isDirectory())\n      ? ignorableDirectory(this)\n      : ignorableFile(this)\n  }\n\n  hidden() {\n    return hidden(this)\n  }\n\n  readonly isMountpoint = lazy(\n    async () =>\n      (await this.isDirectory()) &&\n      (await thenMapOr(\n        mountpoints(),\n        arr => arr.includes(this.nativePath),\n        () => false\n      ))\n  )\n\n  isSidecar() {\n    return isSidecarExt(this.ext)\n  }\n\n  /**\n   * @return oldest sidecars first (so newest sidecar metadata wins, as they are\n   * layered on top of eachother)\n   */\n  readonly sidecars = lazy<Promise<this[]>>(async () => {\n    if (this.isSidecar()) return [] // < sidecars don't have sidecars\n    const arr = await this.parent().childDirectoryEntries(\n      ea =>\n        ea.base !== this.base &&\n        isSidecarExt(ea.ext) &&\n        (ea.name === this.name ||\n          ea.name === this.base ||\n          (Settings.matchSidecarsCaseInsensitively.valueOrDefault\n            ? equalsIgnoreCase(ea.name, this.name) ||\n              equalsIgnoreCase(ea.name, this.base)\n            : false) ||\n          nameWithoutCount(ea.name) === nameWithoutCount(this.name) ||\n          (Settings.matchSidecarsCaseInsensitively.valueOrDefault\n            ? equalsIgnoreCase(\n                nameWithoutCount(ea.name),\n                nameWithoutCount(this.name)\n              )\n            : false))\n    )\n\n    if (arr == null) return []\n    const posixFiles = arr.map(ea => this.parent()._directoryEntryChild(ea))\n    return sortByAsync(posixFiles, ea => ea.maxStatMs())\n  })\n\n  /**\n   * should only be used for writes\n   */\n  async sidecar() {\n    return thenOpt(this.sidecars())\n      .flatMap(arr => arr[arr.length - 1])\n      .getOrElse(() =>\n        this.sibling(\n          this.base +\n            ensurePrefix(\n              Settings.defaultSidecarType.valueOrDefault,\n              \".\"\n            ).toLowerCase()\n        )\n      )\n  }\n\n  // TODO: Add observer to fileSha()\n  readonly shaWithSidecars: MemoizedThunk<Promise<string>> = lazy(async () => {\n    const filenames = [this, ...(await this.sidecars())].map(\n      ea => ea.nativePath\n    )\n    const buffer = await fileSha(sort(filenames))\n    return buffer.toString(\"base64\")\n  }, BaseFile.attrTTL)\n\n  async jsonSidecars(): PromiseMaybe<this[]> {\n    // Try not to readdir if possible:\n    const results = await this.siblings(\n      ea =>\n        equalsIgnoreCase(ea.ext, \".json\") &&\n        (ea.name === this.name ||\n          ea.name === this.base ||\n          nameWithoutCount(ea.name) === nameWithoutCount(this.name))\n    )\n    return this.pflog().tap({\n      msg: \"jsonSidecars()\",\n      result:\n        results == null\n          ? undefined\n          : await sortByAsync(results, ea => ea.maxStatMs())\n    })\n  }\n\n  /**\n   * @return whatever was touched latest (this file or a sidecar)\n   */\n  thisOrSidecareMaxMtimeMs(): PromiseMaybe<number> {\n    return this.trap(\"mtimeOrSidecarMs\", async () => {\n      const thisMaxStatMs = await this.mtimeMs()\n      const sidecars = await this.sidecars()\n      const sidecarMaxStats = await Promise.all(\n        toA(sidecars).map(ea => ea.mtimeMs())\n      )\n      const arr = [thisMaxStatMs, ...sidecarMaxStats].filter(gt0)\n      return mapNotEmpty(arr, ea => Math.floor(Math.max(...ea)))\n    })\n  }\n\n  thisOrSidecareMaxMtimeSec(): PromiseMaybe<number> {\n    return thenMap(this.thisOrSidecareMaxMtimeMs(), ea => unixtime(ea))\n  }\n}\n", "import { compact } from \"../../fe/Array\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { map, mapOr } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { strEnum, StrEnumKeys } from \"../../fe/StrEnum\"\nimport { toS } from \"../../fe/toS\"\nimport { MultiMap } from \"../MultiMap\"\nimport { SidecarExts } from \"./SidecarExts\"\n\n// All file types from https://exiftool.org/#supported\n// that don't have a \"-\" in the EXIF column, as well as the PGM/PPM/PBM formats\n\n// 1. Used firefox to pull out table\n// 2. replace /^([^\\t]+)\\t.*?\\t(.+)$/ with `[[\"$1\"],  \"$2\"],`\n// 3. replace /, ([^ ])/ with `\", \"$1`\n\n// TODO: These descriptions will be used in the details pane at some point\n\n// Note that if I don't have an example image, I'm commenting out support (in an\n// effort to be conservative with what we advertise support for)\n\nexport const fileExtsToDesc = [\n  [[\"360\"], \"GoPro 360 video (QuickTime-based)\"],\n  [[\"3FR\"], \"Hasselblad RAW (TIFF-based)\"],\n  [[\"3G2\", \"3GP2\"], \"3rd Gen. Partnership Project 2 a/v (QuickTime-based)\"],\n  [[\"3GP\", \"3GPP\"], \"3rd Gen. Partnership Project a/v (QuickTime-based)\"],\n  // [[\"A\"], \"Unix static library code Archive\"],\n  // [[\"AA\"], \"Audible Audiobook\"],\n  // [[\"AAE\"], \"Apple edit information (XML PLIST-based)\"],\n  // [[\"AAX\"], \"Audible Enhanced Audiobook (QuickTime-based)\"],\n  // [[\"ACR\"], \"American College of Radiology ACR-NEMA (DICOM-like)\"],\n  // [[\"AFM\", \"ACFM\", \"AMFM\"], \"Adobe [Composite/Multiple Master] Font Metrics\"],\n  // [[\"AI\", \"AIT\"], \"Adobe Illustrator [Template] (PS or PDF)\"],\n  // [[\"AIFF\", \"AIF\", \"AIFC\"], \"Audio Interchange File Format [Compressed]\"],\n  // [[\"APE\"], \"Monkey's Audio\"],\n  [[\"ARQ\"], \"Sony Alpha Pixel-Shift RAW (TIFF-based)\"],\n  [[\"ARW\"], \"Sony Alpha RAW (TIFF-based)\"],\n  [[\"ASF\"], \"Microsoft Advanced Systems Format\"],\n  [[\"AVI\"], \"Audio Video Interleaved (RIFF-based)\"],\n  [[\"AVIF\"], \"AV1 Image File Format (QuickTime-based)\"],\n  // [[\"BMP\", \"DIB\"], \"Windows BitMaP / Device Independent Bitmap\"],\n  // [[\"BPG\"], \"Better Portable Graphics\"],\n  // [[\"BTF\"], \"BigTIFF (64-bit Tagged Image File Format)\"],\n  // [[\"CHM\"], \"Microsoft Compiled HTML format\"],\n  // [[\"COS\"], \"Capture One Settings (XML-based)\"],\n  [[\"CR2\"], \"Canon RAW 2 (TIFF-based) (CR2 spec)\"],\n  [[\"CR3\"], \"Canon RAW 3 (QuickTime-based) (CR3 spec)\"],\n  [[\"CRM\"], \"Canon RAW Movie (QuickTime-based)\"],\n  [[\"CRW\", \"CIFF\"], \"Canon RAW Camera Image File Format (CRW spec)\"],\n  // [[\"CS1\"], \"Sinar CaptureShop 1-shot RAW (PSD-based)\"],\n  // [[\"CSV\"], \"Comma-Separated Values\"],\n  [[\"CZI\"], \"Zeiss Integrated Software RAW (ZISRAW)\"],\n  // [\n  //   [\"DCM\", \"DC3\", \"DIC\", \"DICM\"],\n  //   \"DICOM - Digital Imaging and Communications in Medicine\"\n  // ],\n  [[\"DCP\"], \"DNG Camera Profile (DNG-like)\"],\n  [[\"DCR\"], \"Kodak Digital Camera RAW (TIFF-based)\"],\n  // [[\"DFONT\"], \"Macintosh Data Fork Font\"],\n  // [[\"DIVX\"], \"DivX media format (ASF-based)\"],\n  // [[\"DJVU\", \"DJV\"], \"DjVu image (AIFF-like)\"],\n  [[\"DNG\"], \"Digital Negative (TIFF-based)\"],\n  // [[\"DOC\", \"DOT\"], \"Microsoft Word Document/Template (FPX-like)\"],\n  // [[\"DOCX\", \"DOCM\"], \"Office Open XML Document [Macro-enabled]\"],\n  // [[\"DOTX\", \"DOTM\"], \"Office Open XML Document Template [Macro-enabled]\"],\n  // [[\"DPX\"], \"Digital Picture Exchange\"],\n  // [[\"DR4\"], \"Canon DPP version 4 Recipe\"],\n  // [[\"DSS\", \"DS2\"], \"Digital Speech Standard [2]\"],\n  // [[\"DYLIB\"], \"MacOS Mach-O executable and library files\"],\n  [[\"DV\"], \"Digital Video\"],\n  // [[\"DVB\"], \"Digital Video Broadcasting (QuickTime-based)\"],\n  // [[\"DVR-MS\"], \"Microsoft Digital Video Recording (ASF-based)\"],\n  // [[\"EIP\"], \"Capture One Enhanced Image Package (ZIP-based)\"],\n  // [[\"EPS\", \"EPSF\", \"PS\"], \"[Encapsulated] PostScript Format\"],\n  // [[\"EPUB\"], \"Electronic Publication (ZIP/XML-based)\"],\n  [[\"ERF\"], \"Epson RAW Format (TIFF-based)\"],\n  // [[\"EXE\", \"DLL\"], \"DOS/Windows executable and library files\"],\n  [[\"EXIF\"], \"Exchangeable Image File Format metadata (TIFF-based)\"],\n  // [[\"EXR\"], \"Open EXR (Extended Range)\"],\n  [[\"EXV\"], \"Exiv2 metadata file (JPEG-based)\"],\n  // [\n  //   [\"F4A\", \"F4B\", \"F4P\", \"F4V\"],\n  //   \"Adobe Flash Player 9+ Audio/Video (QuickTime-based)\"\n  // ],\n  [[\"FFF\"], \"Hasselblad Flexible File Format (TIFF-based)\"],\n  [[\"FFF\"], \"FLIR Systems thermal image File Format\"],\n  // [[\"FITS\"], \"Flexible Image Transport System\"],\n  // [[\"FLA\"], \"Macromedia/Adobe Flash project (FPX-like)\"],\n  // [[\"FLAC\"], \"Free Lossless Audio Codec\"],\n  // [[\"FLIF\"], \"Free Lossless Image Format\"],\n  // [[\"FLV\"], \"Flash Video\"],\n  // [[\"FPF\"], \"FLIR Public image Format\"],\n  // [[\"FPX\"], \"FlashPix image\"],\n  [[\"GIF\"], \"Compuserve Graphics Interchange Format\"],\n  [[\"GPR\"], \"GoPro RAW (DNG-based)\"],\n  // [[\"GZ\", \"GZIP\"], \"GNU ZIP compressed archive\"],\n  [\n    [\"HDP\", \"WDP\", \"JXR\"],\n    \"Windows HD Photo / Media Photo / JPEG XR (TIFF-based)\"\n  ],\n  [[\"HDR\"], \"Radiance RGBE High Dynamic-Range\"],\n  [[\"HEIC\", \"HEIF\", \"HIF\"], \"High Efficiency Image Format (QuickTime-based)\"],\n  // [[\"HTML\", \"HTM\", \"XHTML\"], \"[Extensible] HyperText Markup Language\"],\n  // [[\"ICC\", \"ICM\"], \"International Color Consortium color profile\"],\n  // [[\"ICS\", \"ICAL\"], \"iCalendar Schedule\"],\n  // [[\"IDML\"], \"Adobe InDesign Markup Language (ZIP/XML-based)\"],\n  [[\"IIQ\"], \"Phase One Intelligent Image Quality RAW (TIFF-based)\"],\n  // [[\"IND\", \"INDD\", \"INDT\"], \"Adobe InDesign Document/Template\"],\n  [[\"INSP\"], \"Insta360 Picture (JPEG-based)\"],\n  [[\"INSV\"], \"Insta360 Video (QuickTime-based)\"],\n  // [[\"INX\"], \"Adobe InDesign Interchange (XML-based)\"],\n  // [[\"ISO\"], \"ISO 9660 disk image\"],\n  // [[\"ITC\"], \"iTunes Cover Flow artwork\"],\n  [[\"J2C\", \"J2K\", \"JPC\"], \"JPEG 2000 codestream\"],\n  [[\"JP2\", \"JPF\", \"JPM\", \"JPX\"], \"JPEG 2000 image [Compound/Extended]\"],\n  [[\"JPEG\", \"JPG\", \"JPE\"], \"Joint Photographic Experts Group image\"],\n  // [[\"JSON\"], \"JavaScript Object Notation\"],\n  // [[\"K25\"], \"Kodak DC25 RAW (TIFF-based)\"],\n  // [[\"KDC\"], \"Kodak Digital Camera RAW (TIFF-based)\"],\n  // [[\"KEY\", \"KTH\"], \"Apple iWork '09 Keynote presentation/Theme\"],\n  // [[\"LA\"], \"Lossless Audio (RIFF-based)\"],\n  // [[\"LFP\", \"LFR\"], \"Lytro Light Field Picture\"],\n  // [[\"LNK\"], \"Microsoft Shell Link (Windows shortcut)\"],\n  // [[\"LRV\"], \"Low-Resolution Video (QuickTime-based)\"],\n  [\n    [\"M2TS\", \"MTS\", \"M2T\" /* \"TS\" */], // skip .ts files\n    \"MPEG-2 Transport Stream (used for AVCHD video)\"\n  ],\n  [[\"M4A\", \"M4B\", \"M4P\", \"M4V\"], \"MPEG-4 Audio/Video (QuickTime-based)\"],\n  // [[\"MACOS\"], \"MacOS ._ sidecar file (may have any extension)\"],\n  // [[\"MAX\"], \"3D Studio MAX (FPX-like)\"],\n  [[\"MEF\"], \"Mamiya (RAW) Electronic Format (TIFF-based)\"],\n  [[\"MIE\"], \"Meta Information Encapsulation (MIE specification)\"],\n  // [[\"MIFF\", \"MIF\"], \"Magick Image File Format\"],\n  // [[\"MKA\", \"MKV\", \"MKS\"], \"Matroska Audio/Video/Subtitle\"],\n  // [[\"MOBI\", \"AZW\", \"AZW3\"], \"Mobipocket electronic book (Palm-based)\"],\n  // [[\"MODD\"], \"Sony Picture Motion metadata (XML PLIST-based)\"],\n  // [[\"MOI\"], \"MOD Information file\"],\n  // [[\"MOS\"], \"Creo Leaf Mosaic (TIFF-based)\"],\n  [[\"MOV\", \"QT\"], \"Apple QuickTime Movie\"],\n  // [[\"MP3\"], \"MPEG-1 layer 3 audio\"],\n  [[\"MP4\"], \"Motion Picture Experts Group version 4 (QuickTime-based)\"],\n  // [[\"MPC\"], \"Musepack Audio\"],\n  [[\"MPEG\", \"MPG\", \"M2V\"], \"Motion Picture Experts Group version 1 or 2\"],\n  // [[\"MPO\"], \"Extended Multi-Picture format (JPEG with MPF extensions)\"],\n  [[\"MQV\"], \"Sony Mobile QuickTime Video\"],\n  [[\"MRW\"], \"Minolta RAW\"],\n  // [[\"MXF\"], \"Material Exchange Format\"],\n  [[\"NEF\"], \"Nikon (RAW) Electronic Format (TIFF-based)\"],\n  // [[\"NMBTEMPLATE\"], \"Apple iWork '09 Numbers Template\"],\n  [[\"NRW\"], \"Nikon RAW (2) (TIFF-based)\"],\n  // [[\"NUMBERS\"], \"Apple iWork '09 Numbers spreadsheet\"],\n  // [[\"O\"], \"Unix compiled code Object\"],\n  // [\n  //   [\"ODB\", \"ODC\", \"ODF\", \"ODG\", \"ODI\", \"ODP\", \"ODS\", \"ODT\"],\n  //   \"Open Document Database/Chart/Formula/Graphics/Image/Presentation/Spreadsheet/Text (ZIP/XML-based)\"\n  // ],\n  // [[\"OFR\"], \"OptimFROG audio (RIFF-based)\"],\n  // [[\"OGG\", \"OGV\"], \"Ogg bitstream container\"],\n  // [[\"ONP\"], \"ON1 Presets\"],\n  // [[\"OPUS\"], \"Ogg Opus audio\"],\n  [[\"ORF\"], \"Olympus RAW Format (TIFF-based)\"],\n  // [[\"OTF\"], \"Open Type Font\"],\n  // [[\"PAC\"], \"Lossless Predictive Audio Compression (RIFF-based)\"],\n  // [[\"PAGES\"], \"Apple iWork '09 Pages document\"],\n  // [[\"PCD\"], \"Kodak Photo CD Image Pac\"],\n  // [[\"PCX\"], \"PC Paintbrush\"],\n  // [[\"PDB\", \"PRC\"], \"Palm Database\"],\n  // [[\"PDF\"], \"Adobe Portable Document Format\"],\n  [[\"PEF\"], \"Pentax (RAW) Electronic Format (TIFF-based)\"],\n  // [[\"PFA\", \"PFB\"], \"PostScript Font ASCII/Binary\"],\n  // [[\"PFM\"], \"Printer Font Metrics\"],\n  // [[\"PGF\"], \"Progressive Graphics File\"],\n  // [[\"PICT\", \"PCT\"], \"Apple Picture file\"],\n  // [[\"PLIST\"], \"Apple Property List (binary and XML formats)\"],\n  // [[\"PMP\"], \"Sony DSC-F1 Cyber-Shot image\"],\n  [[\"PNG\", \"JNG\", \"MNG\"], \"Portable/JPEG/Multiple-image Network Graphics\"],\n  [[\"PPM\", \"PBM\", \"PGM\"], \"Portable Pixel/Bit/Gray Map\"],\n  // [\n  //   [\"PPT\", \"PPS\", \"POT\"],\n  //   \"PowerPoint Presentation/Slideshow/Template (FPX-like)\"\n  // ],\n  // [[\"POTX\", \"POTM\"], \"Office Open XML Presentation Template [Macro-enabled]\"],\n  // [[\"PPAX\", \"PPAM\"], \"Office Open XML Presentation Addin [Macro-enabled]\"],\n  // [[\"PPSX\", \"PPSM\"], \"Office Open XML Presentation Slideshow [Macro-enabled]\"],\n  // [[\"PPTX\", \"PPTM\"], \"Office Open XML Presentation [Macro-enabled]\"],\n  // [[\"PSD\", \"PSB\", \"PSDT\"], \"PhotoShop Document / Large Document / Template\"],\n  // [[\"PSP\", \"PSPIMAGE\"], \"Paint Shop Pro\"],\n  // [[\"QTIF\", \"QTI\", \"QIF\"], \"QuickTime Image File\"],\n  // [[\"R3D\"], \"Redcode RAW video\"],\n  // [[\"RA\"], \"Real Audio\"],\n  [[\"RAF\"], \"FujiFilm RAW Format\"],\n  // [[\"RAM\", \"RPM\"], \"Real Audio/Plug-in Metafile\"],\n  // [[\"RAR\"], \"RAR Archive\"],\n  [[\"RAW\"], \"Kyocera Contax N Digital RAW\"],\n  [[\"RAW\"], \"Panasonic RAW (TIFF-based)\"],\n  // [[\"RIFF\", \"RIF\"], \"Resource Interchange File Format\"],\n  // [[\"RM\", \"RV\", \"RMVB\"], \"Real Media/Video [Variable Bitrate]\"],\n  // [[\"RSRC\"], \"Mac OS Resource\"],\n  // [[\"RTF\"], \"Rich Text Format\"],\n  [[\"RW2\"], \"Panasonic RAW 2 (TIFF-based)\"],\n  [[\"RWL\"], \"Leica RAW (TIFF-based)\"],\n  // [[\"RWZ\"], \"Rawzor compressed image\"],\n  // [[\"SEQ\"], \"FLIR Systems image Sequence\"],\n  // [[\"SKETCH\"], \"Sketch design file\"],\n  // [[\"SO\"], \"Unix ELF executable and Shared Object files\"],\n  [[\"SR2\"], \"Sony RAW 2 (TIFF-based)\"],\n  [[\"SRF\"], \"Sony RAW Format (TIFF-based)\"],\n  [[\"SRW\"], \"Samsung RAW format (TIFF-based)\"],\n  // [[\"SVG\"], \"Scalable Vector Graphics (XML-based)\"],\n  // [[\"SWF\"], \"Shockwave Flash\"],\n  // [[\"THM\"], \"Thumbnail image (JPEG)\"], // don't need to import these.\n  // [[\"THMX\"], \"Office Open XML Theme\"],\n  [[\"TIFF\", \"TIF\"], \"Tagged Image File Format\"],\n  // [[\"TTF\", \"TTC\"], \"True Type Font/Collection\"],\n  // [[\"TORRENT\"], \"BitTorrent description file\"],\n  // [[\"TXT\"], \"Text files\"],\n  // [[\"VCF\", \"VCARD\"], \"Virtual Card\"],\n  // [[\"VOB\"], \"Video Object (MPEG-based)\"],\n  // [[\"VRD\"], \"Canon DPP Recipe Data\"],\n  // [[\"VSD\"], \"Microsoft Visio Drawing (FPX-like)\"],\n  // [[\"WAV\"], \"Windows digital audio WAVeform (RIFF-based)\"],\n  [[\"WEBM\"], \"Google Web Movie (Matroska-based)\"],\n  [[\"WEBP\"], \"Google Web Picture (RIFF-based)\"],\n  [[/*\"WMA\",*/ \"WMV\"], \"Windows Media Audio/Video (ASF-based)\"], // skipping WMA: no audio\n  // [[\"WTV\"], \"Windows recorded TV show\"],\n  // [[\"WV\"], \"WavePack lossless audio (RIFF-based)\"],\n  [[\"X3F\"], \"Sigma/Foveon RAW\"],\n  // [[\"XCF\"], \"GIMP native image format\"],\n  // [[\"XLS\", \"XLT\"], \"Microsoft Excel Spreadsheet/Template (FPX-like)\"],\n  // [\n  //   [\"XLSX\", \"XLSM\", \"XLSB\"],\n  //   \"Office Open XML Spreadsheet [Macro-enabled/Binary]\"\n  // ],\n  // [[\"XLTX\", \"XLTM\"], \"Office Open XML Spreadsheet Template [Macro-enabled]\"],\n  [[\"XMP\"], \"Extensible Metadata Platform sidecar file\"]\n  // [[\"ZIP\"], \"ZIP archive\"]\n] as [string[], string][]\n\nexport const ExtTypes = strEnum(\n  \"RawImage\",\n  \"Sharp\",\n  \"Video\",\n  \"Sidecar\",\n  \"AssetFile\",\n  \"Exif\",\n  \"SupportedByCurrentBrowser\",\n  \"SupportedByOldBrowser\"\n)\n\nexport type ExtType = StrEnumKeys<typeof ExtTypes>\n\nconst ext2types = lazy(() => {\n  const m = new MultiMap<string, ExtType>()\n\n  // First add all base types:\n\n  const RawImageExts = [\n    \"ARQ\",\n    \"ARW\",\n    \"CR2\",\n    \"CR3\",\n    \"CRW\",\n    \"DNG\",\n    \"GPR\",\n    \"MEF\",\n    \"MRW\",\n    \"NEF\",\n    \"NRW\",\n    \"ORF\",\n    \"RAF\",\n    \"RAW\",\n    \"RW2\",\n    \"RWL\",\n    \"SR2\",\n    \"SRF\",\n    \"SRW\"\n  ]\n  for (const ext of RawImageExts) {\n    m.add(ext, ExtTypes.RawImage)\n  }\n\n  const SharpExts = compact([\"GIF\", \"JPEG\", \"PNG\", \"PPM\", \"TIFF\", \"WEBP\"])\n\n  for (const ext of SharpExts) {\n    m.add(ext, ExtTypes.Sharp)\n  }\n\n  const VideoExts = [\n    \"3G2\",\n    \"3GP\",\n    \"ASF\",\n    \"AVI\",\n    \"CRM\",\n    \"M4A\",\n    \"MOV\",\n    \"MP4\",\n    \"MPEG\",\n    \"MQV\",\n    \"MTS\",\n    \"WEBM\",\n    \"WMV\"\n  ]\n  for (const ext of VideoExts) {\n    m.add(ext, ExtTypes.Video)\n  }\n\n  const AssetFileExts = [...SharpExts, \"HEIC\", ...RawImageExts, ...VideoExts]\n\n  for (const ext of AssetFileExts) {\n    m.add(ext, ExtTypes.AssetFile)\n  }\n\n  for (const ext of SidecarExts) {\n    m.add(ext, ExtTypes.Sidecar)\n  }\n\n  for (const ext of [...AssetFileExts, ...SidecarExts]) {\n    m.add(ext, ExtTypes.Exif)\n  }\n\n  for (const ext of [\"GIF\", \"JPEG\", \"MP4\", \"PNG\", \"WEBM\", \"WEBP\"]) {\n    m.add(ext, ExtTypes.SupportedByCurrentBrowser)\n  }\n\n  for (const ext of [\"GIF\", \"JPEG\", \"MP4\", \"PNG\"]) {\n    m.add(ext, ExtTypes.SupportedByOldBrowser)\n  }\n\n  // Then expand with extension \"synonyms\"\n  const exts = fileExtsToDesc.map(ea => ea[0])\n\n  for (const ext of m.keys()) {\n    const aliases = exts.find(ea => ea.includes(ext))\n    if (aliases != null && aliases.length > 0) {\n      const values = m.get(ext)!\n      for (const alias of aliases) {\n        if (!m.has(alias)) {\n          m.set(alias, values)\n        }\n      }\n    }\n  }\n\n  return m\n})\n\nexport function extTypes(ext: Maybe<string>): Maybe<ExtType[]> {\n  return map(normalizeExt(ext), ea => ext2types().get(ea))\n}\n\nconst shortExtRe = /\\.?([a-z0-9]{2,4})$/i\n\nexport function normalizeExt(ext: Maybe<string>): Maybe<string> {\n  return map(shortExtRe.exec(toS(ext)), m => m[1].toUpperCase())\n}\n\nexport function isExtType(ext: Maybe<string>, extType: ExtType) {\n  return mapOr(\n    extTypes(ext),\n    ea => ea.includes(extType),\n    () => false\n  )\n}\n\nexport function mimeRootType(\n  ext: Maybe<string>\n): undefined | \"image\" | \"video\" {\n  const arr = extTypes(ext)\n  return arr == null\n    ? undefined\n    : arr.includes(ExtTypes.Sharp) || arr.includes(ExtTypes.RawImage)\n    ? \"image\"\n    : arr.includes(ExtTypes.Video)\n    ? \"video\"\n    : undefined\n}\n\nexport function isRawImageExt(ext: Maybe<string>): boolean {\n  return isExtType(ext, ExtTypes.RawImage)\n}\nexport function isSharpExt(ext: Maybe<string>): boolean {\n  return isExtType(ext, ExtTypes.Sharp)\n}\nexport function isVideoExt(ext: Maybe<string>): boolean {\n  return isExtType(ext, ExtTypes.Video)\n}\nexport function isSidecarExt(ext: Maybe<string>): boolean {\n  return isExtType(ext, ExtTypes.Sidecar)\n}\nexport function isAssetFileExt(ext: Maybe<string>): boolean {\n  return isExtType(ext, ExtTypes.AssetFile)\n}\nexport function isExifExt(ext: Maybe<string>): boolean {\n  return isExtType(ext, ExtTypes.Exif)\n}\nexport function isSupportedByCurrentBrowserExt(ext: Maybe<string>): boolean {\n  return isExtType(ext, ExtTypes.SupportedByCurrentBrowser)\n}\nexport function isSupportedByOldBrowserExt(ext: Maybe<string>): boolean {\n  return isExtType(ext, ExtTypes.SupportedByOldBrowser)\n}\n", "import { isEmpty } from \"./Array\"\nimport { entries, Valued } from \"./Object\"\nimport { PrimitiveValued } from \"./Primitive\"\nimport { toS } from \"./toS\"\n\nexport function assembleUri(\n  path: string,\n  query: Valued<string | (string | null)[]>\n): string {\n  const q = joinQuery(query)\n  return q === \"\" ? path : path + \"?\" + q\n}\n\nexport function joinQuery(\n  query: PrimitiveValued | Valued<string | (string | null)[]>\n) {\n  if (query == null) return \"\"\n  const e = entries(query).filter(([, v]) => v != null)\n  if (isEmpty(e)) return \"\"\n  return e.map(ea => ea.map(toS).map(encodeURIComponent).join(\"=\")).join(\"&\")\n}\n\n// Note that \"pslib\" is not a schema that is registered by IANA, but it doesn't\n// collide with anything there, so we should be fine. See\n// https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml\n\n// Node URL parsing uses \"protocol\" instead of \"scheme\", and protocol is always\n// suffixed with a colon.\n\n/**\n * URI scheme used for asset files found in the PhotoStructure Library directory\n * hierarchy\n */\nexport const PS_LIBRARY_PROTOCOL = \"pslib\"\n\n/**\n * URI scheme used for asset files found on a local disk volume\n */\nexport const PS_LOCAL_FILE_PROTOCOL = \"psfile\"\n\n/**\n * URI scheme used for asset files found on a network filesystem\n */\nexport const PS_NETWORK_FILESYSTEM_PROTOCOL = \"psnet\"\n", "import { promises as dns } from \"dns\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toInt } from \"../../fe/Number\"\nimport { toS } from \"../../fe/toS\"\nimport { memoizeAsync } from \"../async/MemoizedAsyncFunc\"\nimport { thenMap2Or } from \"../async/Promise\"\nimport { thenOrTimeout } from \"../async/thenOrTimeout\"\nimport { onClearCache } from \"../event/EventEmitter\"\nimport { mkLogger } from \"../Logger\"\nimport { within } from \"../Number\"\nimport { equalsIgnoreCase } from \"../String\"\nimport { ShortCmdTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { ipv4Re } from \"./ping\"\n\nconst octetRE = new RegExp(\"^\" + ipv4Re.source + \"$\")\n\n/**\n * Try to return the \"canonical\" name for the given `ipOrName`.\n */\nexport const friendlyname = memoizeAsync(\n  async (ipOrName: string) => {\n    const result =\n      octetRE.exec(ipOrName) == null ? ipOrName : await nslookup(ipOrName)\n    return toS(result).toLowerCase().normalize()\n  },\n  { maxSize: 128, timeoutMs: ShortCmdTimeoutMs }\n)\n\nconst loopbackRE = /^(?:(?:localhost(?:\\.?(?:localdomain\\.?)?))|(?:127(?:\\.\\d{1,3}){3}))$/i\n\nexport function isLoopback(name: string): boolean {\n  return loopbackRE.exec(name) != null\n}\n\nexport function octets(nameOrIp: string): Maybe<number[]> {\n  const result: number[] = nameOrIp\n    .split(\".\")\n    .map(ea => toInt(ea))\n    .filter(ea => within(0, 255, ea)) as number[]\n  return result.length === 4 ? result : undefined\n}\n\n/**\n * @return 1 or more IPv4 addresses for the given name or IP address\n */\nexport const resolve4 = memoizeAsync(\n  async (nameOrIp: string): PromiseMaybe<string[]> => {\n    if (blank(nameOrIp)) return\n    if (octets(nameOrIp) != null) return [nameOrIp]\n    try {\n      return await dns.resolve4(nameOrIp)\n    } catch (err) {\n      logger().warn(\"No name found for \" + nameOrIp)\n      return\n    }\n  },\n  { maxSize: 256, timeoutMs: ShortCmdTimeoutMs, clearEveryMs: 10 * minuteMs }\n)\n\nconst logger = lazy(() => mkLogger(\"nslookup\"))\n\nlater(() => onClearCache(() => nslookup.clear()))\n\n/**\n * @return the name or IP address\n */\nexport const nslookup = memoizeAsync(\n  async (nameOrIp: string) => {\n    try {\n      const names = await thenOrTimeout(\n        () =>\n          isLoopback(nameOrIp)\n            ? nameOrIp.startsWith(\"127.\")\n              ? [\"localhost\"]\n              : [\"127.0.0.1\"]\n            : octets(nameOrIp) != null\n            ? dns.reverse(nameOrIp)\n            : dns.resolve4(nameOrIp),\n        5 * secondMs // < DNS resolution should be milliseconds.\n      )\n      if (names == null) {\n        logger().info(\"nslookup(\" + nameOrIp + \"): timeout\")\n        return nameOrIp\n      }\n      const firstNonBlank = names.find(notBlank)\n      if (firstNonBlank == null) {\n        logger().warn(\"No name found for \" + nameOrIp)\n        return nameOrIp\n      } else {\n        return firstNonBlank\n      }\n    } catch (err) {\n      logger().warn(\"Failed to look up \" + nameOrIp + \", using name.\", err)\n      return nameOrIp\n    }\n  },\n  { maxSize: 256, timeoutMs: ShortCmdTimeoutMs, clearEveryMs: 10 * minuteMs }\n)\n\nexport async function isEquivalentHost(\n  a: Maybe<string>,\n  b: Maybe<string>\n): Promise<boolean> {\n  if (blank(a) || blank(b)) return false\n  if (equalsIgnoreCase(a, b)) return true\n  if (isLoopback(a) && isLoopback(b)) return true\n  return thenMap2Or(\n    resolve4(a),\n    resolve4(b),\n    (aAddrs, bAddrs) => aAddrs.some(ea => bAddrs.includes(ea)),\n    () => false\n  )\n}\n", "import { stringify } from \"../../fe/JSON\"\nimport { SyncOrAsync } from \"../../fe/OptAsync\"\nimport { FifoCacheAsync } from \"../FifoCache\"\n\nexport interface MemoizedAsyncFunc<A, R> {\n  (a: A): Promise<R>\n  clear(a?: A): void\n  size(): number\n  callCount(): number\n}\n\nexport function memoizeAsync<A, R>(\n  f: (a: A) => SyncOrAsync<R>,\n  opts: { maxSize: number; timeoutMs: number; clearEveryMs?: number }\n): MemoizedAsyncFunc<A, R> {\n  let callCount = 0\n  const store = new FifoCacheAsync<R>(opts)\n  const r: any = (a: A) => {\n    callCount++\n    return store.getOrSetAsync(stringify(a), async () => f(a))\n  }\n  r.clear = (a?: A) => {\n    if (a == null) {\n      store.clear()\n    } else {\n      const aKey = stringify(a)\n      store.deleteIf(ea => aKey === ea)\n    }\n  }\n  r.size = () => store.size\n  r.callCount = () => callCount\n  return r\n}\n", "import { notBlank } from \"../../fe/Blank\"\nimport { minuteMs, secondMs } from \"../../fe/Date\"\nimport { times } from \"../../fe/Number\"\nimport { opt } from \"../../fe/Opt\"\nimport { toS } from \"../../fe/toS\"\nimport { memoizeAsync } from \"../async/MemoizedAsyncFunc\"\nimport { stdout } from \"../child/ChildProcess\"\nimport { pingWin } from \"../fs/PathTo\"\nimport { isWin } from \"../Platform\"\nimport { ShortCmdTimeoutMs } from \"../volumes/VolumeTtls\"\n\nexport const ping = memoizeAsync(\n  async (target: string) => {\n    const cmd = isWin ? await pingWin() : \"ping\"\n    return stdout(cmd, [isWin ? \"-n\" : \"-c\", \"1\", target], {\n      timeout: 5 * secondMs\n    })\n  },\n  { maxSize: 255, timeoutMs: ShortCmdTimeoutMs, clearEveryMs: 10 * minuteMs }\n)\n\nexport const ipv4Re = new RegExp(\n  \"\\\\b\" + times(4, () => \"[0-9]{1,3}\").join(\"\\\\.\") + \"\\\\b\"\n)\n\nexport const ipAddrFromPing = memoizeAsync(\n  async (target: string) => {\n    return opt(\n      await ping(target).catch(err => {\n        console.warn(\"failed to ping: \" + err)\n        return undefined\n      })\n    )\n      .filter(notBlank)\n      .flatMap(result => ipv4Re.exec(toS(result)))\n      .map(match => match[0])\n      .get()\n  },\n  { maxSize: 255, timeoutMs: ShortCmdTimeoutMs, clearEveryMs: 10 * minuteMs }\n)\n", "import { compact } from \"../../fe/Array\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { map } from \"../../fe/Maybe\"\nimport { filterAsync, thenMapOr } from \"../async/Promise\"\nimport { stdout } from \"../child/ChildProcess\"\nimport { eql } from \"../Eql\"\nimport { BaseFile } from \"../fs/BaseFile\"\nimport { CmdTimeoutMs, MountpointsTtlMs } from \"./VolumeTtls\"\n\n// /dev/disk1s1 on / (apfs, local, journaled)\nconst parseRe = /^([a-z0-9/ -_]+) on (.+?) \\((.+)\\)$/i\n\nexport interface Mount {\n  filesystem: string\n  mountpoint: string\n  options: string[]\n}\nexport async function mounts() {\n  const _mounts = await stdout(\"mount\", [], { timeout: CmdTimeoutMs })\n  return compact(\n    _mounts.split(\"\\n\").map(ea => {\n      return map(parseRe.exec(ea), m => {\n        const [filesystem, mountpoint, opts] = m.slice(1)\n        const options = opts.split(\",\").map(opt => opt.trim())\n        return {\n          filesystem,\n          mountpoint,\n          options\n        }\n      })\n    })\n  )\n}\n\nexport const ignorableMacFilesystems = lazy(async () => {\n  return filterAsync(await mounts(), async m => {\n    return (\n      m.options.includes(\"nobrowse\") ||\n      m.options.includes(\"quarantine\") ||\n      (await isInstallDmg(m.mountpoint))\n    )\n  }).then(arr => arr.map(ea => ea.filesystem))\n}, MountpointsTtlMs)\n\nexport async function isInstallDmg(mountpoint: string) {\n  const f = BaseFile.for(mountpoint)\n  const names = await thenMapOr(\n    await f.childNames(),\n    arr =>\n      arr\n        .filter(ea => !ea.startsWith(\".\"))\n        .map(ea => ea.toLowerCase())\n        .sort(),\n    () => []\n  )\n  return eql(names, [\"applications\", \"photostructure.app\"])\n}\n", "import { notBlank } from \"../../fe/Blank\"\nimport { toInt } from \"../../fe/Number\"\nimport { toS } from \"../../fe/toS\"\nimport { stdout } from \"../child/ChildProcess\"\nimport { parseFixed } from \"../Fixed\"\nimport { isMac } from \"../Platform\"\nimport { ignorableMacFilesystems } from \"./Mount\"\nimport { DfVolume } from \"./Volume\"\nimport { CmdTimeoutMs } from \"./VolumeTtls\"\n\nfunction k2b(s: string): number {\n  return toInt(s, { defaultValue: 0 })! * 1024\n}\n\nconst ignorableMacFsTypes = [\"devfs\"]\n// NOTE: DO NOT EXCLUDE \"/dev/mapper/ubuntu--vg-root\", that may be the root (and\n// only!) filesystem\n// TODO: is it bad to include tmpfs?\nconst ignorableLinuxFsTypes = [\"udev\", \"tmpfs\", \"devtmpfs\", \"shm\"]\nconst ignorableFsTypes = isMac ? ignorableMacFsTypes : ignorableLinuxFsTypes\n\nconst ignorableMountpoints = [\"/boot/efi\", \"/dev/shm\"]\n\nexport async function dfPosixRaw(\n  localsOnly: boolean,\n  path?: string\n): Promise<DfVolume[]> {\n  const ignoreFs = isMac ? await ignorableMacFilesystems() : []\n  const args = [\"-k\", \"-P\"]\n  if (localsOnly) args.push(\"-l\")\n  if (notBlank(path)) args.push(path)\n  const output = await stdout(\"df\", args, {\n    timeout: CmdTimeoutMs,\n    // https://askubuntu.com/questions/1227667/df-command-throws-error-on-run-user-1000-doc-folder\n    ignoreStderr: true,\n    ignoreExitCode: true\n  })\n  const parsed = parseFixed(\n    [\n      \"Filesystem\",\n      \"1024-blocks\",\n      \"Used\",\n      \"Available\",\n      \"Capacity\",\n      \"Mounted on\"\n    ],\n    output\n  )\n  return parsed\n    .map(ea => ({\n      filesystem: ea[\"Filesystem\"],\n      size: k2b(ea[\"1024-blocks\"]),\n      used: k2b(ea[\"Used\"]),\n      available: k2b(ea[\"Available\"]),\n      mountpoint: ea[\"Mounted on\"]\n    }))\n    .filter(ea => {\n      const fs = toS(ea.filesystem)\n      const mp = toS(ea.mountpoint)\n      return (\n        notBlank(mp) &&\n        !ignorableMountpoints.includes(mp) &&\n        notBlank(fs) &&\n        !ignoreFs.includes(fs) &&\n        !ignorableFsTypes.includes(fs)\n      )\n    }) as DfVolume[]\n}\n", "import { mapNotBlank, notBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { map } from \"../../fe/Maybe\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { opt } from \"../../fe/Opt\"\nimport { memoizeAsync } from \"../async/MemoizedAsyncFunc\"\nimport { thenFlatten, thenMap, thenMapOr } from \"../async/Promise\"\nimport { thenOrTimeout } from \"../async/thenOrTimeout\"\nimport { stdout, stdoutResult } from \"../child/ChildProcess\"\nimport { BaseFile } from \"../fs/BaseFile\"\nimport { mkLogger } from \"../Logger\"\nimport { isDocker, isLinux } from \"../Platform\"\nimport { stripPrefix, stripSuffix } from \"../String\"\nimport { dfPosixRaw } from \"./DfPosixRaw\"\nimport { Volume } from \"./Volume\"\nimport {\n  CmdTimeoutMs,\n  LongMountpointsTtlMs,\n  MountpointsTtlMs,\n  ShortCmdTimeoutMs\n} from \"./VolumeTtls\"\n\nexport const isGioSupported = lazy(async () => {\n  if (!isLinux || isDocker()) {\n    return false\n  }\n\n  try {\n    const result = await stdoutResult(GioCommand, [\"version\"], {\n      timeout: CmdTimeoutMs,\n      ignoreStderr: true\n    })\n    return result.code === 0\n  } catch (err) {\n    return false\n  }\n})\n\nexport const GioCommand = \"gio\"\nexport const GioMountMonitorArgs = [\"mount\", \"--monitor\", \"--anonymous\"]\n\nconst gvlog = lazy(() => mkLogger(\"Gio.gioVolumes()\"))\n\n/**\n * The `gio` subsystem may not be installed, in which case, we have to poll\n * the results of `df`.\n */\n/**\n * These volumes won't be in a `df` list.\n */\n// DO NOT USE keyedLazy here, as mountpoints() uses this function!\nexport const gioVolumes = lazy(\n  () =>\n    thenOrTimeout(\n      async () => {\n        // We need to find the FUSE mountpoints that gvfs is using:\n        const dirs = await gvfsFuseDirectories()\n        const vols: Volume[] = (\n          await thenFlatten(\n            dirs.map(async dir => {\n              const rawVols = await dfPosixRaw(false, dir.nativePath).catch(\n                err => {\n                  gvlog().warn(\"Failed to df \" + dir + \": \" + err)\n                  return\n                }\n              )\n              const vol = map(rawVols, ea => ea[0])\n              map(vol, ea => (ea.mountpoint = dir.nativePath))\n              return vol\n            })\n          )\n        ).filter(vol => vol.size > 0)\n\n        return Promise.all(\n          vols.map(async vol =>\n            thenMapOr(\n              getRemoteInfo(vol.mountpoint),\n              remoteInfo => {\n                vol.remoteHost = remoteInfo.remoteHost\n                vol.remoteShare = remoteInfo.remoteShare\n                vol.label = remoteInfo.displayName\n                vol.remote = true\n                return vol\n              },\n              () => vol\n            )\n          )\n        )\n      },\n      MountpointsTtlMs,\n      () =>\n        mkLogger(\"Gio.gioVolumes\").warn(\n          \"timed out after \" + MountpointsTtlMs + \"ms\"\n        )\n    ),\n  LongMountpointsTtlMs\n)\n\nconst riLog = mkLogger(\"Gio.getRemoteInfo()\")\n\nconst getRemoteInfo = memoizeAsync(\n  async (mountpoint: string) => {\n    try {\n      const lines = (\n        await stdout(GioCommand, [\"info\", mountpoint], {\n          timeout: CmdTimeoutMs\n        })\n      ).split(/[\\n\\r]+/)\n      const uri = mapNotBlank(\n        lines.find(ea => ea.startsWith(\"uri: \")),\n        ea => new URL(stripPrefix(ea, \"uri: \"))\n      )\n      return {\n        displayName: map(\n          lines.find(ea => ea.startsWith(\"display name: \")),\n          ea => stripPrefix(ea, \"display name: \")\n        ),\n        remoteHost: map(uri, ea => ea.hostname),\n        remoteShare: opt(uri)\n          .flatMap(ea => ea.pathname)\n          .flatMap(ea => stripPrefix(ea, \"/\"))\n          .flatMap(ea => stripSuffix(ea, \"/\"))\n          .flatMap(decodeURIComponent)\n          .filter(notBlank)\n          .get()\n      }\n    } catch (err) {\n      riLog.warn(\"gio info failed\", { mountpoint, err })\n      return\n    }\n  },\n  { maxSize: 255, timeoutMs: ShortCmdTimeoutMs, clearEveryMs: 10 * minuteMs }\n)\n\n// $ grep gvfs /etc/mtab\n// gvfsd-fuse /run/user/1000/gvfs fuse.gvfsd-fuse rw,nosuid,nodev,relatime,user_id=1000,group_id=1000 0 0\n\nexport const mtabEntries = lazy<PromiseMaybe<string[]>>(async () => {\n  return thenMap(BaseFile.for(\"/proc/mounts\").readLines(), lines =>\n    lines\n      .filter(line => line.startsWith(\"gvfsd-fuse \"))\n      .map(line => line.split(\" \")[1])\n  )\n}, LongMountpointsTtlMs)\n\nasync function gvfsFuseDirectories(): Promise<BaseFile[]> {\n  if (!(await isGioSupported())) return []\n  return thenFlatten(\n    await thenMap(mtabEntries(), arr =>\n      arr.map(ea => BaseFile.for(ea).clear().childDirectories())\n    )\n  )\n}\n", "import { DateObject, DateTime, Duration, Info } from \"luxon\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { isDate, secondMs } from \"../../fe/Date\"\nimport { map, mapOr } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0, round, toInt } from \"../../fe/Number\"\nimport { opt } from \"../../fe/Opt\"\nimport { cmp } from \"../../fe/Primitive\"\nimport { pad2 } from \"../String\"\n\nexport function cmpDate(a?: Date, b?: Date): number {\n  const aTime = mapOr(\n    a,\n    d => d.getTime(),\n    () => 0\n  )\n  const bTime = mapOr(\n    b,\n    d => d.getTime(),\n    () => 0\n  )\n  return cmp(aTime, bTime)\n}\n\nexport function msUntil(d?: Date): number {\n  if (d == null) return 0\n  const ts = d.getTime()\n  const n = Date.now()\n  return ts <= n ? 0 : ts - n\n}\n\nexport function closeTo(a: Maybe<Date>, b: Maybe<Date>, maxMsDelta: number) {\n  return (\n    a != null && b != null && Math.abs(a.getTime() - b.getTime()) <= maxMsDelta\n  )\n}\n\nexport function nowish(d: Maybe<number | Date>, maxMsDelta = 2500): boolean {\n  return d == null\n    ? false\n    : isDate(d)\n    ? closeTo(d, new Date(), maxMsDelta)\n    : Math.abs(d - Date.now()) < maxMsDelta\n}\n\nexport function isRecentMs(\n  timeMs: Maybe<number>,\n  delta = 5 * secondMs\n): boolean {\n  return gt0(timeMs) && Date.now() - timeMs <= delta\n}\n\nexport function datestampUTC(d: Date = new Date()): string {\n  return (\n    d.getUTCFullYear() +\n    \"-\" +\n    pad2(d.getUTCMonth() + 1) +\n    \"-\" +\n    pad2(d.getUTCDate())\n  )\n}\n\nexport function filestamp(d: Date = new Date()): string {\n  return [\n    d.getFullYear(),\n    pad2(d.getMonth() + 1),\n    pad2(d.getDate()),\n    \"-\",\n    pad2(d.getHours()),\n    pad2(d.getMinutes()),\n    pad2(d.getSeconds())\n  ].join(\"\")\n}\n\nexport function filestampUTC(d: Date = new Date()): string {\n  return [\n    d.getUTCFullYear(),\n    pad2(d.getUTCMonth() + 1),\n    pad2(d.getUTCDate()),\n    \"-\",\n    pad2(d.getUTCHours()),\n    pad2(d.getUTCMinutes()),\n    pad2(d.getUTCSeconds())\n  ].join(\"\")\n}\n\nexport function fmtMs(ms: number): string {\n  return Duration.fromMillis(ms).toFormat(\"m:s.S\")\n}\n\nexport function durationToPaddedHMS(ms: number): string {\n  return Duration.fromMillis(ms).toFormat(\"hhhh:mm:ss.SSS\")\n}\n\nexport function durationHMS(ms: number): string {\n  return Duration.fromMillis(round(ms / secondMs) * secondMs).toFormat(\n    \"h:mm:ss\"\n  )\n}\n\nexport function isoNow() {\n  return new Date().toISOString()\n}\n\nexport function utcIsoToTs(iso: Maybe<string>): Maybe<number> {\n  return opt(iso)\n    .filter(notBlank)\n    .map(ea => DateTime.fromISO(ea))\n    .filter(ea => ea.isValid)\n    .map(ea => ea.toMillis())\n    .get()\n}\n\nexport function nowLocal() {\n  return agoLocal(0)\n}\n\nexport function agoLocal(agoMs: number) {\n  return dateTimeToLocal(DateTime.local().plus(-agoMs))!\n}\n\nexport function dateTimeToLocal(d: DateTime): Maybe<number> {\n  return map(\n    dateTimeToLocalSec(d),\n    ea => ea * 100 + millisToLocalSuffix(d.millisecond)\n  )\n}\n\nexport function dateTimeToLocalSec(d: DateTime): Maybe<number> {\n  return d == null || !d.isValid ? undefined : toInt(d.toFormat(\"yMMddHHmmss\"))\n}\n\nexport function millisToLocalSuffix(ms: number) {\n  // NOTE: we floor here rather than rounding as we don't want to deal with\n  // rounding up to a different minute or hour (or day or year)\n  // HONEST IT'S OK IT'S ONLY +/- 5 milliseconds.\n  return Math.floor(ms / 10)\n}\n\nexport function localToDateObject(\n  local: Maybe<number>,\n  offset?: Maybe<number>\n): Maybe<DateObject> {\n  if (local == null || local < 0) return\n  let i = local\n  const pop2 = () => {\n    const result = i % 100\n    i = Math.floor(i / 100)\n    return result\n  }\n  const millisecond = 10 * pop2()\n  const second = pop2()\n  const minute = pop2()\n  const hour = pop2()\n  const day = pop2()\n  const month = pop2()\n  const year = i\n  return {\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    zone: map(offset, ea => Info.normalizeZone(ea))\n  }\n}\n\nexport function localToDateTime(\n  local: Maybe<number>,\n  offset?: Maybe<number>\n): Maybe<DateTime> {\n  return map(localToDateObject(local, offset), ea => DateTime.fromObject(ea))\n}\n\n/**\n * Convert local numeric to millis-from-common-epoch timestamp\n */\nexport function localToTs(\n  local: Maybe<number>,\n  offset?: Maybe<number>\n): Maybe<number> {\n  return map(localToDateTime(local, offset), ea => ea.toMillis())\n}\n\n/**\n * This should only be used by tests, as a timestamp has already lost relevant\n * timezone offset.\n * @param ts is a millis-from-common-epoch timestamp\n */\nexport function tsToLocal(ts: number): number {\n  const d = new Date(ts)\n  return toInt(\n    [\n      d.getFullYear(),\n      ...[\n        d.getMonth() + 1,\n        d.getDate(),\n        d.getHours(),\n        d.getMinutes(),\n        d.getSeconds(),\n        millisToLocalSuffix(d.getUTCMilliseconds())\n      ].map(pad2)\n    ].join(\"\")\n  )!\n}\n\n/**\n * @return local numeric of `local` plus `ms` millis\n */\nexport function localPlusMs(local: number, ms: number): number {\n  return dateTimeToLocal(localToDateTime(local)!.plus(ms))!\n}\n", "import { ChildProcess } from \"child_process\"\nimport { compact } from \"../../fe/Array\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { errorToS, isError } from \"../../fe/Error\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { map, mapOr } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt } from \"../../fe/Number\"\nimport { opt } from \"../../fe/Opt\"\nimport { toS } from \"../../fe/toS\"\nimport {\n  addEndable,\n  Endable,\n  EndableRank,\n  EndableRanks,\n  ending\n} from \"../async/Endable\"\nimport { thenNot } from \"../async/Promise\"\nimport { Promises } from \"../async/Promises\"\nimport { isRecentMs } from \"../date/Date\"\nimport { onError } from \"../error/Error\"\nimport {\n  FatalErrorFlag,\n  isFatalError,\n  isIgnorableError\n} from \"../error/ErrorTypes\"\nimport { WrappedError } from \"../error/WrappedError\"\nimport { onDataChunked } from \"../fs/StreamChunker\"\nimport { endStream } from \"../fs/Streams\"\nimport { mkLogger } from \"../Logger\"\nimport { Rate } from \"../math/Rate\"\nimport { Try } from \"../Object\"\nimport { pidExists } from \"../Pids\"\nimport { serviceShutdownTimeoutMs } from \"../ServiceNames\"\nimport { Settings } from \"../settings/Settings\"\nimport { ellipsize } from \"../String\"\nimport { endProcess, spawn } from \"./ChildProcess\"\n\nexport interface WatchedChildOpts {\n  name: string\n  childFactory: () => ChildProcess | Promise<ChildProcess>\n  dataSep?: string | RegExp\n  maxErrorsPerMinute?: number\n  endableRank?: EndableRank\n  exitCommand?: string\n  restartOnExit?: boolean // should only be false when we test sync\n}\n\nexport interface WatchedChildListener {\n  onStdout(data: string): void\n\n  /**\n   * @return true if the error should be propagated to onError\n   */\n  onStderr?(data: string): boolean\n\n  /**\n   * @return true if the error requires the child process to be restarted\n   */\n  onError(source: string, error: any): boolean\n\n  onRestart?(): void\n\n  /**\n   * Is it OK to start if we can't shut down a prior child process?\n   */\n  ignoreStopErrors: boolean // should be true for non-PS daemons\n}\n\n// so basic\nexport function mkBasicWatchedChild(\n  args: {\n    cmd: string\n    args: string[]\n  } & Partial<WatchedChildListener>\n) {\n  const wc: WatchedChild = new WatchedChild({\n    name: compact([args.cmd, ...args.args]).join(\" \"),\n    childFactory: () => {\n      // Restart every 30 minutes to prevent memory leaks:\n      return spawn(args.cmd, args.args, 30 * minuteMs)\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onStdout: () => {},\n    onError: () => true,\n    ignoreStopErrors: true,\n    ...args\n  })\n  return wc\n}\n\n/**\n * BatchCluster is for ephemeral clusters of stateless processes.\n *\n * To watch a single, long-lived process, though, we need different management\n * heuristics than what batch-cluster gives us:\n *\n * 1. Start the child on construction\n * 2. Delegate all stdout, and errors to the provided listener\n * 3. Restart the child if it crashes/ends and this process hasn't ended\n * 4. The caller may need to specifically stop(), and then arbitrarily later, start()\n * 5. Notify the listener if the error rate is too high, or restarts are\n *    \"flapping\" (more than N restarts per some period of where the child spins\n *    up and immediately fails). It's up to the listener to then do something\n *    with that state information (including potentially end the current\n *    process).\n *\n * This class is used for `gio`, `findmnt`, `diskutil`, as well as the `sync`\n * and `web` PhotoStructure daemons.\n */\nexport class WatchedChild implements Endable {\n  readonly name: string\n  readonly startMs = Date.now()\n  private _stopped = false\n  private readonly logger = lazy(() =>\n    mkLogger(\"WatchedChild(\" + compact([this.name, this.pid]).join(\":\") + \")\")\n  )\n  readonly startRate = new Rate(2 * minuteMs)\n  readonly mutex = new Promises()\n  readonly opts: Required<WatchedChildOpts> & WatchedChildListener\n  private _ended = false\n  private lastError?: WrappedError\n  private cp?: ChildProcess\n\n  readonly endTimeoutMs: number\n\n  constructor(opts: WatchedChildOpts & WatchedChildListener) {\n    this.name = opts.name\n    this.opts = {\n      dataSep: \"\\n\",\n      maxErrorsPerMinute: 3,\n      endableRank: EndableRanks.first,\n      exitCommand: \"\",\n      restartOnExit: true,\n      ...opts\n    }\n    // Let the web or db service take some time to close, vacuum, and back up the db.\n    this.endTimeoutMs = serviceShutdownTimeoutMs(this.name as any)\n    addEndable(this.opts.endableRank, this)\n    void this._restart()\n  }\n\n  get stopped() {\n    return this._stopped\n  }\n\n  get ended() {\n    return this._ended\n  }\n\n  async end() {\n    this._ended = true\n    return this._stop()\n  }\n\n  get proc(): Maybe<ChildProcess> {\n    return this.cp\n  }\n\n  get pid(): Maybe<number> {\n    return map(this.cp, ea => ea.pid)\n  }\n\n  get msSinceLastStart(): number {\n    return this.startRate.msSinceLastEvent\n  }\n\n  running(): Promise<boolean> {\n    return mapOr(\n      this.pid,\n      ea => pidExists(ea),\n      async () => false\n    )\n  }\n\n  notRunning(): Promise<boolean> {\n    return thenNot(this.running())\n  }\n\n  /**\n   * Shuts down the current process. The process won't start again until restart() is called.\n   * @return false if stop failed\n   */\n  async stop(): Promise<boolean> {\n    this.logger().info(\"stop()\")\n    this._stopped = true\n    return this.mutex.serial(`WatchedChild(${this.name}).stop`, () => {\n      this._stopped = true\n      return this._stop()\n    })\n  }\n\n  private async _stop(): Promise<boolean> {\n    this.logger().info(\"_stop()\", {\n      stopped: this._stopped,\n      ended: this._ended\n    })\n    const cp = this.cp\n    this.cp = undefined\n    if (cp == null) return true // nothing to stop\n    return this.stopChild(cp)\n  }\n\n  private async stopChild(cp: ChildProcess) {\n    // Send the exit command, if it isn't blank, and stdin is still open:\n    await opt(this.opts.exitCommand)\n      .filter(notBlank)\n      .flatMap(cmd =>\n        opt(cp)\n          .flatMap(ea => ea.stdin)\n          .filter(ea => ea.writable)\n          .forEach(ea => Try(() => ea.write(cmd + \"\\n\"))) // prevent EPIPE if proc has ended\n          .map(endStream)\n          .get()\n      )\n    return endProcess(cp, this.endTimeoutMs)\n  }\n\n  readonly onError = async (src: string, err: Buffer | string | Error) => {\n    const fatal = isFatalError(src) || isFatalError(err)\n    const error = new WrappedError({\n      message: src + map(err, errorToS),\n      cause: isError(err) ? err : undefined\n    })\n    const ignorable = isIgnorableError(error)\n    const ctx = { src, fatal, ignorable, errToS: errorToS(err) }\n    this.logger().log(ignorable ? \"warn\" : \"error\", \"onError()\", ctx)\n    if (this._ended || ignorable) {\n      return\n    }\n\n    this.lastError = error\n    onError(src, error)\n\n    if (fatal) {\n      return this.end()\n    }\n\n    const requiresRestart = this.opts.onError(src, err)\n    if (requiresRestart) {\n      this.logger().warn(\"onError requested restart\", ctx)\n      return this._restart()\n    } else {\n      return\n    }\n  }\n\n  isErrorRateExceeded() {\n    return this.logger().tap({\n      msg: \"isErrorRateExceeded()\",\n      result: gt(this.startRate.eventsPerMinute, this.opts.maxErrorsPerMinute),\n      meta: {\n        startRatePerMin: this.startRate.eventsPerMinute,\n        maxErrorsPerMin: this.opts.maxErrorsPerMinute\n      }\n    })\n  }\n\n  async restart(force = false) {\n    this.logger().info(\"restart()\", {\n      stopped: this._stopped,\n      ended: this._ended\n    })\n    if (this._ended || ending()) return false\n    if (\n      !force &&\n      this.startRate.msSinceLastEvent <\n        Settings.minTimeBetweenServiceRestartsMs.valueOrDefault\n    ) {\n      this.logger().info(\"restart(): last restart was too recent. Ignoring.\", {\n        msSinceLastEvent: this.startRate.msSinceLastEvent,\n        minTimeBetweenServiceRestartsMs:\n          Settings.minTimeBetweenServiceRestartsMs.valueOrDefault\n      })\n      return\n    }\n    return this.mutex.serial(`WatchedChild(${this.name}).restart`, async () => {\n      await this._stop()\n      this._stopped = false\n      return this._start()\n    })\n  }\n\n  async start() {\n    this.logger().info(\"start()\", {\n      stopped: this._stopped,\n      ended: this._ended\n    })\n    return this.mutex.serial(`WatchedChild(${this.name}).start`, async () => {\n      this._stopped = false\n      return this._start()\n    })\n  }\n\n  /**\n   * Only called by onError/onExit, and pauses restarts if error rate is too high.\n   * @return false if errors\n   */\n  private async _restart() {\n    this.logger().info(\"_restart()\", {\n      stopped: this._stopped,\n      ended: this._ended\n    })\n    return this.mutex.maybeRun(\n      `WatchedChild(${this.name})._restart`,\n      async () => {\n        await this._stop()\n        if (this._stopped || this._ended) return false\n        if (this.isErrorRateExceeded()) {\n          this.logger().warn(\n            \"Cannot restart, error/restart rate is too high.\",\n            {\n              errorsPerMinute: this.startRate.eventsPerMinute,\n              msSinceLastStart: this.startRate.msSinceLastEvent\n            }\n          )\n          // If we're just spinning up, die.\n          if (isRecentMs(this.startMs, Settings.probationMs.valueOrDefault)) {\n            onError(\n              \"Can't restart \" +\n                this.name +\n                \", failure rate is too high.\" +\n                FatalErrorFlag,\n              this.lastError\n            )\n          }\n          return false\n        }\n        this.logger().info(\"restart()\", {\n          currentPid: this.pid,\n          startRate: this.startRate,\n          maxErrorsPerMinute: this.opts.maxErrorsPerMinute\n        })\n\n        // eslint-disable-next-line no-unused-expressions\n        this.opts.onRestart?.()\n\n        return this._start()\n      }\n    )\n  }\n\n  // CAREFUL: this must be protected by this.mutex!\n\n  /**\n   * @return true if new pid was started\n   */\n  private async _start(): Promise<boolean> {\n    this.logger().info(\"_start()\", {\n      stopped: this._stopped,\n      ended: this._ended\n    })\n    if (this._stopped || this._ended) return false\n    if (await this.running()) return false\n    this.startRate.onEvent()\n    const cp = (this.cp = await this.opts.childFactory())\n\n    // Pick up the new PID:\n    this.logger.unset()\n    this.logger().info(\"_start(): spawned pid \" + this.pid)\n\n    const ctx = \"cp(\" + cp.pid + \")\"\n    ;[\n      { o: cp, desc: \"\" },\n      { o: cp.stdin, desc: \".stdin\" },\n      { o: cp.stdout, desc: \".stdout\" },\n      { o: cp.stderr, desc: \".stderr\" }\n    ].forEach(({ o, desc }) => {\n      map(o, ea =>\n        ea.on(\"error\", err => this.onError(ctx + desc + \".on(error)\", err))\n      )\n    })\n\n    void map(this.cp.stdout, sout =>\n      onDataChunked(sout, this.opts.dataSep, ea => {\n        this.logger().trace(\"onDataChunked()\", ea)\n        this.opts.onStdout(ea)\n      })\n    )\n\n    void map(this.cp.stderr, serr =>\n      serr.on(\"data\", s => {\n        if (toS(s).includes(\"Error: Cannot find module\")) {\n          onError(\n            \"Failed to start \" + this.name + FatalErrorFlag,\n            new Error(ellipsize(s, 256))\n          )\n        }\n        if (this.opts.onStderr?.(s) === true) {\n          void this.onError(ctx + \".stderr.on(data)\", s)\n        }\n      })\n    )\n\n    this.cp.on(\"exit\", async (code: number | null, signal: string | null) => {\n      this.logger().info(\"onExit\", {\n        code,\n        signal,\n        stopped: this._stopped,\n        ended: this._ended\n      })\n      if (this.opts.restartOnExit) {\n        await this._restart()\n        this.logger().info(\n          \"onExit(): finished setting up new child \" + this.pid\n        )\n      } else {\n        this.logger().info(\n          \"onExit(): this.opts.restartOnExit is false. Ending \" + this.pid\n        )\n        void this.end()\n      }\n    })\n    return true\n  }\n}\n", "import { clearTimeout } from \"timers\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { setUnrefTimeout } from \"./async/Timers\"\n\nexport interface Debounced {\n  (...args: any[]): void\n  reset(): void\n  now(): void\n}\n\n/**\n * Node-specific debounce. Not for frontend use.\n */\nexport function debounce(\n  f: (...args: any[]) => void,\n  timeoutMs: number\n): Debounced {\n  timeoutMs = Math.ceil(timeoutMs)\n  let lastTimeout: Maybe<NodeJS.Timeout>\n  let args: any[] = []\n  const r: any = (...a: any[]) => {\n    args = a\n    map(lastTimeout, clearTimeout)\n    lastTimeout = setUnrefTimeout(() => f(...args), timeoutMs)\n  }\n  r.reset = () => {\n    map(lastTimeout, clearTimeout)\n    lastTimeout = undefined\n  }\n  r.now = () => {\n    r.reset()\n    f()\n  }\n  return r\n}\n", "import { compactBlanks } from \"../../fe/Array\"\nimport { map } from \"../../fe/Maybe\"\nimport { thenMap } from \"../async/Promise\"\nimport { mkLogger } from \"../Logger\"\nimport { dfPosixRaw } from \"./DfPosixRaw\"\nimport { gioVolumes, isGioSupported } from \"./Gio\"\n\nconst log = mkLogger(\"Mountpoints.localMountpointSetup()\")\n\nexport async function mountpointsPosix() {\n  const mountpoints = await thenMap(dfPosixRaw(false), vols =>\n    compactBlanks(vols.map(vol => vol.mountpoint))\n  )\n  if (mountpoints != null && (await isGioSupported())) {\n    try {\n      await thenMap(gioVolumes(), gioVols =>\n        mountpoints.push(...gioVols.map(ea => ea.mountpoint))\n      )\n    } catch (err) {\n      // may fail due to timeouts. It's better to have *some* volumes than crash:\n      log.warn(\"Failed to fetch gio volumes\", err)\n    }\n  }\n  return map(mountpoints, arr =>\n    arr.filter(ea => !ea.startsWith(\"/snap/\") && ea !== \"/dev\")\n  )\n}\n", "import { isNotEmpty } from \"../../fe/Array\"\nimport { secondMs } from \"../../fe/Date\"\nimport { thenOpt } from \"../../fe/OptAsync\"\nimport { stdout } from \"../child/ChildProcess\"\nimport { fsutil } from \"../fs/PathTo\"\nimport { PowerShell } from \"../pwsh/PowerShell\"\n\nconst driveletterRe = /\\s([A-Z]:\\\\)/g\n\n/**\n * @throws on error\n */\nexport const mountpointsWin = async () => {\n  return thenOpt(\n    PowerShell.instance().executeJsonToA(\n      \"Get-PSDrive -PSProvider FileSystem | Select-Object -Property Root\"\n    )\n  )\n    .flatMap<string[]>(arr => arr.map(ea => ea.Root))\n    .filter(isNotEmpty)\n    .orElse(() => mountpointsWinFsutil())\n    .map(ea => ea.sort())\n    .getRequired()\n}\n\n/**\n * fsutil-based list of all currently active drive letters\n *\n * @return [\"C:\\\", \"D:\\\", ...]\n */\nexport const mountpointsWinFsutil = async () => {\n  // Note that `fsutil fsinfo drives` seems to be about an order of magnitude\n  // faster than ` wmic logicaldisk get caption`.\n\n  // Example output: Drives: C:\\ H:\\ I:\\\"\"\n  const sout = (\n    await stdout(await fsutil(), [\"fsinfo\", \"drives\"], {\n      timeout: 10 * secondMs\n    })\n  ).trim()\n  const result: string[] = []\n  let match: RegExpExecArray | null\n  while ((match = driveletterRe.exec(sout)) !== null) {\n    result.push(match[1])\n  }\n  return result\n}\n", "import { retryOnReject } from \"../../fe/AsyncRetry\"\nimport { secondMs } from \"../../fe/Date\"\nimport { later, unrefDelay } from \"../../fe/Delay\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { end } from \"../async/Endable\"\nimport { firstDefinedLater, LaterMaybe } from \"../async/Later\"\nimport { awaitAll } from \"../async/Promise\"\nimport { stdoutResult } from \"../child/ChildProcess\"\nimport { mkBasicWatchedChild } from \"../child/WatchedChild\"\nimport { debounce } from \"../Debounce\"\nimport { onError } from \"../error/Error\"\nimport { onClearCache } from \"../event/EventEmitter\"\nimport { mkLogger } from \"../Logger\"\nimport { isLinux, isMac, isWin } from \"../Platform\"\nimport { isRpcServer } from \"../ServiceNames\"\nimport {\n  GioCommand,\n  GioMountMonitorArgs,\n  gioVolumes,\n  isGioSupported,\n  mtabEntries\n} from \"./Gio\"\nimport { mountpointsPosix } from \"./MountpointsPosix\"\nimport { mountpointsWin } from \"./MountpointsWin\"\nimport {\n  CmdTimeoutMs,\n  LongMountpointsTtlMs,\n  MountpointsTtlMs\n} from \"./VolumeTtls\"\n\nexport const nonRpcMountpoints = () =>\n  isWin ? mountpointsWin() : mountpointsPosix()\n\nlet rpcMountpoints: Maybe<LaterMaybe<string[]>>\n\nexport function setRpcMountpointsImpl(f: typeof rpcMountpoints) {\n  rpcMountpoints = f\n  void localMountpointSetup() // < make sure we run setup\n}\n\nexport const localMountpointSetup = lazy(async () => {\n  if (isRpcServer()) {\n    later(async () => {\n      const log = mkLogger(\"Mountpoints.localMountpointSetup()\")\n      if (isMac) {\n        log.info(\"Setting up Mac diskutil activity watcher\")\n        mountpoints.setTTL(LongMountpointsTtlMs)\n        diskUtilActivity()\n      }\n      if (isLinux) {\n        if (await isGioSupported()) {\n          log.info(\"Setting up Linux gio mount monitor\")\n          mountpoints.setTTL(LongMountpointsTtlMs)\n          gioMountMonitor()\n        }\n        if (await isFindmntSupported()) {\n          log.info(\"Setting up Linux findmnt mount monitor\")\n          mountpoints.setTTL(LongMountpointsTtlMs)\n          findmntPoll()\n        }\n      }\n    }, 30 * secondMs).unref() // let startup go faster. This can wait.\n  } else {\n    await awaitAll([\n      end(diskUtilActivity.clear()),\n      end(gioMountMonitor.clear()),\n      end(findmntPoll.clear())\n    ])\n  }\n})\n\n/**\n * @return undefined if errors are raised\n */\nexport const mountpoints = lazy(async () => {\n  const impl = () => firstDefinedLater(rpcMountpoints, nonRpcMountpoints)\n  const result = await retryOnReject(impl, {\n    maxRetries: 3,\n    onRetryWaitUntil: i => unrefDelay(i * 1500)\n  }).catch(err => {\n    onError(\"mountpoints() failed\", err)\n    return undefined\n  })\n  return result?.sort()\n}, MountpointsTtlMs)\n\nlater(() => onClearCache(() => mountpoints.unset()))\n\n/**\n * Provides near-real-time updates when volumes change on macs:\n */\nexport const diskUtilActivity = lazy(() =>\n  mkBasicWatchedChild({\n    cmd: \"diskutil\",\n    args: [\"activity\"],\n    onStdout: debounce(() => mountpoints.unset(), 1.5 * secondMs)\n  })\n)\n\nexport const gioMountMonitor = lazy(() =>\n  mkBasicWatchedChild({\n    cmd: GioCommand,\n    args: GioMountMonitorArgs,\n    onStdout: debounce(() => {\n      gioVolumes.unset()\n      mtabEntries.unset()\n      mountpoints.unset()\n    }, 1.5 * secondMs)\n  })\n)\n\nconst isFindmntSupported = lazy(async () => {\n  if (!isLinux) return false\n  try {\n    const result = await stdoutResult(\"findmnt\", [\"--version\"], {\n      timeout: CmdTimeoutMs,\n      ignoreStderr: true\n    })\n    return result.code === 0\n  } catch (err) {\n    return false\n  }\n})\n\nexport const findmntPoll = lazy(() =>\n  mkBasicWatchedChild({\n    cmd: \"findmnt\",\n    args: [\"--poll\"],\n    onStdout: debounce(() => {\n      mtabEntries.unset()\n      mountpoints.unset()\n    }, 1.5 * secondMs)\n  })\n)\n", "import { retryOnReject } from \"../../fe/AsyncRetry\"\nimport { later } from \"../../fe/Delay\"\nimport { MemoizedThunk } from \"../../fe/Lazy\"\nimport { Later } from \"../async/Later\"\nimport { timedLazy } from \"../async/PromiseTimer\"\nimport { isIgnorableError } from \"../error/ErrorTypes\"\nimport { onClearCache } from \"../event/EventEmitter\"\nimport { mountpoints } from \"./Mountpoints\"\nimport { CmdTimeoutMs, LongTtlMs } from \"./VolumeTtls\"\n\n/**\n * lazy-ify `l` with retries\n */\nexport function lazyFsAsync<T>(\n  name: string,\n  l: Later<T>\n): MemoizedThunk<Promise<T>> {\n  const result = timedLazy(\n    \"vol.\" + name,\n    () =>\n      retryOnReject(l, {\n        maxRetries: 2,\n        timeoutMs: CmdTimeoutMs,\n        errorIsRetriable: err => isIgnorableError(err)\n      }),\n    LongTtlMs\n  )\n  mountpoints.onChange(() => result.unset())\n  later(() => onClearCache(() => result.unset()))\n  return result\n}\n", "import { thenMap } from \"../async/Promise\"\nimport { dfPosixRaw } from \"./DfPosixRaw\"\nimport { gioVolumes, isGioSupported } from \"./Gio\"\nimport { lazyFsAsync } from \"./LazyFsAsync\"\n\nconst localMountpoints = lazyFsAsync(\n  \"localMountpoints\",\n  // We'll assume gio mountpoints are always remote, so we can ignore gio stuff\n  // here:\n  () => thenMap(dfPosixRaw(true), vols => vols.map(vol => vol.mountpoint))\n)\n\nexport const dfPosix = lazyFsAsync(\"dfPosix\", async () => {\n  const vols = await dfPosixRaw(false)\n  if (vols == null) return\n  await thenMap(localMountpoints(), locals => {\n    vols.forEach(vol => {\n      vol.remote = !locals.includes(vol.mountpoint)\n    })\n  })\n  if (await isGioSupported()) {\n    await thenMap(gioVolumes(), gv => vols.push(...gv))\n  }\n  return vols\n})\n", "import { compact } from \"../../fe/Array\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { secondMs } from \"../../fe/Date\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { opt } from \"../../fe/Opt\"\nimport { toS } from \"../../fe/toS\"\nimport { thenMap } from \"../async/Promise\"\nimport { stdout } from \"../child/ChildProcess\"\nimport { parseFixed } from \"../Fixed\"\nimport { wmic } from \"../fs/PathTo\"\nimport { toMap } from \"../Map\"\nimport { Try } from \"../Object\"\nimport { isWin } from \"../Platform\"\nimport { PowerShell } from \"../pwsh/PowerShell\"\nimport { ensureSuffix } from \"../String\"\nimport { lazyFsAsync } from \"./LazyFsAsync\"\nimport { Volume } from \"./Volume\"\n\n/*\n$ wmic netuse get LocalName, RemoteName, COnnectionState, Status\nConnectionState  LocalName  RemoteName        Status\nConnected        H:         \\\\10.1.1.7\\homes  OK\nDisconnected     I:         \\\\10.1.1.3\\mrm    Unavailable\n*/\n\nexport async function addRemoteVolumeInfoWin(\n  volumes: Volume[],\n  netInfos?: NetInfo[]\n): Promise<Volume[]> {\n  if (!isWin) throw new Error(\"wtf\")\n  await thenMap(\n    orElse<NetInfo[] | PromiseMaybe<NetInfo[]>>(netInfos, () => netInfoWin()),\n    arr => {\n      const m = toMap(arr, ea => [ea.mountpoint, ea])\n      volumes.forEach(vol => {\n        map(m.get(vol.mountpoint), netInfo => {\n          vol.remote = true\n          vol.remoteHost = netInfo.host\n          vol.remoteShare = netInfo.share\n          vol.ok = netInfo.ok\n        })\n      })\n    }\n  )\n  return volumes\n}\n\nconst columns = [\"LocalName\", \"RemoteName\", \"Status\"]\nconst netuseCmd = [\"NETUSE\", \"get\", columns.join(\",\")]\n\nexport interface NetInfo {\n  /** \"H:\\\" */\n  mountpoint: string\n  /** probably the IP address of the remote share */\n  host: string\n  /** the name of the share */\n  share: string\n  /** true if the Status of the share is \"OK\" */\n  ok: boolean\n}\n\nconst UNC_RE = /^\\\\\\\\(.+?)\\\\(.+)$/\nconst driveLetterRE = /^[a-z]:\\\\?$/i\n\nexport const NetInfoCmd = `Get-WmiObject Win32_NetworkConnection | Select-Object -Property LocalName,RemoteName,ConnectionState,Status`\n\nasync function _netInfoWin(): Promise<NetInfo[]> {\n  const result = await PowerShell.instance().executeJsonToA(\n    `Get-WmiObject Win32_NetworkConnection | Select-Object -Property LocalName,RemoteName,ConnectionState,Status`\n  )\n\n  return result == null\n    ? _netInfoWinWmic()\n    : compact(\n        result\n          .filter((ea: any) => notBlank(ea.LocalName)) // can't do anything if we don't have a localname.\n          .map((ea: any) =>\n            map(parseRemoteName(ea.RemoteName), ({ host, share }) =>\n              map(driveLetterRE.exec(toS(ea.LocalName)), driveLetter => ({\n                mountpoint: ensureSuffix(driveLetter[0], \"\\\\\"),\n                host,\n                share,\n                ok: ea.Status === \"OK\" && ea.ConnectionState === \"Connected\"\n              }))\n            )\n          )\n      )\n}\n\nexport function parseRemoteName(\n  remoteName: string\n): Maybe<{ host: string; share: string }> {\n  if (blank(remoteName)) return\n\n  return opt(remoteName)\n    .flatMap(ea => UNC_RE.exec(ea))\n    .map(ea => ({\n      host: ea[1],\n      share: ea[2]\n    }))\n    .orElse(() =>\n      opt(remoteName)\n        .flatMap(url => Try(() => new URL(url)))\n        .filter(url => notBlank(url.hostname))\n        .map(url => ({\n          host: url.hostname,\n          share: opt(url.pathname)\n            .filter(notBlank)\n            .getOrElse(() => \"/\")\n        }))\n    )\n    .get()\n}\n\nexport async function _netInfoWinWmic(): Promise<NetInfo[]> {\n  const cmd = wmic()\n  const sout = await stdout(cmd, netuseCmd, { timeout: 15 * secondMs })\n  const parsed = parseFixed(columns, sout)\n  return compact(\n    parsed.map(ea =>\n      map(UNC_RE.exec(toS(ea.RemoteName)), remoteName =>\n        map(driveLetterRE.exec(toS(ea.LocalName)), driveLetter => ({\n          mountpoint: ensureSuffix(driveLetter[0], \"\\\\\"),\n          host: remoteName[1],\n          share: remoteName[2],\n          ok: ea.Status === \"OK\"\n        }))\n      )\n    )\n  )\n}\n\nconst netInfoWin = lazyFsAsync(\"netInfoWin\", _netInfoWin)\n", "import { sort, uniq } from \"../../fe/Array\"\nimport { notBlank, notBlankAnd } from \"../../fe/Blank\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { map } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { gt0 } from \"../../fe/Number\"\nimport { compactBlankValues } from \"../../fe/Object\"\nimport { thenCollect } from \"../../fe/Promise\"\nimport { toS } from \"../../fe/toS\"\nimport { onError } from \"../error/Error\"\nimport { mkLogger } from \"../Logger\"\nimport { Pojo } from \"../Object\"\nimport { PowerShell } from \"../pwsh/PowerShell\"\nimport { equalsIgnoreCase } from \"../String\"\nimport { lazyFsAsync } from \"./LazyFsAsync\"\nimport { parseRemoteName } from \"./RemoteVolumesWin\"\nimport { Volume } from \"./Volume\"\n\nconst logger = lazy(() => mkLogger(\"DfWin\"))\n\nexport const dfWin = lazyFsAsync(\"dfWin\", async () => {\n  // Try to fetch local and net volumes. If that times out, downgrade to just\n  // local volumes:\n  const disks = await volumeInfoWin()\n  return disks.filter(d => d.ok !== false && gt0(d.size))\n})\n\n// Returns network-mapped drives, but doesn't get operational status or UUIDs:\nexport const GetPsDrive =\n  \"Get-PSDrive -PSProvider FileSystem | Select-Object -Property Root,DisplayRoot,Description,Used,Free\"\n\nfunction parseGetPsDriveRow(ea: Pojo): Maybe<Volume> {\n  return notBlank(ea.Root) && ea.Free != null && ea.Used != null\n    ? {\n        mountpoint: ea.Root,\n        label: ea.Description,\n        size: ea.Used + ea.Free,\n        used: ea.Used,\n        available: ea.Free,\n        remote: notBlank(ea.DisplayRoot),\n        ...map(parseRemoteName(ea.DisplayRoot), remote => ({\n          remoteHost: remote.host,\n          remoteShare: remote.share\n        }))\n      }\n    : undefined\n}\n\n// Get-Disk and Get-Partition return physical (not logical) disk info.\n\n// No remote drives, but we get UUIDs:\nexport const GetVolume =\n  \"Get-Volume | Select-Object -Property DriveLetter,FileSystem,FileSystemLabel,Size,SizeRemaining,HealthStatus,OperationalStatus,UniqueId\"\n\nconst uuidRE = /\\{([-a-z0-9]{7,})\\}/i\n\n/**\n * @param s \"\\\\?\\Volume{717926df-0000-0000-0000-50e01f000000}\\\"\n */\nfunction uniqueId2uuid(s: Maybe<string>) {\n  return logger().tap({\n    msg: \"uniqueId2uuid\",\n    result: map(uuidRE.exec(toS(s)), m => m[1]),\n    meta: { s }\n  })\n}\n\nfunction parseGetVolumeRow(o: Pojo): Maybe<Volume> {\n  // We don't care about system recovery volumes:\n  if (\n    o.DriveLetter == null ||\n    o.DriveLetter === \"null\" ||\n    o.FileSystemLabel === \"System Reserved\"\n  ) {\n    return\n  }\n  const ok =\n    o.Size != null &&\n    o.SizeRemaining != null &&\n    notBlank(o.DriveLetter) &&\n    (notBlankAnd(o.HealthStatus, ea => equalsIgnoreCase(ea, \"Healthy\")) ||\n      notBlankAnd(o.OperationalStatus, ea => equalsIgnoreCase(ea, \"OK\")))\n  return {\n    mountpoint: o.DriveLetter + \":\\\\\",\n    filesystem: o.FileSystem,\n    label: o.FileSystemLabel,\n    uuid: uniqueId2uuid(o.UniqueId),\n    size: o.Size,\n    used: o.Size - o.SizeRemaining,\n    available: o.SizeRemaining,\n    remote: false, // Get-Volume only returns local drives.\n    ok\n  }\n}\n\nexport async function volumeInfoWin(): Promise<Volume[]> {\n  const getPsDrive = await thenCollect(\n    PowerShell.instance()\n      .executeJsonToA(GetPsDrive)\n      .catch(err => {\n        onError(\"volumeInfoWin(): LocalAndNetCmd failed\", err)\n        return []\n      }),\n    ea => compactBlankValues(parseGetPsDriveRow(ea))\n  )\n\n  const getVolumes = await thenCollect(\n    PowerShell.instance()\n      .executeJsonToA(GetVolume)\n      .catch(err => {\n        onError(\"_localAndNet(): LocalCmd failed\", err)\n        return []\n      }),\n    ea => compactBlankValues(parseGetVolumeRow(ea))\n  )\n\n  // Don't include any mountpoints that are unhealthy:\n  const unhealthy = uniq(\n    [...getPsDrive, ...getVolumes]\n      .filter(ea => ea.ok === false)\n      .map(ea => ea.mountpoint)\n  )\n\n  const mountpoints = sort(\n    uniq([...getPsDrive, ...getVolumes].map(ea => ea.mountpoint)).filter(\n      ea => !unhealthy.includes(ea)\n    )\n  )\n\n  logger().info(\"volumeInfoWin()\", {\n    getPsDrive,\n    getVolumes,\n    mountpoints,\n    unhealthy\n  })\n\n  return mountpoints.map(mountpoint => ({\n    ...getPsDrive.find(ea => mountpoint === ea.mountpoint)!,\n    ...getVolumes.find(ea => mountpoint === ea.mountpoint)!\n  })) as Volume[]\n}\n", "import { blank } from \"../../fe/Blank\"\nimport { mapOr } from \"../../fe/Maybe\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { thenMap } from \"../../fe/Promise\"\nimport { stdout } from \"../child/ChildProcess\"\nimport { toMap } from \"../Map\"\nimport { hasAnyIgnoreCase } from \"../String\"\nimport { lazyFsAsync } from \"./LazyFsAsync\"\nimport { DfVolume, Volume } from \"./Volume\"\nimport { CmdTimeoutMs } from \"./VolumeTtls\"\n\n/*\n$ diskutil info -all\nDevice Identifier:        disk0s7\nDevice Node:              /dev/disk0s7\nWhole:                    No\nPart of Whole:            disk0\nDevice / Media Name:      Untitled 7\n\nVolume Name:              Not applicable (no file system)\n\nMounted:                  Not applicable (no file system)\n\nFile System:              None\n\nPartition Type:           Apple_Boot\nOS Can Be Installed:      No\nMedia Type:               Generic\nProtocol:                 SATA\nSMART Status:             Verified\nVolume UUID:              476B3B07-6CFE-3D16-B776-36D0A61244A9\nDisk / Partition UUID:    8F500ACC-D8D9-4135-9234-C3644C543F1D\n\nTotal Size:               650.0 MB (650002432 Bytes) (exactly 1269536 512-Byte-Units)\nVolume Free Space:        Not applicable (no file system)\nDevice Block Size:        512 Bytes\n\nRead-Only Media:          No\nRead-Only Volume:         Not applicable (no file system)\n\nDevice Location:          Internal\nRemovable Media:          No\n\nSolid State:              Yes\n\n**********\n\nDevice Identifier:        disk0s8\nDevice Node:              /dev/disk0s8\nWhole:                    No\nPart of Whole:            disk0\nDevice / Media Name:      Untitled 4\n\nVolume Name:              Untitled 4\n\nMounted:                  Yes\nMount Point:              /Volumes/Untitled 4\n\nFile System Personality:  Journaled HFS+\nType (Bundle):            hfs\nName (User Visible):      Mac OS Extended (Journaled)\nJournal:                  Journal size 24576 KB at offset 0x68f000\nOwners:                   Enabled\n\nPartition Type:           Apple_HFS\nOS Can Be Installed:      Yes\nMedia Type:               Generic\nProtocol:                 SATA\nSMART Status:             Verified\nVolume UUID:              D97628B4-1ADA-3DEC-A500-6636193E26EE\nDisk / Partition UUID:    3BC4303B-DD12-4AFF-9513-5B37BB53B778\n\nTotal Size:               225.0 GB (225000001536 Bytes) (exactly 439453128 512-Byte-Units)\nVolume Free Space:        223.8 GB (223788535808 Bytes) (exactly 437086984 512-Byte-Units)\nDevice Block Size:        512 Bytes\nAllocation Block Size:    4096 Bytes\n\nRead-Only Media:          No\nRead-Only Volume:         No\n\nDevice Location:          Internal\nRemovable Media:          No\n\nSolid State:              Yes\n\n**********\n*/\n\nexport async function addLocalVolumeInfoMac(\n  vols: DfVolume[]\n): PromiseMaybe<Volume[]> {\n  return thenMap(mnt2uuidMac(), uuids =>\n    vols.map(vol =>\n      mapOr(\n        uuids.get(vol.mountpoint),\n        info => ({ ...vol, ...info }),\n        () => vol\n      )\n    )\n  )\n}\n\nexport const mnt2uuidMac = lazyFsAsync(\"mnt2uuidMac\", async () => {\n  const sout = await stdout(\"diskutil\", [\"info\", \"-all\"], {\n    timeout: CmdTimeoutMs\n  })\n  const volumes = sout.split(/^\\s*\\*{8,12}\\s*$/m)\n  return toMap(volumes, volumeLines => {\n    const volumeInfo = toMap(volumeLines.split(/\\s*\\n+\\s*/), line => {\n      const [key, val] = line.split(\":\").map(ea => ea.trim())\n      return hasAnyIgnoreCase([\"not applicable\", \"no file system\"], val)\n        ? undefined\n        : [key.toLowerCase(), val]\n    })\n    const mountpoint = volumeInfo.get(\"mount point\")\n    const label = volumeInfo.get(\"volume name\")\n    const uuid = volumeInfo.get(\"volume uuid\")\n    // There's a lot more interesting metadata we're throwing away here, maybe\n    // TODO look at this later?\n    return blank(mountpoint) ? undefined : [mountpoint, { label, uuid }]\n  })\n})\n", "import { StringValued } from \"../fe/Object\"\nimport { splitLines } from \"./fs/CRLF\"\nimport { stripPreSuff } from \"./String\"\n\n/**\n * Parser for sh environment variable assignments, like `FOO=\"bar\"`.\n *\n * Pairs may be one per line or joined on a single line.\n *\n * \\# Comments are removed.\n */\nexport function parseEnvTokens({\n  input,\n  lowerCaseKeys\n}: {\n  input: string\n  lowerCaseKeys: boolean\n}): StringValued {\n  const result = {}\n  let m\n  for (const line of splitLines(input).filter(\n    ea => ea.match(/^\\s*#/) == null\n  )) {\n    const re = /([a-z_]+)\\s*=\\s*([\"'])?((?:\\\\[\"']|.)*?)(\\2)(?:$|\\s+|#.*?)/gim\n    while ((m = re.exec(line)) != null) {\n      const [, key, quot, val] = m\n      result[lowerCaseKeys ? key.toLowerCase() : key] = stripPreSuff(\n        val,\n        quot,\n        quot\n      )\n    }\n  }\n  return result\n}\n", "import { uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { map2Numeric, toInt } from \"../../fe/Number\"\nimport { thenMap } from \"../../fe/Promise\"\nimport { mapAsync } from \"../async/Promise\"\nimport { stdout } from \"../child/ChildProcess\"\nimport { parseEnvTokens } from \"../EnvTokens\"\nimport { splitLines } from \"../fs/CRLF\"\nimport { isDirectory } from \"../fs/Path\"\nimport { mkLogger } from \"../Logger\"\nimport { isDocker } from \"../Platform\"\nimport { sortIgnoreCase } from \"../String\"\nimport { lazyFsAsync } from \"./LazyFsAsync\"\nimport { DfVolume, Volume } from \"./Volume\"\nimport { CmdTimeoutMs } from \"./VolumeTtls\"\n\n/*\n * lsblk --json! I LOVE YOU but I can't have you\n$ lsblk --json --output mountpoint,uuid\n{\n   \"blockdevices\": [\n      {\"mountpoint\": \"/snap/vlc/190\", \"uuid\": null},\n      {\"mountpoint\": null, \"uuid\": null},\n      {\"mountpoint\": \"/home/archive\", \"uuid\": \"5bcd3874-036b-4c80-ad00-258d34f5a097\"},\n      {\"mountpoint\": null, \"uuid\": null},\n      {\"mountpoint\": \"/boot/efi\", \"uuid\": \"32BA-03AC\"},\n      {\"mountpoint\": \"/\", \"uuid\": \"45e94248-490a-4224-b067-3ea48bb062e5\"},\n      {\"mountpoint\": \"[SWAP]\", \"uuid\": \"f8fbf87c-3ba3-4618-b733-74dab6f67cf2\"},\n      {\"mountpoint\": \"/home\", \"uuid\": \"bf676327-0a04-42ff-8088-313fad5082f7\"}\n   ]\n}\n\nbecause --json is fairly new (requires 2.27+). SO SAD.\n\nThis works with debian jessie:\n\n$ lsblk -P --output mountpoint,uuid\nMOUNTPOINT=\"/snap/kde-frameworks-5/26\" UUID=\"\"\nMOUNTPOINT=\"/snap/spotify/16\" UUID=\"\"\nMOUNTPOINT=\"/snap/core/4650\" UUID=\"\"\nMOUNTPOINT=\"/snap/inkscape/4019\" UUID=\"\"\nMOUNTPOINT=\"/snap/spotify/13\" UUID=\"\"\nMOUNTPOINT=\"/snap/vlc/365\" UUID=\"\"\nMOUNTPOINT=\"/snap/core/4917\" UUID=\"\"\nMOUNTPOINT=\"/snap/ffmpeg/13\" UUID=\"\"\nMOUNTPOINT=\"/snap/core/4830\" UUID=\"\"\nMOUNTPOINT=\"/snap/vlc/190\" UUID=\"\"\nMOUNTPOINT=\"/snap/docker/179\" UUID=\"\"\nMOUNTPOINT=\"\" UUID=\"\"\nMOUNTPOINT=\"\" UUID=\"fRFzBv-zld2-4ZJR-zbYw-C3sX-K9pI-KjnP1v\"\nMOUNTPOINT=\"/\" LABEL=\"root\" UUID=\"a7713a75-f1d9-4aba-8cdf-028a9339faee\"\n\n */\n\nconst logger = lazy(() => mkLogger(\"LocalVolumesPosix\"))\n\nexport async function addLocalVolumeInfoPosix(vols: DfVolume[]) {\n  return thenMap(await localVolumeInfoPosix(), infos => {\n    const mountpoints = sortIgnoreCase(\n      uniq([\n        ...infos.filter(ea => !ea.ignorable).map(ea => ea.mountpoint),\n        ...vols.map(ea => ea.mountpoint)\n      ])\n    )\n\n    return mountpoints.map(mountpoint => ({\n      ...vols.find(ea => ea.mountpoint === mountpoint),\n      ...infos.find(ea => ea.mountpoint === mountpoint)\n    })) as Volume[]\n  })\n}\n\nexport const localVolumeInfoPosix = lazyFsAsync(\n  \"localVolumeInfoPosix\",\n  async () => {\n    const sout = await stdout(\n      \"lsblk\",\n      [\"-P\", \"-b\", \"--output\", \"mountpoint,label,fsused,fsavail,uuid\"],\n      {\n        timeout: CmdTimeoutMs // we may need to wait for spinning rust to spin up.\n      }\n    )\n    const allMountpoints = splitLines(sout)\n      .map(input => parseEnvTokens({ input, lowerCaseKeys: true }))\n      .filter(ea => ea != null)\n\n    const result = await mapAsync(allMountpoints, async ea => {\n      const ignorable =\n        blank(ea.mountpoint) ||\n        ea.mountpoint.startsWith(\"/snap/\") ||\n        ea.mountpoint === \"/boot\" ||\n        ea.mountpoint.startsWith(\"/boot/\") ||\n        !(await isDirectory(ea.mountpoint)) // < docker can bind-mount files. Ignore those.\n      return map2Numeric(\n        toInt(ea.fsused),\n        toInt(ea.fsavail),\n        (used, available) => ({\n          mountpoint: ea.mountpoint,\n          label: ea.label as Maybe<string>,\n          uuid: ea.uuid,\n          ignorable,\n          used,\n          available,\n          size: used + available,\n          ...(!isDocker() ? { remote: false } : undefined)\n        })\n      )\n    })\n\n    return logger().tap({\n      msg: \"lsblk\",\n      result\n    })\n  }\n)\n", "import { map, mapOr } from \"../../fe/Maybe\"\nimport { toS } from \"../../fe/toS\"\nimport { Volume } from \"./Volume\"\n\n/* \n\non mac el capitan for SMB/CIFS:\n\n//mrm@rusty._smb._tcp.local/homes ...\n//mrm@rusty.local/photos ...\n//mrm@rusty/web ...\n\non ubuntu 18:\n\n//10.1.1.7/homes ...\n\nWith NFS:\n\n192.168.1.10:/opt/Media ...\n\n*/\n\nconst smbRe = /^\\/\\/(?:.+@)?(.+?)(?:\\._(?:smb|afs|nfs|tcp)){0,2}(?:\\.local)?\\/(.+)$/i\n\nexport const nfsRe = /^([^:\\s]+):(\\/.+)$/\n\nexport async function addRemoteVolumeInfoPosix(\n  volumes: Volume[]\n): Promise<Volume[]> {\n  volumes\n    .filter(ea => ea.remote)\n    .forEach(ea => {\n      mapOr(\n        smbRe.exec(toS(ea.filesystem)),\n        m => {\n          ea.remoteHost = m[1]\n          ea.remoteShare = m[2]\n        },\n        () =>\n          map(nfsRe.exec(toS(ea.filesystem)), m => {\n            ea.remoteHost = m[1]\n            ea.remoteShare = m[2]\n          })\n      )\n    })\n  return volumes\n}\n", "import { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { MaybeSyncOrAsync } from \"../../fe/OptAsync\"\nimport { onError } from \"../error/Error\"\nimport { thenOrTimeout } from \"./thenOrTimeout\"\n\nexport async function tryWithErrorHandling<T>(\n  f: () => MaybeSyncOrAsync<T>,\n  opts: {\n    context?: string\n    message: string\n    timeoutMs?: number\n  }\n): PromiseMaybe<T> {\n  try {\n    return await (opts.timeoutMs == null\n      ? f()\n      : thenOrTimeout(f, opts.timeoutMs, () =>\n          onError(opts.message + \": timeout\", undefined, opts.context)\n        ))\n  } catch (error) {\n    onError(opts.message, error, opts.context)\n    return undefined\n  }\n}\n", "import { randomBytes } from \"crypto\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { decuss } from \"../Cuss\"\n\n/**\n * Type-4 UUID\n *\n * @see https://en.wikipedia.org/wiki/Universally_unique_identifier\n */\nexport function uuid() {\n  const b = randomBytes(16)\n\n  // Set the version bits:\n  b[6] = (b[6] & 0x0f) | 0x40\n\n  // RFC 4122 Section 3 requires that the characters be generated in lower case\n  const s = b.toString(\"hex\")\n\n  // canonical 8-4-4-4-12 format string:\n  return [\n    s.slice(0, 8),\n    s.slice(8, 12),\n    s.slice(12, 16),\n    s.slice(16, 20),\n    s.slice(20)\n  ].join(\"-\")\n}\n\n/**\n * Type-4 UUID without naughty words\n */\nexport function safeUUID(): string {\n  return decuss(uuid)\n}\n\n// only useful for tests:\nexport const UUIDRegExp = lazy(() => /^\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}$/)\n", "import { thenOrTimeout } from \"../../fe/AsyncRetry\"\nimport { notBlank, notBlankOr } from \"../../fe/Blank\"\nimport { isFalse, isTrue } from \"../../fe/Boolean\"\nimport { later } from \"../../fe/Delay\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { getOrSet } from \"../../fe/Map\"\nimport { PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { thenOpt } from \"../../fe/OptAsync\"\nimport { thenMap } from \"../async/Promise\"\nimport { withBoundedConcurrency } from \"../async/Promises\"\nimport { tryWithErrorHandling } from \"../async/TryWithErrorHandling\"\nimport { onClearCache } from \"../event/EventEmitter\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { mkLogger } from \"../Logger\"\nimport { safeUUID } from \"../math/UUID\"\nimport { Settings } from \"../settings/Settings\"\nimport { mountpoints } from \"./Mountpoints\"\nimport { Volume } from \"./Volume\"\nimport { MountpointsTtlMs } from \"./VolumeTtls\"\n\nconst logger = lazy(() => mkLogger(\"VolumeUUID\"))\n\nexport const VolumeUuidTimeoutMs = MountpointsTtlMs / 2\n\n// This isn't a TTLMap because we don't expect to have bajillions of\n// mountpoints, they don't expire, and we force-clear it whenever mountpoints\n// change.\nconst cache = new Map<string, PromiseMaybe<string>>()\n\nlater(() => {\n  onClearCache(() => cache.clear())\n  mountpoints.onChange(() => cache.clear())\n})\n\nexport async function addVolumeUUIDs(vols: Volume[]): Promise<void> {\n  await withBoundedConcurrency({\n    name: \"addVolumeUUIDs\",\n    laters: vols.map(ea => () => addVolumeUUID(ea))\n  })\n}\n\n/**\n * Prefer the UUID stored on the mountpoint/.uuid.\n *\n * If that cannot be read, use the UUID already on the volume.\n *\n * If that is missing/timesout, use the last-set UUID for that volume, stored in\n * APP_DATA/mountpoint-uuids.json\n */\nasync function addVolumeUUID(v: Volume): Promise<void> {\n  if (isTrue(v.ignorable)) {\n    // Don't bother reading the .uuid.\n    logger().debug(\"volumeUUID(): ignorable is true for \" + v.mountpoint)\n    return\n  }\n\n  if (isFalse(v.ok)) {\n    // We don't want to touch this filesystem, it'll probably hang!\n    logger().debug(\"volumeUUID(): remoteOK is false for \" + v.mountpoint)\n    return\n  }\n\n  await thenMap(\n    getOrSet(cache, v.mountpoint, () =>\n      thenOrTimeout(\n        () =>\n          tryWithErrorHandling(() => readVolumeUUID(v), {\n            message: \"readVolumeUUID(\" + v.mountpoint + \")\"\n          }),\n        VolumeUuidTimeoutMs\n      )\n    ),\n    uuid => (v.uuid = uuid)\n  )\n}\n\n/**\n * If the vol UUID file exists, use that instead of the device UUID.\n */\nexport async function readVolumeUUID(v: Volume): PromiseMaybe<string> {\n  const volUuidFile = PosixFile.for(v.mountpoint).join(\".uuid\")\n\n  if (Settings.readVolumeUuidFiles.valueOrDefault) {\n    const uuid = await thenOrTimeout(\n      () =>\n        thenOpt(volUuidFile.readFile(\"debug\")) // isn't worthy of a warn\n          .map(ea => ea.toString().trim())\n          .filter(notBlank)\n          .get(),\n      VolumeUuidTimeoutMs\n    )\n\n    if (uuid != null && uuid.length > 6) {\n      logger().debug(\"Serving UUID from .uuid\", {\n        uuid,\n        mountpoint: v.mountpoint\n      })\n      return uuid\n    }\n  }\n\n  // Don't try to write to the root directory:\n  if (v.mountpoint === \"/\") return v.uuid\n\n  if (Settings.writeVolumeUuidFiles.valueOrDefault) {\n    // Try to persist the UUID for later (or if the volume is remotely mounted)\n    const uuid = notBlankOr(v.uuid, safeUUID)\n\n    // Don't try to write if the directory (typically the root directory\n    // for the volume) is not writable:\n    if (await volUuidFile.parent().isReadWritable()) {\n      try {\n        await volUuidFile.writeTxt_(uuid)\n        logger().info(\"volumeUUID(): Saved new UUID for \" + v.mountpoint, {\n          uuid\n        })\n        return uuid\n      } catch (err) {\n        // Only return the UUID if we can persist it successfully.\n        logger().warn(\n          \"volumeUUID(): Failed to save new UUID for \" + v.mountpoint,\n          err\n        )\n      }\n    }\n  }\n\n  // Only return the hardware uuid if we couldn't persist the mkuuid for later\n  return v.uuid\n}\n", "import {\n  commonPrefixLength,\n  compact,\n  filterInPlace,\n  isEmpty,\n  mapNotEmpty,\n  sortBy\n} from \"../../fe/Array\"\nimport { blank, mapNotBlank, notBlank } from \"../../fe/Blank\"\nimport { isFalse, isTrue } from \"../../fe/Boolean\"\nimport { secondMs } from \"../../fe/Date\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { orElse } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { opt } from \"../../fe/Opt\"\nimport { greatestBy } from \"../Array\"\nimport { firstDefinedLater, LaterMaybe } from \"../async/Later\"\nimport { asyncFind, thenMap } from \"../async/Promise\"\nimport { withBoundedConcurrency } from \"../async/Promises\"\nimport { thenOrTimeout } from \"../async/thenOrTimeout\"\nimport { getEnv } from \"../Env\"\nimport { eql } from \"../Eql\"\nimport { onError } from \"../error/Error\"\nimport { emitVolumesChanged } from \"../event/EventEmitter\"\nimport {\n  containedByNativePath,\n  nativePathIsReadableDirectory\n} from \"../fs/Path\"\nimport { StatTimeoutMs } from \"../fs/StatTimeout\"\nimport { mkLogger } from \"../Logger\"\nimport { friendlyname } from \"../net/nslookup\"\nimport { isMac, isWin } from \"../Platform\"\nimport { Settings } from \"../settings/Settings\"\nimport { ensureSuffix, equalsIgnoreCase } from \"../String\"\nimport { dfPosix } from \"./DfPosix\"\nimport { dfWin } from \"./DfWin\"\nimport { lazyFsAsync } from \"./LazyFsAsync\"\nimport { addLocalVolumeInfoMac } from \"./LocalVolumesMac\"\nimport { addLocalVolumeInfoPosix } from \"./LocalVolumesPosix\"\nimport { addRemoteVolumeInfoPosix } from \"./RemoteVolumesPosix\"\nimport { addRemoteVolumeInfoWin } from \"./RemoteVolumesWin\"\nimport { Volume } from \"./Volume\"\nimport { MountpointsTtlMs } from \"./VolumeTtls\"\nimport { addVolumeUUIDs } from \"./VolumeUUID\"\n\nconst logger = lazy(() => mkLogger(\"Volumes\"))\n\nasync function nonRpcVolumes(): PromiseMaybe<Volume[]> {\n  const rawDfVols = await thenOrTimeout(\n    isWin ? dfWin() : dfPosix(),\n    MountpointsTtlMs,\n    () => onError(\"Timed out getting local volume metadata\")\n  )\n  if (rawDfVols == null) {\n    logger().warn(\"df failed\")\n    return\n  }\n\n  const dfVols = Settings.validateMountpoints.valueOrDefault\n    ? compact(\n        await withBoundedConcurrency({\n          name: \"nonRpcVolumes: filter unhealthy volumes\",\n          laters: rawDfVols.map(vol => async () => {\n            try {\n              // Exclude volumes whose mountpoint doesn't exist (like unhealthy gio\n              // mountpoints):\n              const isDir = await nativePathIsReadableDirectory(\n                vol.mountpoint,\n                StatTimeoutMs / 2\n              )\n              if (isDir) {\n                return vol\n              } else {\n                logger().info(\n                  \"validateMountpoints(): \" +\n                    vol.mountpoint +\n                    \" is not a directory\"\n                )\n              }\n            } catch (err) {\n              logger().info(\n                \"validateMountpoints(): failed to stat \" + vol.mountpoint,\n                err\n              )\n            }\n            return\n          })\n        })\n      )\n    : rawDfVols\n\n  // We only need to fetch remote volume information if there are remote volumes\n  // that are missing remoteHost:\n  if (dfVols.some(ea => ea.remote && blank(ea[\"remoteHost\"]))) {\n    await thenOrTimeout(\n      isWin ? addRemoteVolumeInfoWin(dfVols) : addRemoteVolumeInfoPosix(dfVols),\n      10 * secondMs // < windows NET USE is flaky\n    ).catch(err => {\n      onError(\"Failed to get remote volume info\", err)\n    })\n  }\n  const vols: Volume[] = orElse(\n    await (isWin\n      ? dfVols\n      : isMac\n      ? addLocalVolumeInfoMac(dfVols)\n      : addLocalVolumeInfoPosix(dfVols)),\n    dfVols\n  )\n\n  filterInPlace(vols, ea => !isTrue(ea.ignorable))\n\n  if (Settings.ignoreUnhealthyVolumes.valueOrDefault) {\n    filterInPlace(vols, ea => !isFalse(ea.ok))\n  }\n\n  // Fix hostnames:\n  for (const vol of vols) {\n    vol.remote = isTrue(vol.remote)\n    mapNotBlank(\n      vol.remoteHost,\n      // remote hosts cannot be case sensitive\n      ea => (vol.remoteHost = ea.toLowerCase().normalize().trim())\n    )\n  }\n\n  // undefine any blank labels:\n  for (const vol of vols) {\n    if (blank(vol.label)) delete vol.label\n  }\n\n  logger().debug(\"nonRpcVolumes(): before addVolumeUUIDs\", vols)\n  await addVolumeUUIDs(vols)\n\n  const sorted = sortBy(vols, ea => ea.mountpoint)\n  logger().debug(\"_volumes(): final result\", { sorted })\n  return Object.freeze(sorted) as Volume[]\n}\n\nlet rpcVolumes: Maybe<LaterMaybe<Volume[]>>\n\nexport function setRpcVolumesImpl(f: typeof rpcVolumes) {\n  rpcVolumes = f\n}\n\n// require(\"./dist/core/volumes/Volumes\").volumes().then(console.dir)\n\nlet priorVolumeMountpoints: string[] = []\n\nconst volumesImpl = async () => {\n  try {\n    // DO NOT USE orElse here, it tries to apply function pointers.\n    const result = await firstDefinedLater(rpcVolumes, nonRpcVolumes)\n    mapNotEmpty(result, arr => {\n      const volumeMountpoints = arr.map(ea => ea.mountpoint).sort()\n      if (!eql(priorVolumeMountpoints, volumeMountpoints)) {\n        emitVolumesChanged()\n        priorVolumeMountpoints = volumeMountpoints\n      }\n    })\n    return result\n  } catch (err) {\n    onError(\"volumes() failed\", err)\n    return undefined\n  }\n}\n\nexport const volumes = lazyFsAsync(\"volumes\", volumesImpl)\n\nexport const rootPath = lazy(() =>\n  isWin\n    ? opt(getEnv(\"SystemDrive\")) // < looks like \"C:\", not \"C:\\\"\n        .filter(notBlank)\n        .orElse(() => \"C:\")\n        .map(ea => ensureSuffix(ea, \"\\\\\"))\n        .get()!\n    : \"/\"\n)\n\nexport function rootVolume(): PromiseMaybe<Volume> {\n  return volumeFor(rootPath())\n}\n\nexport async function volumeFor(nativePath: string): PromiseMaybe<Volume> {\n  return thenMap(volumes(), vols => bestVolume(vols, nativePath))\n}\n\nexport function bestVolume(vols: Volume[], nativePath: string): Maybe<Volume> {\n  const candidates = vols.filter(vol =>\n    containedByNativePath(nativePath, vol.mountpoint)\n  )\n  return greatestBy(candidates, vol =>\n    commonPrefixLength(vol.mountpoint, nativePath)\n  )\n}\n\nexport async function remoteVolumeFor(\n  remoteHost: string,\n  remoteShare: string\n): PromiseMaybe<Volume> {\n  return thenMap(volumes(), vols =>\n    bestRemoteVolume(remoteHost, remoteShare, vols)\n  )\n}\n\n/**\n * Find the first volume in `vols` that matches (case-insensitively) the given\n * `remoteHost` and `remoteShare`.\n */\nexport async function bestRemoteVolume(\n  remoteHost: string,\n  remoteShare: string,\n  vols: Volume[]\n): PromiseMaybe<Volume> {\n  // Share names may be mostly unique, and they aren't messed with, so filter by that first:\n  const withCorrectShare = vols.filter(vol =>\n    equalsIgnoreCase(remoteShare, vol.remoteShare)\n  )\n  if (isEmpty(withCorrectShare)) return\n\n  const withExactHostname = withCorrectShare.find(\n    vol =>\n      isTrue(vol.remote) &&\n      notBlank(vol.remoteHost) &&\n      equalsIgnoreCase(remoteHost, vol.remoteHost)\n  )\n  if (withExactHostname != null) return withExactHostname\n\n  const friendlyRemoteHost = await friendlyname(remoteHost)\n  return asyncFind(withCorrectShare, async vol =>\n    equalsIgnoreCase(friendlyRemoteHost, await friendlyname(vol.remoteHost!))\n  )\n}\n", "import { join, sep } from \"path\"\nimport { blank, mapNotBlank, notBlank } from \"../../fe/Blank\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { ensurePrefix } from \"../../fe/String\"\nimport { PS_LOCAL_FILE_PROTOCOL } from \"../../fe/URI\"\nimport { thenMap } from \"../async/Promise\"\nimport { onClearCache } from \"../event/EventEmitter\"\nimport { shortStringSha } from \"../fs/Hash\"\nimport { native2posix } from \"../fs/Path\"\nimport { compactMap } from \"../Map\"\nimport { memoize } from \"../MemoizedFunc\"\nimport { Volume } from \"../volumes/Volume\"\nimport { volumeFor, volumes } from \"../volumes/Volumes\"\nimport { URI } from \"./URI\"\n\nexport const volsha = memoize(\n  (uuid: Maybe<string>) => mapNotBlank(uuid, shortStringSha),\n  { maxSize: 128, ttlMs: minuteMs }\n)\n\n// Prevent circular module reference problems:\nlater(() => {\n  onClearCache(() => volshaToMountpoint.unset())\n  volumes.onChange(() => volshaToMountpoint.unset())\n})\n\nconst volshaToMountpoint = lazy(async () => {\n  return thenMap(volumes(), vols =>\n    compactMap(vols.map(vol => [volsha(vol.uuid), vol.mountpoint]))\n  )\n})\n\nexport function nativePath2psfile(nativePath: string, vol: Maybe<Volume>) {\n  if (blank(nativePath) || vol == null || blank(vol.uuid)) return\n\n  const fullPath = native2posix(nativePath)\n  const volPath = native2posix(vol.mountpoint)\n  if (!fullPath.normalize().startsWith(volPath.normalize())) return\n  const path = ensurePrefix(fullPath.slice(volPath.length), \"/\")\n\n  return URI.from({\n    scheme: PS_LOCAL_FILE_PROTOCOL,\n    authority: volsha(vol.uuid),\n    path\n  })\n}\n\nexport function joinMountpoint(mountpoint: string, posixPath: string) {\n  return join(mountpoint, ...posixPath.split(\"/\").slice(1))\n}\n\nexport async function psfile2nativePath(\n  uri: URI,\n  mountpoint?: string\n): PromiseMaybe<string> {\n  if (uri.scheme !== PS_LOCAL_FILE_PROTOCOL) {\n    throw new Error(\"invalid URI: \" + uri + \" (bad scheme)\")\n  }\n  if (blank(uri.authority)) {\n    throw new Error(\"invalid URI: \" + uri + \" (missing authority)\")\n  }\n\n  // Best-case, the volsha matches the mountpoint:\n\n  // Don't look at the mountpoint unless it includes a separator character for\n  // the current platform (windows or posix):\n\n  const mountpointMatchesPlatform =\n    mountpoint != null && mountpoint.includes(sep)\n\n  if (mountpointMatchesPlatform) {\n    const vol = await volumeFor(mountpoint!)\n    if (vol?.uuid != null) {\n      const authority = volsha(vol.uuid)\n      if (authority === uri.authority) {\n        return joinMountpoint(mountpoint!, uri.path)\n      }\n    }\n  }\n\n  // Dang, the mountpoint doesn't match. See if we can resolve the volsha:\n\n  const shaMountpoint = await thenMap(volshaToMountpoint(), m =>\n    m.get(uri.authority)\n  )\n  if (notBlank(shaMountpoint)) {\n    return joinMountpoint(shaMountpoint, uri.path)\n  }\n\n  if (mountpointMatchesPlatform) {\n    return joinMountpoint(mountpoint!, uri.path)\n  }\n\n  return undefined\n}\n", "import { stringify } from \"../fe/JSON\"\nimport { FifoCache } from \"./FifoCache\"\n\nexport interface MemoizedFunc<A, R> {\n  (a: A): R\n  clear(a?: A): void\n  size(): number\n  callCount(): number\n}\n\nexport function memoize<A, R>(\n  f: (a: A) => R,\n  opts: { maxSize: number; ttlMs?: number }\n): MemoizedFunc<A, R> {\n  let callCount = 0\n  const store = new FifoCache<R>(opts.maxSize, opts.ttlMs)\n  const r: any = (a: A) => {\n    callCount++\n    return store.getOrSet(stringify(a), () => f(a))\n  }\n  r.clear = (a?: A) => (a == null ? store.clear() : store.delete(stringify(a)))\n  r.size = () => store.size\n  r.callCount = () => callCount\n  return r\n}\n", "// see https://github.com/microsoft/vscode/blob/master/src/vs/base/common/uri.ts\nimport { posix, win32 } from \"path\"\nimport { toUnicode } from \"punycode\"\nimport { inspect } from \"util\"\nimport { notBlank } from \"../../fe/Blank\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { ensureSuffix } from \"../../fe/String\"\nimport { findLast } from \"../Array\"\nimport { CharCode } from \"../CharCode\"\nimport { isWin, isWinPortable } from \"../Platform\"\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/\nconst _singleSlashStart = /^\\//\nconst _doubleSlashStart = /^\\/\\//\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n  // scheme, must be set\n  if (!ret.scheme && _strict === true) {\n    throw new Error(\n      `[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`\n    )\n  }\n\n  // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n  // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n  if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n    throw new Error(\"[UriError]: Scheme contains illegal characters.\")\n  }\n\n  // path, http://tools.ietf.org/html/rfc3986#section-3.3\n  // If a URI contains an authority component, then the path component\n  // must either be empty or begin with a slash (\"/\") character.  If a URI\n  // does not contain an authority component, then the path cannot begin\n  // with two slash characters (\"//\").\n  if (ret.path) {\n    if (ret.authority) {\n      if (!_singleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character'\n        )\n      }\n    } else {\n      if (_doubleSlashStart.test(ret.path)) {\n        throw new Error(\n          '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")'\n        )\n      }\n    }\n  }\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n  if (!scheme && !_strict) {\n    return \"file\"\n  }\n  return scheme\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n  // the slash-character is our 'default base' as we don't\n  // support constructing URIs relative to other URIs. This\n  // also means that we alter and potentially break paths.\n  // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n  switch (scheme) {\n    case \"https\":\n    case \"http\":\n    case \"file\":\n      if (!path) {\n        path = _slash\n      } else if (path[0] !== _slash) {\n        path = _slash + path\n      }\n      break\n  }\n  return path\n}\n\nconst _empty = \"\"\nconst _slash = \"/\"\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI implements UriComponents {\n  static isUri(thing: any): thing is URI {\n    if (thing instanceof URI) {\n      return true\n    }\n    if (thing == null) {\n      return false\n    }\n    return (\n      typeof (<URI>thing).authority === \"string\" &&\n      typeof (<URI>thing).fragment === \"string\" &&\n      typeof (<URI>thing).path === \"string\" &&\n      typeof (<URI>thing).query === \"string\" &&\n      typeof (<URI>thing).scheme === \"string\" &&\n      typeof (<URI>thing).fsPath === \"function\" &&\n      typeof (<URI>thing).with === \"function\" &&\n      typeof (<URI>thing).toString === \"function\"\n    )\n  }\n\n  /**\n   * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part before the first colon.\n   */\n  readonly scheme: string\n\n  /**\n   * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n   * The part between the first double slashes and the next slash.\n   */\n  readonly authority: string\n\n  /**\n   * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly path: string\n\n  /**\n   * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly query: string\n\n  /**\n   * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n   */\n  readonly fragment: string\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    scheme: string,\n    authority?: string,\n    path?: string,\n    query?: string,\n    fragment?: string,\n    _strict?: boolean\n  )\n\n  /**\n   * @internal\n   */\n  protected constructor(components: UriComponents)\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    schemeOrData: string | UriComponents,\n    authority?: string,\n    path?: string,\n    query?: string,\n    fragment?: string,\n    _strict: boolean = false\n  ) {\n    if (typeof schemeOrData === \"object\") {\n      this.scheme = schemeOrData.scheme || _empty\n      this.authority = schemeOrData.authority || _empty\n      this.path = schemeOrData.path || _empty\n      this.query = schemeOrData.query || _empty\n      this.fragment = schemeOrData.fragment || _empty\n      // no validation because it's this URI\n      // that creates uri components.\n      // _validateUri(this);\n    } else {\n      this.scheme = _schemeFix(schemeOrData, _strict)\n      this.authority = orElse(authority, _empty)\n      this.path = _referenceResolution(this.scheme, orElse(path, _empty))\n      this.query = orElse(query, _empty)\n      this.fragment = orElse(fragment, _empty)\n\n      _validateUri(this, _strict)\n    }\n  }\n\n  // ---- filesystem path -----------------------\n\n  /**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n  get fsPath(): string {\n    // if (this.scheme !== 'file') {\n    // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n    // }\n    return uriToFsPath(this, false)\n  }\n\n  // ---- modify to new -------------------------\n\n  with(change: {\n    scheme?: string\n    authority?: string | null\n    path?: string | null\n    query?: string | null\n    fragment?: string | null\n  }): URI {\n    if (change == null) {\n      return this\n    }\n\n    let { scheme, authority, path, query, fragment } = change\n    if (scheme === undefined) {\n      scheme = this.scheme\n    } else if (scheme === null) {\n      scheme = _empty\n    }\n    if (authority === undefined) {\n      authority = this.authority\n    } else if (authority === null) {\n      authority = _empty\n    }\n    if (path === undefined) {\n      path = this.path\n    } else if (path === null) {\n      path = _empty\n    }\n    if (query === undefined) {\n      query = this.query\n    } else if (query === null) {\n      query = _empty\n    }\n    if (fragment === undefined) {\n      fragment = this.fragment\n    } else if (fragment === null) {\n      fragment = _empty\n    }\n\n    if (\n      scheme === this.scheme &&\n      authority === this.authority &&\n      path === this.path &&\n      query === this.query &&\n      fragment === this.fragment\n    ) {\n      return this\n    }\n\n    return new Uri(scheme, authority, path, query, fragment)\n  }\n\n  // ---- parse & validate ------------------------\n\n  /**\n   * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n   * `file:///usr/home`, or `scheme:with/path`.\n   *\n   * @param value A string which represents an URI (see `URI#toString`).\n   */\n  static parse(value: string, _strict: boolean = false): URI {\n    const match = _regexp.exec(value)\n    if (!match) {\n      return new Uri(_empty, _empty, _empty, _empty, _empty)\n    }\n    const scheme = match[2] || _empty\n    const authority = percentDecode(match[4] || _empty)\n    const path = (match[5] || _empty).split(\"/\").map(percentDecode).join(\"/\")\n    const fixedPath =\n      scheme === \"psfile\" && path.startsWith(\"//\") ? path.slice(1) : path // TODO SITS\n    const query = percentDecode(match[7] || _empty)\n    const fragment = percentDecode(match[9] || _empty)\n    return new Uri(scheme, authority, fixedPath, query, fragment, _strict)\n  }\n\n  /**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n  static file(path: string): URI {\n    let authority = _empty\n\n    // normalize to fwd-slashes on windows,\n    // on other systems bwd-slashes are valid\n    // filename character, eg /f\\oo/ba\\r.txt\n    if (isWin) {\n      path = path.replace(/\\\\/g, _slash)\n    }\n\n    // check for authority as used in UNC shares\n    // or use the path as given\n    if (path[0] === _slash && path[1] === _slash) {\n      const idx = path.indexOf(_slash, 2)\n      if (idx === -1) {\n        authority = path.substring(2)\n        path = _slash\n      } else {\n        authority = path.substring(2, idx)\n        path = path.substring(idx) || _slash\n      }\n    }\n\n    return new Uri(\"file\", authority, path, _empty, _empty)\n  }\n\n  static from(components: {\n    scheme: string\n    authority?: string\n    path?: string\n    query?: string\n    fragment?: string\n  }): URI {\n    return new Uri(\n      components.scheme,\n      components.authority,\n      components.path,\n      components.query,\n      components.fragment\n    )\n  }\n\n  /**\n   * Join a URI path with path fragments and normalizes the resulting path.\n   *\n   * @param uri The input URI.\n   * @param pathFragment The path fragment to add to the URI path.\n   * @returns The resulting URI.\n   */\n  static joinPath(uri: URI, ...pathFragment: string[]): URI {\n    if (!uri.path) {\n      throw new Error(`[UriError]: cannot call joinPaths on URI without path`)\n    }\n    let newPath: string\n    if (isWin && uri.scheme === \"file\") {\n      newPath = URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment))\n        .path\n    } else {\n      newPath = posix.join(uri.path, ...pathFragment)\n    }\n    return uri.with({ path: newPath })\n  }\n\n  isRootPath(): boolean {\n    return this.path == null || this.path === _slash\n  }\n\n  get pathBase(): Maybe<string> {\n    return this.isRootPath()\n      ? \"\"\n      : map(this.path, path => findLast(path.split(_slash), notBlank))\n  }\n\n  parent(): URI {\n    if (this.isRootPath()) return this\n    return this.with({\n      path: this.path.slice(0, this.path.lastIndexOf(_slash))\n    })\n  }\n\n  join(...path: string[]): URI {\n    return this.with({\n      path: ensureSuffix(this.path, _slash) + path.join(_slash)\n    })\n  }\n\n  // ---- printing/externalize ---------------------------\n\n  /**\n   * Creates a string representation for this URI. It's guaranteed that calling\n   * `URI.parse` with the result of this function creates an URI which is equal\n   * to this URI.\n   *\n   * * The result shall *not* be used for display purposes but for externalization or transport.\n   * * The result will be encoded using the percentage encoding and encoding happens mostly\n   * ignore the scheme-specific encoding rules.\n   *\n   * @param skipEncoding Do not encode the result, default is `false`\n   */\n  toString(skipEncoding: boolean = false): string {\n    return _asFormatted(this, skipEncoding)\n  }\n\n  toJSON(): UriComponents {\n    return this\n  }\n\n  [inspect.custom]() {\n    return this.toString()\n  }\n}\n\nexport interface UriComponents {\n  scheme: string\n  authority: string\n  path: string\n  query: string\n  fragment: string\n}\n\ninterface UriState extends UriComponents {\n  $mid: number\n  external: string\n  fsPath: string\n  _sep: 1 | undefined\n}\n\nconst _pathSepMarker = isWinPortable ? 1 : undefined\n\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends URI {\n  _formatted: string | null = null\n  _fsPath: string | null = null\n\n  get fsPath(): string {\n    if (this._fsPath == null) {\n      this._fsPath = uriToFsPath(this, false)\n    }\n    return this._fsPath\n  }\n\n  toString(skipEncoding: boolean = false): string {\n    if (!skipEncoding) {\n      if (this._formatted == null) {\n        this._formatted = _asFormatted(this, false)\n      }\n      return this._formatted\n    } else {\n      // we don't cache that\n      return _asFormatted(this, true)\n    }\n  }\n\n  toJSON(): UriComponents {\n    const res = <UriState>{\n      $mid: 1\n    }\n    // cached state\n    if (this._fsPath != null) {\n      res.fsPath = this._fsPath\n      res._sep = _pathSepMarker\n    }\n    if (this._formatted != null) {\n      res.external = this._formatted\n    }\n    // uri components\n    if (this.path) {\n      res.path = this.path\n    }\n    if (this.scheme) {\n      res.scheme = this.scheme\n    }\n    if (this.authority) {\n      res.authority = this.authority\n    }\n    if (this.query) {\n      res.query = this.query\n    }\n    if (this.fragment) {\n      res.fragment = this.fragment\n    }\n    return res\n  }\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n  [CharCode.Colon]: \"%3A\", // gen-delims\n  [CharCode.Slash]: \"%2F\",\n  [CharCode.QuestionMark]: \"%3F\",\n  [CharCode.Hash]: \"%23\",\n  [CharCode.OpenSquareBracket]: \"%5B\",\n  [CharCode.CloseSquareBracket]: \"%5D\",\n  [CharCode.AtSign]: \"%40\",\n\n  [CharCode.ExclamationMark]: \"%21\", // sub-delims\n  [CharCode.DollarSign]: \"%24\",\n  [CharCode.Ampersand]: \"%26\",\n  [CharCode.SingleQuote]: \"%27\",\n  [CharCode.OpenParen]: \"%28\",\n  [CharCode.CloseParen]: \"%29\",\n  [CharCode.Asterisk]: \"%2A\",\n  [CharCode.Plus]: \"%2B\",\n  [CharCode.Comma]: \"%2C\",\n  [CharCode.Semicolon]: \"%3B\",\n  [CharCode.Equals]: \"%3D\",\n\n  [CharCode.Space]: \"%20\"\n}\n\nexport function encodeURIComponentFast(\n  uriComponent: string,\n  allowSlash: boolean\n): string {\n  let res: string | undefined\n  let nativeEncodePos = -1\n\n  for (let pos = 0; pos < uriComponent.length; pos++) {\n    const code = uriComponent.charCodeAt(pos)\n\n    // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n    if (\n      (code >= CharCode.a && code <= CharCode.z) ||\n      (code >= CharCode.A && code <= CharCode.Z) ||\n      (code >= CharCode.Digit0 && code <= CharCode.Digit9) ||\n      code === CharCode.Dash ||\n      code === CharCode.Period ||\n      code === CharCode.Underline ||\n      code === CharCode.Tilde ||\n      (allowSlash && code === CharCode.Slash)\n    ) {\n      // check if we are delaying native encode\n      if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos))\n        nativeEncodePos = -1\n      }\n      // check if we write into a new string (by default we try to return the param)\n      if (res !== undefined) {\n        res += uriComponent.charAt(pos)\n      }\n    } else {\n      // encoding needed, we need to allocate a new string\n      if (res === undefined) {\n        res = uriComponent.substr(0, pos)\n      }\n\n      // check with default table first\n      const escaped = encodeTable[code]\n      if (escaped !== undefined) {\n        // check if we are delaying native encode\n        if (nativeEncodePos !== -1) {\n          res += encodeURIComponent(\n            uriComponent.substring(nativeEncodePos, pos)\n          )\n          nativeEncodePos = -1\n        }\n\n        // append escaped variant to result\n        res += escaped\n      } else if (nativeEncodePos === -1) {\n        // use native encode only when needed\n        nativeEncodePos = pos\n      }\n    }\n  }\n\n  if (nativeEncodePos !== -1) {\n    res += encodeURIComponent(uriComponent.substring(nativeEncodePos))\n  }\n\n  return res !== undefined ? res : uriComponent\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n  let res: string | undefined\n  for (let pos = 0; pos < path.length; pos++) {\n    const code = path.charCodeAt(pos)\n    if (code === CharCode.Hash || code === CharCode.QuestionMark) {\n      if (res === undefined) {\n        res = path.substr(0, pos)\n      }\n      res += encodeTable[code]\n    } else {\n      if (res !== undefined) {\n        res += path[pos]\n      }\n    }\n  }\n  return res !== undefined ? res : path\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: URI, keepDriveLetterCasing: boolean): string {\n  let value: string\n  if (uri.authority && uri.path.length > 1 && uri.scheme === \"file\") {\n    // unc path: file://shares/c$/far/boo\n    value = `//${uri.authority}${uri.path}`\n  } else if (\n    uri.path.charCodeAt(0) === CharCode.Slash &&\n    ((uri.path.charCodeAt(1) >= CharCode.A &&\n      uri.path.charCodeAt(1) <= CharCode.Z) ||\n      (uri.path.charCodeAt(1) >= CharCode.a &&\n        uri.path.charCodeAt(1) <= CharCode.z)) &&\n    uri.path.charCodeAt(2) === CharCode.Colon\n  ) {\n    if (!keepDriveLetterCasing) {\n      // windows drive letter: file:///c:/far/boo\n      value = uri.path[1].toLowerCase() + uri.path.substr(2)\n    } else {\n      value = uri.path.substr(1)\n    }\n  } else {\n    // other path\n    value = uri.path\n  }\n  if (isWin) {\n    value = value.replace(/\\//g, \"\\\\\")\n  }\n  return value\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n  const encoder = !skipEncoding\n    ? encodeURIComponentFast\n    : encodeURIComponentMinimal\n\n  let res = \"\"\n  const { scheme, query, fragment } = uri\n  let { authority, path } = uri\n  if (scheme) {\n    res += scheme\n    res += \":\"\n  }\n  if (authority || scheme === \"file\") {\n    res += _slash\n    res += _slash\n  }\n  if (authority) {\n    let idx = authority.indexOf(\"@\")\n    if (idx !== -1) {\n      // <user>@<auth>\n      const userinfo = authority.substr(0, idx)\n      authority = authority.substr(idx + 1)\n      idx = userinfo.indexOf(\":\")\n      if (idx === -1) {\n        res += encoder(userinfo, false)\n      } else {\n        // <user>:<pass>@<auth>\n        res += encoder(userinfo.substr(0, idx), false)\n        res += \":\"\n        res += encoder(userinfo.substr(idx + 1), false)\n      }\n      res += \"@\"\n    }\n    // MRM 20200815: DON'T DOWNCASE:\n    // authority = authority.toLowerCase()\n    idx = authority.indexOf(\":\")\n    if (idx === -1) {\n      res += encoder(authority, false)\n    } else {\n      // <auth>:<port>\n      res += encoder(authority.substr(0, idx), false)\n      res += authority.substr(idx)\n    }\n  }\n  if (path) {\n    // lower-case windows drive letters in /C:/fff or C:/fff\n    if (\n      path.length >= 3 &&\n      path.charCodeAt(0) === CharCode.Slash &&\n      path.charCodeAt(2) === CharCode.Colon\n    ) {\n      const code = path.charCodeAt(1)\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}` // \"/c:\".length === 3\n      }\n    } else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n      const code = path.charCodeAt(0)\n      if (code >= CharCode.A && code <= CharCode.Z) {\n        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}` // \"/c:\".length === 3\n      }\n    }\n    // encode the rest of the path\n    res += encoder(path, true)\n  }\n  if (query) {\n    res += \"?\"\n    res += encoder(query, false)\n  }\n  if (fragment) {\n    res += \"#\"\n    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment\n  }\n  return res\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n  try {\n    return decodeURIComponent(str)\n  } catch {\n    if (str.length > 3) {\n      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3))\n    } else {\n      return str\n    }\n  }\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g\n\nfunction percentDecode(str: string): string {\n  if (str.startsWith(\"xn--\")) return toUnicode(str)\n  if (!str.match(_rEncodedAsHex)) {\n    return str\n  }\n  return str.replace(_rEncodedAsHex, match => decodeURIComponentGraceful(match))\n}\n\nexport function toURI(u: string | URI): URI {\n  return URI.isUri(u) ? u : URI.parse(u)\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// Names from https://blog.codinghorror.com/ascii-pronunciation-rules-for-programmers/\n\n/**\n * An inlined enum containing useful character codes (to be used with String.charCodeAt).\n * Please leave the const keyword such that it gets inlined when compiled to JavaScript!\n */\nexport const enum CharCode {\n  Null = 0,\n  /**\n   * The `\\b` character.\n   */\n  Backspace = 8,\n  /**\n   * The `\\t` character.\n   */\n  Tab = 9,\n  /**\n   * The `\\n` character.\n   */\n  LineFeed = 10,\n  /**\n   * The `\\r` character.\n   */\n  CarriageReturn = 13,\n  Space = 32,\n  /**\n   * The `!` character.\n   */\n  ExclamationMark = 33,\n  /**\n   * The `\"` character.\n   */\n  DoubleQuote = 34,\n  /**\n   * The `#` character.\n   */\n  Hash = 35,\n  /**\n   * The `$` character.\n   */\n  DollarSign = 36,\n  /**\n   * The `%` character.\n   */\n  PercentSign = 37,\n  /**\n   * The `&` character.\n   */\n  Ampersand = 38,\n  /**\n   * The `'` character.\n   */\n  SingleQuote = 39,\n  /**\n   * The `(` character.\n   */\n  OpenParen = 40,\n  /**\n   * The `)` character.\n   */\n  CloseParen = 41,\n  /**\n   * The `*` character.\n   */\n  Asterisk = 42,\n  /**\n   * The `+` character.\n   */\n  Plus = 43,\n  /**\n   * The `,` character.\n   */\n  Comma = 44,\n  /**\n   * The `-` character.\n   */\n  Dash = 45,\n  /**\n   * The `.` character.\n   */\n  Period = 46,\n  /**\n   * The `/` character.\n   */\n  Slash = 47,\n\n  Digit0 = 48,\n  Digit1 = 49,\n  Digit2 = 50,\n  Digit3 = 51,\n  Digit4 = 52,\n  Digit5 = 53,\n  Digit6 = 54,\n  Digit7 = 55,\n  Digit8 = 56,\n  Digit9 = 57,\n\n  /**\n   * The `:` character.\n   */\n  Colon = 58,\n  /**\n   * The `;` character.\n   */\n  Semicolon = 59,\n  /**\n   * The `<` character.\n   */\n  LessThan = 60,\n  /**\n   * The `=` character.\n   */\n  Equals = 61,\n  /**\n   * The `>` character.\n   */\n  GreaterThan = 62,\n  /**\n   * The `?` character.\n   */\n  QuestionMark = 63,\n  /**\n   * The `@` character.\n   */\n  AtSign = 64,\n\n  A = 65,\n  B = 66,\n  C = 67,\n  D = 68,\n  E = 69,\n  F = 70,\n  G = 71,\n  H = 72,\n  I = 73,\n  J = 74,\n  K = 75,\n  L = 76,\n  M = 77,\n  N = 78,\n  O = 79,\n  P = 80,\n  Q = 81,\n  R = 82,\n  S = 83,\n  T = 84,\n  U = 85,\n  V = 86,\n  W = 87,\n  X = 88,\n  Y = 89,\n  Z = 90,\n\n  /**\n   * The `[` character.\n   */\n  OpenSquareBracket = 91,\n  /**\n   * The `\\` character.\n   */\n  Backslash = 92,\n  /**\n   * The `]` character.\n   */\n  CloseSquareBracket = 93,\n  /**\n   * The `^` character.\n   */\n  Caret = 94,\n  /**\n   * The `_` character.\n   */\n  Underline = 95,\n  /**\n   * The ``(`)`` character.\n   */\n  BackTick = 96,\n\n  a = 97,\n  b = 98,\n  c = 99,\n  d = 100,\n  e = 101,\n  f = 102,\n  g = 103,\n  h = 104,\n  i = 105,\n  j = 106,\n  k = 107,\n  l = 108,\n  m = 109,\n  n = 110,\n  o = 111,\n  p = 112,\n  q = 113,\n  r = 114,\n  s = 115,\n  t = 116,\n  u = 117,\n  v = 118,\n  w = 119,\n  x = 120,\n  y = 121,\n  z = 122,\n\n  /**\n   * The `{` character.\n   */\n  OpenCurlyBrace = 123,\n  /**\n   * The `|` character.\n   */\n  Pipe = 124,\n  /**\n   * The `}` character.\n   */\n  CloseCurlyBrace = 125,\n  /**\n   * The `~` character.\n   */\n  Tilde = 126,\n\n  U_Combining_Grave_Accent = 0x0300, //\tU+0300\tCombining Grave Accent\n  U_Combining_Acute_Accent = 0x0301, //\tU+0301\tCombining Acute Accent\n  U_Combining_Circumflex_Accent = 0x0302, //\tU+0302\tCombining Circumflex Accent\n  U_Combining_Tilde = 0x0303, //\tU+0303\tCombining Tilde\n  U_Combining_Macron = 0x0304, //\tU+0304\tCombining Macron\n  U_Combining_Overline = 0x0305, //\tU+0305\tCombining Overline\n  U_Combining_Breve = 0x0306, //\tU+0306\tCombining Breve\n  U_Combining_Dot_Above = 0x0307, //\tU+0307\tCombining Dot Above\n  U_Combining_Diaeresis = 0x0308, //\tU+0308\tCombining Diaeresis\n  U_Combining_Hook_Above = 0x0309, //\tU+0309\tCombining Hook Above\n  U_Combining_Ring_Above = 0x030a, //\tU+030A\tCombining Ring Above\n  U_Combining_Double_Acute_Accent = 0x030b, //\tU+030B\tCombining Double Acute Accent\n  U_Combining_Caron = 0x030c, //\tU+030C\tCombining Caron\n  U_Combining_Vertical_Line_Above = 0x030d, //\tU+030D\tCombining Vertical Line Above\n  U_Combining_Double_Vertical_Line_Above = 0x030e, //\tU+030E\tCombining Double Vertical Line Above\n  U_Combining_Double_Grave_Accent = 0x030f, //\tU+030F\tCombining Double Grave Accent\n  U_Combining_Candrabindu = 0x0310, //\tU+0310\tCombining Candrabindu\n  U_Combining_Inverted_Breve = 0x0311, //\tU+0311\tCombining Inverted Breve\n  U_Combining_Turned_Comma_Above = 0x0312, //\tU+0312\tCombining Turned Comma Above\n  U_Combining_Comma_Above = 0x0313, //\tU+0313\tCombining Comma Above\n  U_Combining_Reversed_Comma_Above = 0x0314, //\tU+0314\tCombining Reversed Comma Above\n  U_Combining_Comma_Above_Right = 0x0315, //\tU+0315\tCombining Comma Above Right\n  U_Combining_Grave_Accent_Below = 0x0316, //\tU+0316\tCombining Grave Accent Below\n  U_Combining_Acute_Accent_Below = 0x0317, //\tU+0317\tCombining Acute Accent Below\n  U_Combining_Left_Tack_Below = 0x0318, //\tU+0318\tCombining Left Tack Below\n  U_Combining_Right_Tack_Below = 0x0319, //\tU+0319\tCombining Right Tack Below\n  U_Combining_Left_Angle_Above = 0x031a, //\tU+031A\tCombining Left Angle Above\n  U_Combining_Horn = 0x031b, //\tU+031B\tCombining Horn\n  U_Combining_Left_Half_Ring_Below = 0x031c, //\tU+031C\tCombining Left Half Ring Below\n  U_Combining_Up_Tack_Below = 0x031d, //\tU+031D\tCombining Up Tack Below\n  U_Combining_Down_Tack_Below = 0x031e, //\tU+031E\tCombining Down Tack Below\n  U_Combining_Plus_Sign_Below = 0x031f, //\tU+031F\tCombining Plus Sign Below\n  U_Combining_Minus_Sign_Below = 0x0320, //\tU+0320\tCombining Minus Sign Below\n  U_Combining_Palatalized_Hook_Below = 0x0321, //\tU+0321\tCombining Palatalized Hook Below\n  U_Combining_Retroflex_Hook_Below = 0x0322, //\tU+0322\tCombining Retroflex Hook Below\n  U_Combining_Dot_Below = 0x0323, //\tU+0323\tCombining Dot Below\n  U_Combining_Diaeresis_Below = 0x0324, //\tU+0324\tCombining Diaeresis Below\n  U_Combining_Ring_Below = 0x0325, //\tU+0325\tCombining Ring Below\n  U_Combining_Comma_Below = 0x0326, //\tU+0326\tCombining Comma Below\n  U_Combining_Cedilla = 0x0327, //\tU+0327\tCombining Cedilla\n  U_Combining_Ogonek = 0x0328, //\tU+0328\tCombining Ogonek\n  U_Combining_Vertical_Line_Below = 0x0329, //\tU+0329\tCombining Vertical Line Below\n  U_Combining_Bridge_Below = 0x032a, //\tU+032A\tCombining Bridge Below\n  U_Combining_Inverted_Double_Arch_Below = 0x032b, //\tU+032B\tCombining Inverted Double Arch Below\n  U_Combining_Caron_Below = 0x032c, //\tU+032C\tCombining Caron Below\n  U_Combining_Circumflex_Accent_Below = 0x032d, //\tU+032D\tCombining Circumflex Accent Below\n  U_Combining_Breve_Below = 0x032e, //\tU+032E\tCombining Breve Below\n  U_Combining_Inverted_Breve_Below = 0x032f, //\tU+032F\tCombining Inverted Breve Below\n  U_Combining_Tilde_Below = 0x0330, //\tU+0330\tCombining Tilde Below\n  U_Combining_Macron_Below = 0x0331, //\tU+0331\tCombining Macron Below\n  U_Combining_Low_Line = 0x0332, //\tU+0332\tCombining Low Line\n  U_Combining_Double_Low_Line = 0x0333, //\tU+0333\tCombining Double Low Line\n  U_Combining_Tilde_Overlay = 0x0334, //\tU+0334\tCombining Tilde Overlay\n  U_Combining_Short_Stroke_Overlay = 0x0335, //\tU+0335\tCombining Short Stroke Overlay\n  U_Combining_Long_Stroke_Overlay = 0x0336, //\tU+0336\tCombining Long Stroke Overlay\n  U_Combining_Short_Solidus_Overlay = 0x0337, //\tU+0337\tCombining Short Solidus Overlay\n  U_Combining_Long_Solidus_Overlay = 0x0338, //\tU+0338\tCombining Long Solidus Overlay\n  U_Combining_Right_Half_Ring_Below = 0x0339, //\tU+0339\tCombining Right Half Ring Below\n  U_Combining_Inverted_Bridge_Below = 0x033a, //\tU+033A\tCombining Inverted Bridge Below\n  U_Combining_Square_Below = 0x033b, //\tU+033B\tCombining Square Below\n  U_Combining_Seagull_Below = 0x033c, //\tU+033C\tCombining Seagull Below\n  U_Combining_X_Above = 0x033d, //\tU+033D\tCombining X Above\n  U_Combining_Vertical_Tilde = 0x033e, //\tU+033E\tCombining Vertical Tilde\n  U_Combining_Double_Overline = 0x033f, //\tU+033F\tCombining Double Overline\n  U_Combining_Grave_Tone_Mark = 0x0340, //\tU+0340\tCombining Grave Tone Mark\n  U_Combining_Acute_Tone_Mark = 0x0341, //\tU+0341\tCombining Acute Tone Mark\n  U_Combining_Greek_Perispomeni = 0x0342, //\tU+0342\tCombining Greek Perispomeni\n  U_Combining_Greek_Koronis = 0x0343, //\tU+0343\tCombining Greek Koronis\n  U_Combining_Greek_Dialytika_Tonos = 0x0344, //\tU+0344\tCombining Greek Dialytika Tonos\n  U_Combining_Greek_Ypogegrammeni = 0x0345, //\tU+0345\tCombining Greek Ypogegrammeni\n  U_Combining_Bridge_Above = 0x0346, //\tU+0346\tCombining Bridge Above\n  U_Combining_Equals_Sign_Below = 0x0347, //\tU+0347\tCombining Equals Sign Below\n  U_Combining_Double_Vertical_Line_Below = 0x0348, //\tU+0348\tCombining Double Vertical Line Below\n  U_Combining_Left_Angle_Below = 0x0349, //\tU+0349\tCombining Left Angle Below\n  U_Combining_Not_Tilde_Above = 0x034a, //\tU+034A\tCombining Not Tilde Above\n  U_Combining_Homothetic_Above = 0x034b, //\tU+034B\tCombining Homothetic Above\n  U_Combining_Almost_Equal_To_Above = 0x034c, //\tU+034C\tCombining Almost Equal To Above\n  U_Combining_Left_Right_Arrow_Below = 0x034d, //\tU+034D\tCombining Left Right Arrow Below\n  U_Combining_Upwards_Arrow_Below = 0x034e, //\tU+034E\tCombining Upwards Arrow Below\n  U_Combining_Grapheme_Joiner = 0x034f, //\tU+034F\tCombining Grapheme Joiner\n  U_Combining_Right_Arrowhead_Above = 0x0350, //\tU+0350\tCombining Right Arrowhead Above\n  U_Combining_Left_Half_Ring_Above = 0x0351, //\tU+0351\tCombining Left Half Ring Above\n  U_Combining_Fermata = 0x0352, //\tU+0352\tCombining Fermata\n  U_Combining_X_Below = 0x0353, //\tU+0353\tCombining X Below\n  U_Combining_Left_Arrowhead_Below = 0x0354, //\tU+0354\tCombining Left Arrowhead Below\n  U_Combining_Right_Arrowhead_Below = 0x0355, //\tU+0355\tCombining Right Arrowhead Below\n  U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below = 0x0356, //\tU+0356\tCombining Right Arrowhead And Up Arrowhead Below\n  U_Combining_Right_Half_Ring_Above = 0x0357, //\tU+0357\tCombining Right Half Ring Above\n  U_Combining_Dot_Above_Right = 0x0358, //\tU+0358\tCombining Dot Above Right\n  U_Combining_Asterisk_Below = 0x0359, //\tU+0359\tCombining Asterisk Below\n  U_Combining_Double_Ring_Below = 0x035a, //\tU+035A\tCombining Double Ring Below\n  U_Combining_Zigzag_Above = 0x035b, //\tU+035B\tCombining Zigzag Above\n  U_Combining_Double_Breve_Below = 0x035c, //\tU+035C\tCombining Double Breve Below\n  U_Combining_Double_Breve = 0x035d, //\tU+035D\tCombining Double Breve\n  U_Combining_Double_Macron = 0x035e, //\tU+035E\tCombining Double Macron\n  U_Combining_Double_Macron_Below = 0x035f, //\tU+035F\tCombining Double Macron Below\n  U_Combining_Double_Tilde = 0x0360, //\tU+0360\tCombining Double Tilde\n  U_Combining_Double_Inverted_Breve = 0x0361, //\tU+0361\tCombining Double Inverted Breve\n  U_Combining_Double_Rightwards_Arrow_Below = 0x0362, //\tU+0362\tCombining Double Rightwards Arrow Below\n  U_Combining_Latin_Small_Letter_A = 0x0363, //\tU+0363\tCombining Latin Small Letter A\n  U_Combining_Latin_Small_Letter_E = 0x0364, //\tU+0364\tCombining Latin Small Letter E\n  U_Combining_Latin_Small_Letter_I = 0x0365, //\tU+0365\tCombining Latin Small Letter I\n  U_Combining_Latin_Small_Letter_O = 0x0366, //\tU+0366\tCombining Latin Small Letter O\n  U_Combining_Latin_Small_Letter_U = 0x0367, //\tU+0367\tCombining Latin Small Letter U\n  U_Combining_Latin_Small_Letter_C = 0x0368, //\tU+0368\tCombining Latin Small Letter C\n  U_Combining_Latin_Small_Letter_D = 0x0369, //\tU+0369\tCombining Latin Small Letter D\n  U_Combining_Latin_Small_Letter_H = 0x036a, //\tU+036A\tCombining Latin Small Letter H\n  U_Combining_Latin_Small_Letter_M = 0x036b, //\tU+036B\tCombining Latin Small Letter M\n  U_Combining_Latin_Small_Letter_R = 0x036c, //\tU+036C\tCombining Latin Small Letter R\n  U_Combining_Latin_Small_Letter_T = 0x036d, //\tU+036D\tCombining Latin Small Letter T\n  U_Combining_Latin_Small_Letter_V = 0x036e, //\tU+036E\tCombining Latin Small Letter V\n  U_Combining_Latin_Small_Letter_X = 0x036f, //\tU+036F\tCombining Latin Small Letter X\n\n  /**\n   * Unicode Character 'LINE SEPARATOR' (U+2028)\n   * http://www.fileformat.info/info/unicode/char/2028/index.htm\n   */\n  LINE_SEPARATOR = 0x2028,\n  /**\n   * Unicode Character 'PARAGRAPH SEPARATOR' (U+2029)\n   * http://www.fileformat.info/info/unicode/char/2029/index.htm\n   */\n  PARAGRAPH_SEPARATOR = 0x2029,\n  /**\n   * Unicode Character 'NEXT LINE' (U+0085)\n   * http://www.fileformat.info/info/unicode/char/0085/index.htm\n   */\n  NEXT_LINE = 0x0085,\n\n  // http://www.fileformat.info/info/unicode/category/Sk/list.htm\n  U_CIRCUMFLEX = 0x005e, // U+005E\tCIRCUMFLEX\n  U_GRAVE_ACCENT = 0x0060, // U+0060\tGRAVE ACCENT\n  U_DIAERESIS = 0x00a8, // U+00A8\tDIAERESIS\n  U_MACRON = 0x00af, // U+00AF\tMACRON\n  U_ACUTE_ACCENT = 0x00b4, // U+00B4\tACUTE ACCENT\n  U_CEDILLA = 0x00b8, // U+00B8\tCEDILLA\n  U_MODIFIER_LETTER_LEFT_ARROWHEAD = 0x02c2, // U+02C2\tMODIFIER LETTER LEFT ARROWHEAD\n  U_MODIFIER_LETTER_RIGHT_ARROWHEAD = 0x02c3, // U+02C3\tMODIFIER LETTER RIGHT ARROWHEAD\n  U_MODIFIER_LETTER_UP_ARROWHEAD = 0x02c4, // U+02C4\tMODIFIER LETTER UP ARROWHEAD\n  U_MODIFIER_LETTER_DOWN_ARROWHEAD = 0x02c5, // U+02C5\tMODIFIER LETTER DOWN ARROWHEAD\n  U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING = 0x02d2, // U+02D2\tMODIFIER LETTER CENTRED RIGHT HALF RING\n  U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING = 0x02d3, // U+02D3\tMODIFIER LETTER CENTRED LEFT HALF RING\n  U_MODIFIER_LETTER_UP_TACK = 0x02d4, // U+02D4\tMODIFIER LETTER UP TACK\n  U_MODIFIER_LETTER_DOWN_TACK = 0x02d5, // U+02D5\tMODIFIER LETTER DOWN TACK\n  U_MODIFIER_LETTER_PLUS_SIGN = 0x02d6, // U+02D6\tMODIFIER LETTER PLUS SIGN\n  U_MODIFIER_LETTER_MINUS_SIGN = 0x02d7, // U+02D7\tMODIFIER LETTER MINUS SIGN\n  U_BREVE = 0x02d8, // U+02D8\tBREVE\n  U_DOT_ABOVE = 0x02d9, // U+02D9\tDOT ABOVE\n  U_RING_ABOVE = 0x02da, // U+02DA\tRING ABOVE\n  U_OGONEK = 0x02db, // U+02DB\tOGONEK\n  U_SMALL_TILDE = 0x02dc, // U+02DC\tSMALL TILDE\n  U_DOUBLE_ACUTE_ACCENT = 0x02dd, // U+02DD\tDOUBLE ACUTE ACCENT\n  U_MODIFIER_LETTER_RHOTIC_HOOK = 0x02de, // U+02DE\tMODIFIER LETTER RHOTIC HOOK\n  U_MODIFIER_LETTER_CROSS_ACCENT = 0x02df, // U+02DF\tMODIFIER LETTER CROSS ACCENT\n  U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR = 0x02e5, // U+02E5\tMODIFIER LETTER EXTRA-HIGH TONE BAR\n  U_MODIFIER_LETTER_HIGH_TONE_BAR = 0x02e6, // U+02E6\tMODIFIER LETTER HIGH TONE BAR\n  U_MODIFIER_LETTER_MID_TONE_BAR = 0x02e7, // U+02E7\tMODIFIER LETTER MID TONE BAR\n  U_MODIFIER_LETTER_LOW_TONE_BAR = 0x02e8, // U+02E8\tMODIFIER LETTER LOW TONE BAR\n  U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR = 0x02e9, // U+02E9\tMODIFIER LETTER EXTRA-LOW TONE BAR\n  U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK = 0x02ea, // U+02EA\tMODIFIER LETTER YIN DEPARTING TONE MARK\n  U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK = 0x02eb, // U+02EB\tMODIFIER LETTER YANG DEPARTING TONE MARK\n  U_MODIFIER_LETTER_UNASPIRATED = 0x02ed, // U+02ED\tMODIFIER LETTER UNASPIRATED\n  U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD = 0x02ef, // U+02EF\tMODIFIER LETTER LOW DOWN ARROWHEAD\n  U_MODIFIER_LETTER_LOW_UP_ARROWHEAD = 0x02f0, // U+02F0\tMODIFIER LETTER LOW UP ARROWHEAD\n  U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD = 0x02f1, // U+02F1\tMODIFIER LETTER LOW LEFT ARROWHEAD\n  U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD = 0x02f2, // U+02F2\tMODIFIER LETTER LOW RIGHT ARROWHEAD\n  U_MODIFIER_LETTER_LOW_RING = 0x02f3, // U+02F3\tMODIFIER LETTER LOW RING\n  U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT = 0x02f4, // U+02F4\tMODIFIER LETTER MIDDLE GRAVE ACCENT\n  U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT = 0x02f5, // U+02F5\tMODIFIER LETTER MIDDLE DOUBLE GRAVE ACCENT\n  U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT = 0x02f6, // U+02F6\tMODIFIER LETTER MIDDLE DOUBLE ACUTE ACCENT\n  U_MODIFIER_LETTER_LOW_TILDE = 0x02f7, // U+02F7\tMODIFIER LETTER LOW TILDE\n  U_MODIFIER_LETTER_RAISED_COLON = 0x02f8, // U+02F8\tMODIFIER LETTER RAISED COLON\n  U_MODIFIER_LETTER_BEGIN_HIGH_TONE = 0x02f9, // U+02F9\tMODIFIER LETTER BEGIN HIGH TONE\n  U_MODIFIER_LETTER_END_HIGH_TONE = 0x02fa, // U+02FA\tMODIFIER LETTER END HIGH TONE\n  U_MODIFIER_LETTER_BEGIN_LOW_TONE = 0x02fb, // U+02FB\tMODIFIER LETTER BEGIN LOW TONE\n  U_MODIFIER_LETTER_END_LOW_TONE = 0x02fc, // U+02FC\tMODIFIER LETTER END LOW TONE\n  U_MODIFIER_LETTER_SHELF = 0x02fd, // U+02FD\tMODIFIER LETTER SHELF\n  U_MODIFIER_LETTER_OPEN_SHELF = 0x02fe, // U+02FE\tMODIFIER LETTER OPEN SHELF\n  U_MODIFIER_LETTER_LOW_LEFT_ARROW = 0x02ff, // U+02FF\tMODIFIER LETTER LOW LEFT ARROW\n  U_GREEK_LOWER_NUMERAL_SIGN = 0x0375, // U+0375\tGREEK LOWER NUMERAL SIGN\n  U_GREEK_TONOS = 0x0384, // U+0384\tGREEK TONOS\n  U_GREEK_DIALYTIKA_TONOS = 0x0385, // U+0385\tGREEK DIALYTIKA TONOS\n  U_GREEK_KORONIS = 0x1fbd, // U+1FBD\tGREEK KORONIS\n  U_GREEK_PSILI = 0x1fbf, // U+1FBF\tGREEK PSILI\n  U_GREEK_PERISPOMENI = 0x1fc0, // U+1FC0\tGREEK PERISPOMENI\n  U_GREEK_DIALYTIKA_AND_PERISPOMENI = 0x1fc1, // U+1FC1\tGREEK DIALYTIKA AND PERISPOMENI\n  U_GREEK_PSILI_AND_VARIA = 0x1fcd, // U+1FCD\tGREEK PSILI AND VARIA\n  U_GREEK_PSILI_AND_OXIA = 0x1fce, // U+1FCE\tGREEK PSILI AND OXIA\n  U_GREEK_PSILI_AND_PERISPOMENI = 0x1fcf, // U+1FCF\tGREEK PSILI AND PERISPOMENI\n  U_GREEK_DASIA_AND_VARIA = 0x1fdd, // U+1FDD\tGREEK DASIA AND VARIA\n  U_GREEK_DASIA_AND_OXIA = 0x1fde, // U+1FDE\tGREEK DASIA AND OXIA\n  U_GREEK_DASIA_AND_PERISPOMENI = 0x1fdf, // U+1FDF\tGREEK DASIA AND PERISPOMENI\n  U_GREEK_DIALYTIKA_AND_VARIA = 0x1fed, // U+1FED\tGREEK DIALYTIKA AND VARIA\n  U_GREEK_DIALYTIKA_AND_OXIA = 0x1fee, // U+1FEE\tGREEK DIALYTIKA AND OXIA\n  U_GREEK_VARIA = 0x1fef, // U+1FEF\tGREEK VARIA\n  U_GREEK_OXIA = 0x1ffd, // U+1FFD\tGREEK OXIA\n  U_GREEK_DASIA = 0x1ffe, // U+1FFE\tGREEK DASIA\n\n  U_OVERLINE = 0x203e, // Unicode Character 'OVERLINE'\n\n  /**\n   * UTF-8 BOM\n   * Unicode Character 'ZERO WIDTH NO-BREAK SPACE' (U+FEFF)\n   * http://www.fileformat.info/info/unicode/char/feff/index.htm\n   */\n  UTF8_BOM = 65279\n}\n", "import { join } from \"path\"\nimport { blank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { PS_LIBRARY_PROTOCOL } from \"../../fe/URI\"\nimport { posixPathFrom } from \"../fs/Path\"\nimport { Settings } from \"../settings/Settings\"\nimport { URI } from \"./URI\"\n\nexport const PSLIB_ROOT_URI = URI.from({\n  scheme: PS_LIBRARY_PROTOCOL,\n  path: \"\"\n})\n\nexport function nativePath2pslib(nativePath: string) {\n  const lp = Settings.libraryPath.value\n\n  if (blank(lp) || blank(nativePath) || !nativePath.startsWith(lp)) return\n\n  const path = \"/\" + posixPathFrom({ nativePath: lp }, { nativePath })\n\n  return URI.from({\n    scheme: PS_LIBRARY_PROTOCOL,\n    path\n  })\n}\n\nexport function pslib2nativePath(uri: URI): Maybe<string> {\n  if (uri.scheme !== PS_LIBRARY_PROTOCOL) {\n    throw new Error(\"invalid URI: \" + uri + \" (bad scheme)\")\n  }\n\n  const lp = Settings.libraryPath.value\n\n  if (blank(lp)) {\n    throw new Error(\"invalid URI: \" + uri + \" (no library set)\")\n  }\n\n  return join(lp, ...uri.path.split(\"/\"))\n}\n", "import { join, posix, sep } from \"path\"\nimport { blank, notBlank } from \"../../fe/Blank\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toA } from \"../../fe/toA\"\nimport { PS_NETWORK_FILESYSTEM_PROTOCOL } from \"../../fe/URI\"\nimport { native2posix, nativePathIsReadableDirectory } from \"../fs/Path\"\nimport { isEquivalentHost } from \"../net/nslookup\"\nimport { isWin } from \"../Platform\"\nimport { equalsIgnoreCase, stripPrefix } from \"../String\"\nimport { Volume } from \"../volumes/Volume\"\nimport { volumes } from \"../volumes/Volumes\"\nimport { URI } from \"./URI\"\n\nexport function nativePath2psnet(\n  nativePath: string,\n  vol: Maybe<Volume>\n): Maybe<URI> {\n  if (blank(nativePath)) return\n\n  // Prefer the volume, if available:\n  if (\n    vol != null &&\n    vol.remote === true &&\n    notBlank(vol.remoteHost) &&\n    notBlank(vol.remoteShare)\n  ) {\n    return URI.from({\n      scheme: PS_NETWORK_FILESYSTEM_PROTOCOL,\n      authority: vol.remoteHost,\n      path: posix.join(\n        \"/\" + vol.remoteShare,\n        stripPrefix(native2posix(nativePath), native2posix(vol.mountpoint))\n      )\n    })\n  }\n\n  // If it's a UNC path, URI knows how to handle it:\n  if (nativePath.startsWith(\"\\\\\\\\\")) {\n    return URI.file(nativePath).with({ scheme: PS_NETWORK_FILESYSTEM_PROTOCOL })\n  }\n\n  // Give up:\n  return\n}\n\nexport async function psnet2nativePath(\n  uri: URI,\n  mountpoint?: string\n): PromiseMaybe<string> {\n  if (uri.scheme !== PS_NETWORK_FILESYSTEM_PROTOCOL) {\n    throw new Error(\"invalid URI: \" + uri + \" (bad scheme)\")\n  }\n\n  if (blank(uri.authority)) {\n    throw new Error(\"invalid URI: \" + uri + \" (missing authority)\")\n  }\n\n  const arr = uri.path.split(\"/\").slice(1) // < slice(1) to skip over the '' due to the absolute path\n  const share = arr[0]\n\n  if (blank(share)) {\n    throw new Error(\"invalid URI: \" + uri + \" (missing share)\")\n  }\n\n  if (isWin) {\n    return `\\\\\\\\${uri.authority}\\\\${arr.join(sep)}`\n  }\n\n  const path = arr.slice(1)\n\n  // If there's a mounted drive with this share, use that:\n  const vols = await volumes()\n\n  for (const vol of toA(vols)) {\n    if (!vol.remote) continue\n    if (\n      equalsIgnoreCase(vol.remoteShare, share) &&\n      (await isEquivalentHost(uri.authority, vol.remoteHost))\n    ) {\n      return join(vol.mountpoint, ...path)\n    }\n  }\n\n  if (await nativePathIsReadableDirectory(mountpoint)) {\n    return join(mountpoint!, ...path)\n  }\n\n  return\n}\n", "import { uniq } from \"../../fe/Array\"\nimport { eql } from \"../../fe/Eql\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { toS } from \"../../fe/toS\"\nimport {\n  PS_LOCAL_FILE_PROTOCOL,\n  PS_NETWORK_FILESYSTEM_PROTOCOL\n} from \"../../fe/URI\"\nimport { thenMap2Or } from \"../async/Promise\"\nimport { mkLogger } from \"../Logger\"\nimport { uri2nativePath } from \"./FileURI\"\nimport { toURI, URI } from \"./URI\"\n\nconst uriPrefixes = [\n  \"http:\",\n  \"https:\",\n  \"file:\",\n  PS_LOCAL_FILE_PROTOCOL,\n  PS_NETWORK_FILESYSTEM_PROTOCOL\n].map(ea => ea + \"//\")\n\nexport function isUri(s: string): boolean {\n  const l = toS(s).toLowerCase()\n  return uriPrefixes.some(ea => l.startsWith(ea))\n}\n\nconst logger = lazy(() => mkLogger(\"UriNormalization\"))\n\nexport function normalizeURI(uri: string): string {\n  try {\n    return URI.parse(uri).toString()\n  } catch (err) {\n    logger().warn(\"Failed to normalize invalid URI\", { uri, err })\n    return uri\n  }\n}\n\n//\n// URI UNICODE NORMALIZATION\n//\n\n// We don't store normalized unicode URIs, as this allows us to store the actual\n// filename characters.\n\n// We *do* compare URIs by normalizing them, so macOS (using NFD) and other\n// filesystems (using NFC) can be considered equivalent.\n\nexport function uriEqlSync(a: string, b: string) {\n  try {\n    if (a == null || b == null) return false\n    const au = URI.parse(a)\n    const bu = URI.parse(b)\n    return (\n      au.scheme === bu.scheme &&\n      au.authority === bu.authority &&\n      au.path.normalize() === bu.path.normalize()\n    )\n  } catch {\n    return false\n  }\n}\n\nexport async function uriIsEquivalent(\n  a: Maybe<string | URI>,\n  b: Maybe<string | URI>\n) {\n  try {\n    if (a == null || b == null) return false\n    if (eql(a, b)) return true\n    const aStr = a.toString()\n    const bStr = b.toString()\n    if (uriEqlSync(aStr, bStr)) return true\n    return await thenMap2Or(\n      uri2nativePath(aStr),\n      uri2nativePath(bStr),\n      (ap, bp) => ap.normalize() === bp.normalize(),\n      () => false\n    )\n  } catch {\n    return false\n  }\n}\n\nexport function uriEncodingVariants(uri: string | URI): string[] {\n  const u = toURI(uri)\n  return uniq([\n    u.toString(),\n    u.with({ path: u.path.normalize(\"NFC\") }).toString(),\n    u.with({ path: u.path.normalize(\"NFD\") }).toString()\n  ])\n}\n", "import { flatten, uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { toA } from \"../../fe/toA\"\nimport {\n  PS_LIBRARY_PROTOCOL,\n  PS_LOCAL_FILE_PROTOCOL,\n  PS_NETWORK_FILESYSTEM_PROTOCOL\n} from \"../../fe/URI\"\nimport { firstDefinedLater } from \"../async/Later\"\nimport { thenCompact, thenMap, thenOrElse } from \"../async/Promise\"\nimport { mkLogger } from \"../Logger\"\nimport { Volume } from \"../volumes/Volume\"\nimport { volumeFor } from \"../volumes/Volumes\"\nimport { nativePath2psfile, psfile2nativePath } from \"./psfile\"\nimport { nativePath2pslib, pslib2nativePath } from \"./pslib\"\nimport { nativePath2psnet, psnet2nativePath } from \"./psnet\"\nimport { URI } from \"./URI\"\nimport { uriEncodingVariants } from \"./UriNormalization\"\n\nconst logger = lazy(() => mkLogger(\"FileURI\"))\n\nexport async function nativePath2uri(\n  nativePath: string,\n  volume?: Volume\n): Promise<URI> {\n  if (nativePath == null || blank(nativePath)) {\n    return logger().throw(\"empty nativePath passed to nativePath2uri()\", {\n      retriable: false\n    })\n  }\n\n  const vol = lazy(() => thenOrElse(volume, () => volumeFor(nativePath)))\n\n  return firstDefinedLater(\n    () => nativePath2pslib(nativePath),\n    async () => nativePath2psfile(nativePath, await vol()),\n    async () => nativePath2psnet(nativePath, await vol()),\n    () => URI.file(nativePath)\n  ) as any\n}\n\nexport async function nativePath2uris(nativePath: string): Promise<URI[]> {\n  const vol = await volumeFor(nativePath)\n  return thenCompact([\n    nativePath2pslib(nativePath),\n    nativePath2psfile(nativePath, vol),\n    nativePath2psnet(nativePath, vol),\n    URI.file(nativePath)\n  ])\n}\n\nexport async function nativePath2uriVariants(\n  nativePath: string\n): Promise<string[]> {\n  const arr = await nativePath2uris(nativePath)\n  return uniq(flatten(arr.map(uriEncodingVariants)))\n}\n\nexport async function uriVariants(\n  uri: string,\n  mountpoint?: string\n): Promise<string[]> {\n  const result = uriEncodingVariants(uri)\n  result.push(\n    ...toA(\n      await thenMap(uri2nativePath(uri, mountpoint), nativePath2uriVariants)\n    )\n  )\n  return uniq(result)\n}\n\nfunction toURI(uri: string | URI): Maybe<URI> {\n  try {\n    if (URI.isUri(uri)) return uri\n    return URI.parse(uri, true)\n  } catch (err) {\n    logger().warn(\"bad URI\", { uri, err })\n    return\n  }\n}\n\nexport async function uri2nativePath(\n  uri: string | URI,\n  mountpoint?: string\n): PromiseMaybe<string> {\n  if (blank(uri)) return\n  const u = toURI(uri)\n  if (u == null) return\n\n  switch (u.scheme) {\n    case \"file\":\n      return u.fsPath\n    case PS_LOCAL_FILE_PROTOCOL:\n      return psfile2nativePath(u, mountpoint)\n    case PS_NETWORK_FILESYSTEM_PROTOCOL:\n      return psnet2nativePath(u, mountpoint)\n    case PS_LIBRARY_PROTOCOL:\n      return pslib2nativePath(u)\n    default:\n      throw new Error(\"unsupported URI: \" + uri)\n  }\n}\n", "import { notBlank } from \"../../fe/Blank\"\nimport { secondMs } from \"../../fe/Date\"\nimport { toInt } from \"../../fe/Number\"\nimport { opt } from \"../../fe/Opt\"\nimport { SyncOrAsync } from \"../../fe/OptAsync\"\nimport { stdout } from \"../child/ChildProcess\"\nimport { isMac, isWin } from \"../Platform\"\nimport { PowerShell, pwshQuote } from \"../pwsh/PowerShell\"\nimport { SimpleFile } from \"./SimpleFile\"\n\nasync function hiddenWin(file: SimpleFile) {\n  const json = await PowerShell.instance().executeJsonToA(\n    [\n      \"Get-Item -Force -LiteralPath\",\n      pwshQuote(file.nativePath),\n      \"-ErrorAction SilentlyContinue\",\n      \"| Select-Object -Property Name, Mode\"\n    ].join(\" \")\n  )\n  return (\n    opt(json)\n      .flatMap(ea => ea[0])\n      .flatMap(ea => ea.Mode)\n      .filter(notBlank)\n      // See https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-childitem?view=powershell-5.1#examples\n      .flatMap((mode: string) => mode.includes(\"h\") || mode.includes(\"s\"))\n      .getOrElse(() => false)\n  )\n}\n\nasync function hiddenMac(file: SimpleFile) {\n  try {\n    const out = await stdout(\"stat\", [\"-f\", \"%f\", file.nativePath], {\n      timeout: 10 * secondMs\n    })\n    const flags = toInt(out)\n    if (flags != null) {\n      return (flags & 0x8000) > 0 // from /usr/include/sys/stat.h\n    } else {\n      return false\n    }\n  } catch (err) {\n    return false\n  }\n}\n\nexport function hidden(file: SimpleFile): SyncOrAsync<boolean> {\n  if (file.base.startsWith(\".\")) return true\n  return isWin ? hiddenWin(file) : isMac ? hiddenMac(file) : false\n}\n", "import { orElse } from \"../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../fe/MaybeTypes\"\nimport { keys } from \"../fe/Object\"\nimport { SyncOrAsync } from \"../fe/OptAsync\"\nimport { ContextualLogger } from \"./log/Logger\"\n\nexport interface BooleanThunk {\n  (): Maybe<boolean>\n}\n\n// TODO: SITS: COMBINE WITH PREDICATE\nexport interface BooleanLater {\n  (): Maybe<boolean> | PromiseMaybe<boolean>\n}\n\n// function log({\n//   logger,\n//   name,\n//   result\n// }: {\n//   logger: ContextualLogger\n//   name: string\n//   result: Maybe<boolean>\n// }) {\n//   const level = result == null ? \"warn\" : \"debug\"\n//   logger.log(\n//     level,\n//     darkGrey(name) + \": \" + (result === true ? green : red)(toS(result))\n//   )\n// }\n\nexport function orLogged(\n  predicates: { [key: string]: BooleanThunk }[],\n  name: string,\n  logger: ContextualLogger\n): boolean {\n  const results: BooleanValued = {}\n  try {\n    for (const predicate of predicates) {\n      for (const ea of keys(predicate)) {\n        const result = predicate[ea]()\n        results[ea] = orElse(result, false)\n        if (result === true) return result\n      }\n    }\n    return false\n  } finally {\n    logValues(logger, name, results)\n  }\n  //  return predicates.some(predicate =>\n  //   keys(predicate).some(name =>\n  //     isTrue(\n  //       tap(predicate[name](), result =>\n  //         log({\n  //           logger,\n  //           name,\n  //           result\n  //         })\n  //       )\n  //     )\n  //   )\n  // )\n}\n\nexport type AsyncPredicates = {\n  [key: string]: () => SyncOrAsync<boolean>\n}\n\nexport interface BooleanValued {\n  [key: string]: boolean\n}\n\nfunction logValues(logger: ContextualLogger, name: string, b: BooleanValued) {\n  const level = b == null ? \"warn\" : \"debug\"\n  logger.log(level, name, b)\n}\n\nexport async function orLoggedAsync(\n  predicates: AsyncPredicates[],\n  name: string,\n  logger: ContextualLogger\n): Promise<boolean> {\n  const results: BooleanValued = {}\n  try {\n    for (const predicate of predicates) {\n      for (const ea of keys(predicate)) {\n        const result = await predicate[ea]()\n        results[ea] = result\n        if (result) return result\n      }\n    }\n    return false\n  } finally {\n    logValues(logger, name, results)\n  }\n}\n", "import { getOrSet } from \"../fe/Map\"\nimport { map } from \"../fe/Maybe\"\nimport { Maybe } from \"../fe/MaybeTypes\"\nimport { mapGte0 } from \"./Number\"\n\n/**\n * Supports efficient lookup for 2-tuple matches\n */\nexport class SetSet {\n  private readonly store = new Map<string, Set<string>>()\n\n  add(elem1: string, elem2: string) {\n    getOrSet(this.store, elem1, () => new Set<string>()).add(elem2)\n  }\n\n  delete(elem1: string, elem2: string) {\n    map(this.store.get(elem1), set => {\n      set.delete(elem2)\n      if (set.size === 0) this.store.delete(elem1)\n    })\n  }\n\n  find(needle: string[]): Maybe<string[]> {\n    return mapGte0(\n      needle.findIndex((ea, idx) => this.store.get(ea)?.has(needle[idx + 1])),\n      idx => needle.slice(idx, idx + 2)\n    )\n  }\n\n  has(arr: string[]) {\n    return this.find(arr) != null\n  }\n}\n", "import { compactBlanks } from \"../../fe/Array\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { emitFileChanged, onClearCache } from \"../event/EventEmitter\"\nimport { mkLogger } from \"../Logger\"\nimport { Predicates } from \"../Predicates\"\nimport { Settings } from \"../settings/Settings\"\nimport { resolveSimpleFile } from \"./Path\"\nimport { SimpleFile } from \"./SimpleFile\"\n\nconst logger = lazy(() => mkLogger(\"NeverIgnoredPaths\"))\n\nconst listenForChanges = lazy(() => {\n  Settings.neverIgnored.addListener(() => {\n    NeverIgnored.clear()\n    emitFileChanged()\n    logger().info(\"Settings.neverIgnored changed\", Settings.neverIgnored.value)\n  })\n  Settings.scanPaths.addListener(() => {\n    NeverIgnored.clear()\n    emitFileChanged()\n  })\n  onClearCache(() => NeverIgnored.clear())\n})\n\nconst NeverIgnored = lazy(() => {\n  listenForChanges()\n  return new Set<string>(\n    compactBlanks([\n      ...Settings.scanPaths.values,\n      ...Settings.neverIgnored.values\n    ])\n  )\n})\n\nexport function pathIsNeverIgnored(nativePath: string): boolean {\n  return (\n    NeverIgnored().has(nativePath) ||\n    NeverIgnored().has(nativePath.toLowerCase())\n  )\n}\n\nexport function neverIgnore(...arr: (string | SimpleFile)[]) {\n  Settings.neverIgnored.push(...compactBlanks(arr).map(resolveSimpleFile))\n}\n\nexport function pathIsNeverIgnoredPredicate(\n  nativePath: string\n): Maybe<Predicates> {\n  return pathIsNeverIgnored(nativePath)\n    ? { pathIsNeverIgnored: () => false }\n    : undefined\n}\n", "import { join } from \"path\"\nimport { minuteMs } from \"../../fe/Date\"\nimport { later } from \"../../fe/Delay\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { thenMap } from \"../async/Promise\"\nimport { onClearCache, onFileChanged } from \"../event/EventEmitter\"\nimport { FifoCacheAsync } from \"../FifoCache\"\nimport { mkLogger } from \"../Logger\"\nimport { MountpointsTtlMs } from \"../volumes/VolumeTtls\"\nimport { BaseFile } from \"./BaseFile\"\nimport { pathIsNeverIgnored } from \"./NeverIgnoredPaths\"\nimport { nativePathExists, pathnames } from \"./Path\"\nimport { SimpleFile } from \"./SimpleFile\"\n\n// We're making the dot optional (although that isn't part of the spec)\nconst nomediaRe = /^\\.?NoMedia$/i\n\nconst NoMedia = \"NoMedia\"\n\nfunction variants(s: string) {\n  return [s, s.toLowerCase(), s.toUpperCase()]\n}\n\nconst NoMediaNames = Object.freeze([\n  ...variants(\".\" + NoMedia),\n  ...variants(NoMedia)\n])\n\nexport function isNoMediaName(basename: string): boolean {\n  return nomediaRe.exec(basename) != null\n}\n\nconst cache = new FifoCacheAsync<Maybe<boolean>>({\n  maxSize: 1024,\n  timeoutMs: MountpointsTtlMs,\n  clearEveryMs: minuteMs\n})\n\nlater(() => onClearCache(() => cache.clear()))\nlater(() =>\n  onFileChanged(path => {\n    path == null ? cache.clear() : cache.deleteIf(key => key.startsWith(path))\n  })\n)\n\nconst logger = lazy(() => mkLogger(\"hasNoMedia()\"))\n\nexport async function hasNoMedia(sf: Maybe<SimpleFile>): PromiseMaybe<boolean> {\n  if (sf == null) return false\n\n  // Before checking the cache, do any simple tests say we are NoMedia?\n\n  if (pathIsNeverIgnored(sf.nativePath)) {\n    return logger().tap({ msg: sf + \" is never ignored\", result: false })\n  }\n\n  if (sf instanceof BaseFile) {\n    // Avoid instantiating tons of BaseFiles:\n    return hasNoMedia(await sf.directoryEntry())\n  }\n\n  // Are we an actual NoMedia file?\n\n  if (isNoMediaName(sf.base)) {\n    // this doesn't need to be cached, it's almost a no-op:\n    return logger().tap({ msg: sf + \" basename is NoMedia\", result: true })\n  }\n\n  // Are any of my parent directories NoMedia?\n\n  if (pathnames(sf.nativePath).some(isNoMediaName)) {\n    // this doesn't need to be cached, it's almost a no-op:\n    return logger().tap({ msg: sf + \" parent path is NoMedia\", result: true })\n  }\n\n  if (await sf.isDirectory()) {\n    const thisHasNoMedia = await cache.getOrSetAsync(\n      sf.nativePath,\n      async () => {\n        for (const ea of NoMediaNames) {\n          if (await nativePathExists(join(sf.nativePath, ea))) {\n            return logger().tap({\n              msg: sf + \" is a directory and has a noMedia child, \" + ea,\n              result: true\n            })\n          }\n        }\n        return false\n      }\n    )\n\n    if (thisHasNoMedia === true) return true\n  }\n  return sf.isRoot ? false : thenMap(sf.parent(), hasNoMedia)\n}\n", "import { count } from \"../../fe/Array\"\nimport { Settings } from \"../settings/Settings\"\n\n/**\n * Naive detection of symlink loops\n */\nexport function seemsRecursive(path: string[]): boolean {\n  const max = Settings.maxDuplicatePathElements.valueOrDefault\n  for (const ea of new Set(path)) {\n    if (count(path, el => el === ea) > max) return true\n  }\n  return false\n}\n", "import { entries, Valued } from \"../../fe/Object\"\nimport { flatMap } from \"../Array\"\nimport { darkGrey, green, red } from \"../Chalk\"\nimport { Filter } from \"../Filter\"\nimport { Logger } from \"../Logger\"\nimport { ellipsize } from \"../String\"\nimport { filter } from \"./Predicate\"\nimport { thenNot } from \"./Promise\"\n\nexport type AnyFilter<T> = Filter<T> | AsyncFilter<T>\n\nexport class AsyncFilter<T> {\n  constructor(readonly apply: (item: T) => Promise<boolean>) {}\n\n  static lift<T1>(f: (item: T1) => Promise<boolean>): AsyncFilter<T1> {\n    return new AsyncFilter(f)\n  }\n\n  static and<T1>(...filters: AnyFilter<T1>[]): AsyncFilter<T1> {\n    return new AsyncFilter(async (item: T1) => {\n      for (const f of filters) {\n        if (!(await f.apply(item))) return false\n      }\n      return true\n    })\n  }\n\n  static or<T1>(...filters: AnyFilter<T1>[]): AsyncFilter<T1> {\n    return new AsyncFilter(async (item: T1) => {\n      for (const f of filters) {\n        if (await f.apply(item)) return true\n      }\n      return false\n    })\n  }\n\n  static logged<T1>(\n    logger: Logger,\n    ...filters: { [key: string]: AnyFilter<T1> }[]\n  ) {\n    return flatMap(filters, ea =>\n      entries(ea).map(([key, value]) => value.asAsync().logged(logger, key))\n    )\n\n    // const tuples = flatten(filters.map(entries))\n    // return tuples.map(([k, v]) => v.asAsync().logged(logger, k))\n  }\n\n  static andLogged<T1>(\n    logger: Logger,\n    ...filters: { [key: string]: AnyFilter<T1> }[]\n  ): AsyncFilter<T1> {\n    return this.and(...this.logged(logger, ...filters))\n  }\n\n  static orLogged<T1>(\n    logger: Logger,\n    ...filters: Valued<AnyFilter<T1>>[]\n  ): AsyncFilter<T1> {\n    return this.or(...this.logged(logger, ...filters))\n  }\n\n  static async andExplain<T1>(\n    t: T1,\n    filters: Valued<AnyFilter<T1>>[]\n  ): Promise<{ accepted: string[]; rejected: string[] }> {\n    const accepted: string[] = []\n    const rejected: string[] = []\n    for (const filterObj of filters) {\n      for (const [name, ea] of entries(filterObj)) {\n        ;((await ea.apply(t)) ? accepted : rejected).push(name)\n      }\n    }\n    return {\n      accepted,\n      rejected\n    }\n  }\n\n  asAsync(): this {\n    return this\n  }\n\n  and(...that: this[]): this {\n    return AsyncFilter.and(this, ...that) as this\n  }\n\n  not(): this {\n    return new AsyncFilter((t: T) => thenNot(this.apply(t))) as this\n  }\n\n  or(that: this): this {\n    return new AsyncFilter(\n      async (item: T) =>\n        // don't need to await that.apply:\n        (await this.apply(item)) || (await that.apply(item))\n    ) as this\n  }\n\n  async filter(arr: T[]): Promise<T[]> {\n    return filter(arr, ea => this.apply(ea))\n  }\n\n  // SITS: this duplicates the Predicates.orLoggedAsync code: DRY. later?\n  logged(logger: Logger, description: string): AsyncFilter<T> {\n    const af = new AsyncFilter(async (item: T) => {\n      const result = await this.apply(item)\n      logger.log(\n        result ? \"debug\" : \"info\",\n        [\n          darkGrey(description),\n          result ? green(\"ACCEPT\") : red(\"REJECT\"),\n          ellipsize(item)\n        ].join(\" \")\n      )\n      return result\n    })\n    return af\n  }\n}\n", "import { secondMs } from \"../../fe/Date\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { toA } from \"../../fe/toA\"\nimport { AsyncFilter } from \"../async/AsyncFilter\"\nimport { stdout } from \"../child/ChildProcess\"\nimport { parseFixed } from \"../Fixed\"\nimport { mkLogger } from \"../Logger\"\nimport { isDocker, isLinux } from \"../Platform\"\nimport { pathnames } from \"./Path\"\nimport { SimpleFile } from \"./SimpleFile\"\n\nconst logger = mkLogger(\"Snap\")\n\n// Some snaps will mount the home directory into the snap, so we get assetfile dupes like\n// file:///home/mrm/snap/spotify/current/Pictures/2015/2015-12-29/IMG_20151229_160926.jpg and\n// file:///home/mrm/snap/spotify/13/Pictures/2016/2015-12-29/IMG_20151229_160926.jpg\n\nexport const ignorableSnapDir: AsyncFilter<SimpleFile> = AsyncFilter.lift(\n  async (file: SimpleFile) => {\n    // Snap is currently only available on linux:\n    if (!(await hasSnap())) return false\n    // Only call snaps() if a pathname is \"snap\":\n    const paths = pathnames(file.nativePath)\n    const idx = paths.indexOf(\"snap\")\n    if (idx < 0) return false\n    return toA(await snaps()).includes(pathnames[idx + 1])\n  }\n)\n\nexport const hasSnap = lazy(async () => {\n  // snap isn't on the alpine docker image:\n  if (!isLinux || isDocker()) return false\n\n  try {\n    await stdout(\"snap\", [\"--version\"], {\n      timeout: 10 * secondMs,\n      quiet: true,\n      maxRetries: 0\n    })\n    return true\n  } catch {\n    return false\n  }\n})\n\n/*\n\n$ snap list\nName              Version                 Rev   Tracking  Developer     Notes\nbitwarden         1.2.0                   4     stable    bitwarden     -\ncore              16-2.33.1               4917  stable    canonical     core\nffmpeg            4.0                     13    stable    snapcrafters  classic\ninkscape          0.92.3                  4019  stable    inkscape      -\nkde-frameworks-5  5.47.0                  27    stable    kde           -\nspotify           1.0.80.474.gef6b503e-7  16    stable    spotify       -\nvlc               3.0.3-1-3-gf09fd0d      365   stable    videolan      -\n\n*/\n\nexport const snaps = lazy(async () => {\n  if (!(await hasSnap())) return []\n  try {\n    // We don't use Version, but if we don't have the next column past \"Name\",\n    // the whole input will be considered a single column.\n    return await parseFixed(\n      [\"Name\", \"Version\"],\n      await stdout(\"snap\", [\"list\"], { timeout: 10 * secondMs })\n    ).map(ea => ea.Name as string)\n  } catch (err) {\n    logger.warn(\"snap failed\", err)\n    return []\n  }\n}, 30 * secondMs)\n", "import { compactBlanks, uniq } from \"../../fe/Array\"\nimport { blank } from \"../../fe/Blank\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { appData } from \"../AppData\"\nimport { thenMapOr } from \"../async/Promise\"\nimport { getEnv } from \"../Env\"\nimport { AsyncPredicates, orLogged, orLoggedAsync } from \"../LoggedThunks\"\nimport { mkLogger } from \"../Logger\"\nimport { isTest } from \"../NodeEnv\"\nimport { isLinux, isWin } from \"../Platform\"\nimport { Predicates } from \"../Predicates\"\nimport { SetSet } from \"../SetSet\"\nimport { mountpoints } from \"../volumes/Mountpoints\"\nimport { hidden } from \"./Hidden\"\nimport {\n  pathIsNeverIgnored,\n  pathIsNeverIgnoredPredicate\n} from \"./NeverIgnoredPaths\"\nimport { hasNoMedia } from \"./NoMedia\"\nimport { native2posix, pathnames } from \"./Path\"\nimport { PosixFile } from \"./PosixFile\"\nimport { seemsRecursive } from \"./SeemsRecursive\"\nimport { SimpleFile } from \"./SimpleFile\"\nimport { ignorableSnapDir } from \"./Snap\"\n\n/**\n * This is a steaming bag of whack-a-mole heuristics to prevent iterating\n * \"ignorable\" directories. These are OS or application directories which\n * frequently make up the bulk of files on many drives, but never include assets\n * that users want to include in their libraries.\n *\n * It's messy down here. Scroll down at your own peril.\n *\n * Also, because people access volumes with different OSes, we won't assume that\n * a given drive was used by the current OS, so \"C:\\\\etc\" on windows and\n * \"/Program Files/\" on mac should be considered ignorable directories, and be\n * skipped.\n */\nexport class Ignorable {\n  private readonly ignorableRootDirectories = new Set(\n    [\n      // See http://www.linfo.org/var.html\n      // https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard\n      // http://www.pathname.com/fhs/\n\n      // bin and boot don't have many files, let them get scanned\n      // \"bin\", // Essential command binaries\n      // \"boot\", // Boot loader files\n      \"dev\", // Essential device files\n      \"etc\", // Host-specific system-wide configuration files\n      \"initrd\", // initial ramdisk\n      \"lib\", // Libraries essential for the binaries in /bin and /sbin.\n      \"lost+found\",\n      \"proc\", // Virtual filesystem providing process and kernel information as files.\n      // \"root\", // Home directory for the root user (might have something?)\n      \"sbin\", // Essential system binaries\n      \"sys\", // Contains information about devices, drivers, and some kernel features\n      \"tmp\", // tmp is tmp\n      // \"var\", < Some people mounted their docker volume to /var/photos:\n\n      \"System\", // mac and win\n\n      // windows\n      \"Dell\", // drivers\n      \"Intel\", // drivers\n      \"Microsoft\", // drivers\n      \"NVIDIA\", // surprisingly large driver (> 4gb!)\n      \"temp\",\n      // DON'T INCLUDE /Volumes here, as that causes all external drives to be\n      // rejected!\n      \"Windows.old\", // thanks, windows updater\n      \"Windows\"\n    ].map(s => s.toLowerCase().normalize())\n  ) // case insensitivity\n\n  /**\n   * All these directories are sufficiently nerdy that they uniquely identify a\n   * system or development directory, and don't need to be anchored to, say, / to\n   * be sufficiently constrained.\n   */\n  private readonly ignorableDirectories = new Set(\n    [\n      \"#snapshot\", // backup snapshots on synology\n      \"__MACOSX\", // resource fork\n      \"_includes\", // source tree\n      \"@eaDir\", // synology thumbs\n      \"@Recycle\", // qnap trash\n      \"@SynoResource\", // synology\n      \"#recycle\", // synology trash\n      \"$Recycle.Bin\", // windows trash\n      \"3rdParty\", // source\n      \"Application Data\", // win\n      \"Application Support\", // mac\n      \"Applications\", // mac\n      \"arangodb\", // their 3rdparty subdir is a menace\n      \"cache\",\n      \"caches\",\n      \"CacheClip\", // movie app cache dir\n      \"cmake\", // dev\n      \"com.apple.TimeMachine.localsnapshots\", // mac\n      \"cpan\", // hello old frenemy\n      \"DefinitelyTyped\", // roughly infinite subdirectories\n      \"Desktop DB\", // mac\n      \"Desktop DF\", // mac\n      \"Desktop.ini\", // mac\n      \"DisplayDriver\", // win\n      // \"Download\", // these might actually have something\n      // \"Downloads\",\n      \"ehthumbs.db\", // win\n      \"iMovie Cache\",\n      \"iTunes Cache\",\n      \"iTunes Media\", // music videos: see https://gitlab.com/mceachen/photostructure/issues/102\n      \"iTunes\", // music videos: see https://gitlab.com/mceachen/photostructure/issues/102\n      \"lost+found\", // posix\n      \"Network Trash Folder\",\n      \"node_modules\", // ugh, nothing good in there\n      \"pkgconfig\", // dev\n      \"pkgs\", // python\n      \"Program Files (x86)\", //win\n      \"Program Files\", // win\n      \"ProgramData\", // win\n      \"site-packages\", // python\n      \"spotifycache\", // muzak\n      \"SteamApps\", // win\n      \"System Volume Information\", // win\n      \"System32\", // win\n      \"temp\",\n      \"Temporary Items\", // win\n      \"test_suite\", // source\n      \"testutils\", // source\n      \"third_party\", // source\n      \"Thumbnails\", // iPhoto\n      \"Thumbs.db\", // win\n      \"tmp\",\n      \"Trash\", // xdg trash https://specifications.freedesktop.org/trash-spec/trashspec-1.0.html\n      \"Windows10Upgrade\",\n      \"Xcode.app\"\n    ].map(s => s.toLowerCase())\n  )\n\n  // These paths are all \"posix-ized\" before being applied\n  private readonly ignorableDirectoryPatterns = [\n    /.sparsebundle\\/bands(\\/|$)/i, // < mac time machine backups like \".../bob's mac.sparsebundle/bands/...\"\n    /\\/resources\\/media\\/face/i, // iPhoto face tiles\n    /\\/facetile[-_]/i, // iPhoto face tiles\n    /\\/.*?\\.photos?library\\/(?!(masters?|originals)\\/)/i, // iPhoto subdirectories except for Master, Masters, or Originals.\n    /\\/ImageMagick[\\d.-]*(\\/|$)/i,\n    /\\/Install OS X .+\\.app(\\/|$)/i,\n    /Previews\\.lrdata(\\/|$)/i, // lightroom\n    /\\/MinGW-.+(\\/|$)/i, // MSYS and variants\n    /\\/msys[\\d.-]*(\\/|$)/i, // msys or msys64\n    /\\/Python[\\d.-]*(amd64|x64)?(\\/|$)/i, // Python may not have a version\n    /\\/Ruby[\\d.-]+(amd64|x64)?(\\/|$)/i // Ruby directories always seem to have a version number\n  ]\n\n  private readonly systemDirs = uniq(\n    compactBlanks([\n      appData(),\n      getEnv(\"APPDATA\"),\n      getEnv(\"SYSTEMROOT\"),\n      getEnv(\"ProgramFiles\"),\n      getEnv(\"ProgramFiles(x86)\")\n    ]).map(ea => ea.toLowerCase().normalize())\n  )\n\n  // Some \"ignorable\" paths need more than just a single pathname to be sure it's\n  // ignorable. For example, just ignoring all folders named \"Library\" would not\n  // be safe.\n  private readonly ignorableSubdirs = new SetSet()\n  addIgnorableSubdirs(root: string, children: string[]) {\n    if (blank(root)) return\n    const l = root.toLowerCase().normalize()\n    compactBlanks(children).forEach(ea =>\n      this.ignorableSubdirs.add(l, ea.toLowerCase().normalize())\n    )\n  }\n\n  constructor(testing: boolean = isTest) {\n    if (isLinux) {\n      this.ignorableRootDirectories.add(\"run\")\n      this.ignorableRootDirectories.add(\"snap\")\n    }\n\n    this.addIgnorableSubdirs(\"nix\", [\"store\"])\n\n    const subdirs = [\n      \"bin\",\n      \"cygdrive\",\n      \"dev\",\n      \"etc\",\n      \"games\",\n      \"include\",\n      \"lib\",\n      \"lib32\",\n      \"local\",\n      \"locale\",\n      \"man\",\n      \"proc\",\n      \"sbin\",\n      \"share\",\n      \"src\",\n      \"tmp\",\n      \"usr\",\n      \"var\"\n    ]\n\n    this.addIgnorableSubdirs(\"usr\", subdirs)\n    this.addIgnorableSubdirs(\"cygwin\", subdirs)\n    this.addIgnorableSubdirs(\"cygwin64\", subdirs)\n    this.addIgnorableSubdirs(\"local\", subdirs)\n\n    // These can be found in backups:\n    this.addIgnorableSubdirs(\"Windows\", [\n      \"Boot\",\n      \"Containers\",\n      \"Cursors\",\n      \"Fonts\",\n      \"Help\",\n      \"Installer\",\n      \"Logs\",\n      \"Microsoft.NET\",\n      \"SoftwareDistribution\",\n      \"System\",\n      \"System32\",\n      \"SysWOW64\",\n      \"Temp\"\n    ])\n\n    this.addIgnorableSubdirs(\"lib\", [\n      \"firmware\",\n      \"modules\",\n      \"systemd\",\n      \"udev\",\n      \"x86_64-linux-gnu\"\n    ])\n    this.addIgnorableSubdirs(\"opt\", [\"google\", \"x11\", ...subdirs])\n\n    // git:\n    this.addIgnorableSubdirs(\"lfs\", [\"objects\"])\n\n    // https://www.tldp.org/LDP/sag/html/var-fs.html\n    this.addIgnorableSubdirs(\"var\", [\n      \"cache\",\n      \"crash\",\n      \"games\",\n      \"lib\",\n      \"local\",\n      \"lock\",\n      \"log\",\n      \"mail\",\n      \"run\",\n      \"snap\",\n      \"spool\",\n      \"tmp\"\n    ])\n\n    // linux backups:\n    this.addIgnorableSubdirs(\"dev\", [\n      \"block\",\n      \"bsg\",\n      \"bus\",\n      \"char\",\n      \"cpu\",\n      \"disk\",\n      \"dri\",\n      \"fd\",\n      \"hugepages\",\n      \"input\",\n      \"lightnvm\",\n      \"mapper\",\n      \"mqueue\",\n      \"net\",\n      \"pts\",\n      \"shm\",\n      \"snd\",\n      \"ubuntu-vg\",\n      \"usb\",\n      \"vfio\"\n    ])\n    this.addIgnorableSubdirs(\"proc\", [\n      \"acpi\",\n      \"asound\",\n      \"bus\",\n      \"driver\",\n      \"fs\",\n      \"ipmi\",\n      \"irq\",\n      \"net\",\n      \"scsi\",\n      \"self\",\n      \"sys\",\n      \"sysvipc\",\n      \"thread-self\",\n      \"tty\"\n    ])\n\n    // Mac Library folders:\n    this.addIgnorableSubdirs(\"library\", [\n      \"Application Support\",\n      \"Audio\",\n      \"Bundles\",\n      \"Caches\",\n      \"ColorPickers\",\n      \"ColorSync\",\n      \"Components\",\n      \"Compositions\",\n      \"Contextual Menu Items\",\n      \"CoreAnalytics\",\n      \"CoreMediaIO\",\n      \"Desktop Pictures\",\n      \"Developer\",\n      \"Dictionaries\",\n      \"DirectoryServices\",\n      \"Documentation\",\n      \"Extensions\",\n      \"Filesystems\",\n      \"Fonts\",\n      \"Frameworks\",\n      \"GPUBundles\",\n      \"Graphics\",\n      \"Image Capture\",\n      \"Input Methods\",\n      \"Internet Plug-Ins\",\n      \"iTunes\",\n      \"Java\",\n      \"Keyboard Layouts\",\n      \"Keychains\",\n      \"LaunchAgents\",\n      \"LaunchDaemons\",\n      \"Logs\",\n      \"Messages\",\n      \"MessageTracer\",\n      \"Modem Scripts\",\n      \"OpenDirectory\",\n      \"PDF Services\",\n      \"Perl\",\n      \"PreferencePanes\",\n      \"Preferences\",\n      \"Printers\",\n      \"PrivilegedHelperTools\",\n      \"Python\",\n      \"QuickLook\",\n      \"QuickTime\",\n      \"Receipts\",\n      \"Ruby\",\n      \"Sandbox\",\n      \"Screen Savers\",\n      \"ScriptingAdditions\",\n      \"Scripts\",\n      \"Security\",\n      \"Speech\",\n      \"Spotlight\",\n      \"StagedExtensions\",\n      \"StartupItems\",\n      \"SystemProfiler\",\n      \"Updates\",\n      \"User Pictures\",\n      \"Video\",\n      \"WebServer\",\n      \"Widgets\"\n    ])\n\n    // src trees:\n    this.addIgnorableSubdirs(\"src\", [\"main\", \"test\"]) // < maven\n    this.addIgnorableSubdirs(\"examples\", [\"bin\", \"conf\", \"src\"]) // docs\n    this.addIgnorableSubdirs(\"docs\", [\n      \"admin\",\n      \"content\",\n      \"general\",\n      \"generated\",\n      \"sql\"\n    ]) // docs\n    this.addIgnorableSubdirs(\"pkg\", [\n      \"acceptance\",\n      \"ccl\",\n      \"cli\",\n      \"cmd\",\n      \"server\",\n      \"sql\",\n      \"storage\",\n      \"ui\",\n      \"util\",\n      \"workload\"\n    ]) // cockroach\n\n    this.addIgnorableSubdirs(\"osv\", [\n      \"apps\",\n      \"arch\",\n      \"compiler\",\n      \"external\",\n      \"include\",\n      \"java\",\n      \"modules\",\n      \"musl\",\n      \"tests\"\n    ])\n\n    // Go installation has some ignorables:\n    this.addIgnorableSubdirs(\"go\", [\n      \"bin\",\n      \"blog\",\n      \"cmd\",\n      \"doc\",\n      \"lib\",\n      \"misc\",\n      \"pkg\",\n      \"src\",\n      \"test\",\n      \"vt\"\n    ])\n\n    // Perl\n    const perlDirs = [\"bin\", \"eg\", \"etc\", \"html\", \"lib\", \"site\"]\n\n    this.addIgnorableSubdirs(\"Perl\", perlDirs)\n    this.addIgnorableSubdirs(\"Perl64\", perlDirs)\n\n    // Android SDK:\n    this.addIgnorableSubdirs(\"sdk\", [\n      \"build-tools\",\n      \"emulator\",\n      \"extras\",\n      \"patcher\",\n      \"platforms\",\n      \"platform-tools\",\n      \"sources\",\n      \"tools\"\n    ])\n\n    // Seems safe? If you've got any transifex source, this is a huge chunk:\n    this.addIgnorableSubdirs(\"i18n\", [\n      \"chs\",\n      \"cht\",\n      \"deu\",\n      \"esn\",\n      \"fra\",\n      \"hun\",\n      \"ita\",\n      \"jpn\",\n      \"kor\",\n      \"ptb\",\n      \"rus\",\n      \"trk\"\n    ])\n\n    this.addIgnorableSubdirs(\"test\", [\"fixtures\"]) // no one will put their precious photos in \".../test/fixtures/...\". RIGHT?\n    this.addIgnorableSubdirs(\"data\", [\"$of\"]) // windows 7-10 backup directories\n    this.addIgnorableSubdirs(\"system\", [\"library\"]) // mac os system disk\n    this.addIgnorableSubdirs(\"contents\", [\n      \"frameworks\",\n      \"plugins\",\n      \"resources\",\n      \"sharedsupport\"\n    ]) // mac os app\n    this.addIgnorableSubdirs(\"pg\", [\"pgsql\"]) // PostgreSQL src\n\n    // Windows application data:\n    if (!testing) {\n      this.addIgnorableSubdirs(\"appdata\", [\"local\", \"locallow\", \"roaming\"])\n      this.addIgnorableSubdirs(getEnv(\"APPDATA\")!, [\n        \"local\",\n        \"locallow\",\n        \"roaming\"\n      ])\n    }\n\n    if (testing) {\n      // We want to be able to import example pictures directories that are from mktmpdir:\n      this.ignorableDirectories.delete(\"tmp\")\n      this.ignorableRootDirectories.delete(\"tmp\")\n      this.ignorableDirectories.delete(\"temp\")\n      this.ignorableRootDirectories.delete(\"temp\")\n      // gitlab on speedy:\n      this.ignorableRootDirectories.delete(\"var\")\n      this.ignorableSubdirs.delete(\"var\", \"lib\")\n      if (isWin) {\n        this.ignorableSubdirs.delete(\"cygwin64\", \"tmp\")\n      }\n    }\n  }\n\n  ignorablePathPredicates(nativePath: string): Predicates {\n    const neverIgnored = pathIsNeverIgnoredPredicate(nativePath)\n    if (neverIgnored != null) return neverIgnored\n\n    const lc = nativePath.toLowerCase().normalize()\n    const paths = compactBlanks(pathnames(lc))\n    return {\n      hiddenPosix: () => paths.some(ea => ea.startsWith(\".\")),\n      systemDir: () => this.systemDirs.some(ea => lc.startsWith(ea)),\n      ignorableRoot: () => this.ignorableRootDirectories.has(paths[0]),\n      ignorableDirectory: () =>\n        paths.some(ea => this.ignorableDirectories.has(ea)),\n      ignorablePath: () => this.ignorableSubdirs.has(paths),\n      ignorablePattern: () => {\n        const posixPath = native2posix(nativePath)\n        return this.ignorableDirectoryPatterns.some(ea => ea.test(posixPath))\n      }\n    }\n  }\n\n  ignorablePath(nativePath: string): boolean {\n    return orLogged(\n      [this.ignorablePathPredicates(nativePath)],\n      nativePath,\n      mkLogger(\"ignorablePath()\")\n    )\n  }\n}\n\nconst instance = lazy(() => new Ignorable())\n\nexport function ignorablePathPredicates(nativePath: string): AsyncPredicates {\n  return {\n    ...instance().ignorablePathPredicates(nativePath),\n    notExists: () => PosixFile.for(nativePath).notExists()\n  }\n}\n\nexport function ignorablePath(nativePath: string): boolean {\n  return instance().ignorablePath(nativePath)\n}\n\nexport function ignorableFile(file: SimpleFile): boolean {\n  return ignorablePath(file.nativePath)\n}\n\n/**\n * @return if accept is non-empty, the directory is ignorable.\n */\nexport function ignorableDirectoryPredicates(\n  file: SimpleFile\n): AsyncPredicates {\n  const lc = file.nativePath.toLowerCase().normalize()\n  if (pathIsNeverIgnored(file.nativePath) || pathIsNeverIgnored(lc)) {\n    return {\n      pathIsNeverIgnored: () => false\n    }\n  }\n  return {\n    ...ignorablePathPredicates(file.nativePath),\n    snapDirectory: async () => isLinux && (await ignorableSnapDir.apply(file)),\n    // hasNoMedia returns a PromiseMaybe:\n    noMedia: async () => true === (await hasNoMedia(file)),\n    hidden: () => hidden(file),\n    seemsRecursive: () => seemsRecursive(file.pathnames),\n    mountpoint: async () =>\n      thenMapOr(\n        mountpoints(),\n        arr => arr.includes(file.nativePath),\n        () => false\n      )\n  }\n}\n\nexport async function ignorablePredicates(\n  file: SimpleFile\n): Promise<AsyncPredicates> {\n  return (await file.isDirectory())\n    ? ignorableDirectoryPredicates(file)\n    : ignorablePathPredicates(file.nativePath)\n}\n\nexport async function ignorableDirectory(file: SimpleFile): Promise<boolean> {\n  return orLoggedAsync(\n    [ignorableDirectoryPredicates(file)],\n    file.nativePath,\n    mkLogger(\"ignorableDirectory()\")\n  )\n}\n", "import { mapNotBlank } from \"../../fe/Blank\"\nimport { Maybe } from \"../../fe/MaybeTypes\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { version } from \"../Version\"\nimport { Settings } from \"./Settings\"\n\nconst README = `\nHello, and thank you for using PhotoStructure!\n\nThe files in this folder support your PhotoStructure Library, including\n\n  * a database with the filepaths to your photos and movies\n  * previews and thumbnails of your photos and movies\n  * content metadata about these assets, like ratings and sharing information\n  * albums that both you and PhotoStructure Curators have assembled\n\nMoving or deleting any files here will cause problems using your library.\n\nIf you have any questions, please visit <https://photostructure.com/support/>.\n\nSincerely,\n\nYour Friendly Neighborhood PhotoStructure, v${version}`\n\n/**\n * libraryDataDir was pulled out of Library so settings could be written into\n * .photostructure, rather than directly into the library root.\n */\nexport function libraryDataDir(\n  libraryRootPath: Maybe<string | PosixFile> = Settings.libraryPath.value\n): Maybe<PosixFile> {\n  return mapNotBlank(libraryRootPath, ea =>\n    // subdir is all lowercase to minimize case-(in)sensitive\n    // filesystem pain and suffering\n    PosixFile.for(ea).join(\".photostructure\")\n  )\n}\n\nexport function libraryOriginalsDir(\n  libraryRootPath: Maybe<string | PosixFile> = Settings.libraryPath.value\n): Maybe<PosixFile> {\n  return mapNotBlank(libraryRootPath, ea =>\n    PosixFile.for(ea).join(Settings.originalsDir.valueOrDefault)\n  )\n}\n\nexport function setupLibraryOriginalsDir(\n  libraryRootPath: Maybe<string | PosixFile> = Settings.libraryPath.value\n) {\n  return libraryOriginalsDir(libraryRootPath)?.mkdirp()\n}\n\nexport function libraryPreviewsDir(\n  libraryRootPath: Maybe<string | PosixFile> = Settings.libraryPath.value\n): Maybe<PosixFile> {\n  return mapNotBlank(libraryRootPath, ea =>\n    PosixFile.for(ea).join(Settings.previewsDir.valueOrDefault)\n  )\n}\n\n/**\n * @throws if there are issues\n */\nexport async function setupLibraryDataDir(\n  libraryRootPath: string | PosixFile\n): Promise<PosixFile> {\n  const dataDir = libraryDataDir(libraryRootPath)\n  if (dataDir == null) {\n    throw new Error(\"empty dataDir\")\n  }\n  if (null == (await dataDir.mkdirp())) {\n    throw new Error(\"Could not mkdirp \" + dataDir)\n  }\n  await dataDir.mkNoMedia()\n  const readmeFile = dataDir.join(\"README.txt\")\n  if ((await readmeFile.size()) !== README.length) {\n    await readmeFile.writeTxt_(README)\n  }\n  return dataDir\n}\n", "import toml from \"@iarna/toml\"\nimport { compact, flatten, isNotEmpty, mapNotEmpty, sort } from \"../../fe/Array\"\nimport { firstNotBlank, mapNotBlank } from \"../../fe/Blank\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { later } from \"../../fe/Delay\"\nimport { errorToVerbose } from \"../../fe/Error\"\nimport { stringify } from \"../../fe/JSON\"\nimport { lazy } from \"../../fe/Lazy\"\nimport { map, orElse } from \"../../fe/Maybe\"\nimport { Maybe, PromiseMaybe } from \"../../fe/MaybeTypes\"\nimport { entries, pick, values } from \"../../fe/Object\"\nimport { toS } from \"../../fe/toS\"\nimport { first } from \"../Array\"\nimport { thenMap, thenNot, thenOrElse } from \"../async/Promise\"\nimport { eqlAsync } from \"../Eql\"\nimport {\n  emitClearCache,\n  emitSettingsChanged,\n  onClearCache\n} from \"../event/EventEmitter\"\nimport { BaseFile } from \"../fs/BaseFile\"\nimport { splitLines } from \"../fs/CRLF\"\nimport { PosixFile } from \"../fs/PosixFile\"\nimport { mkLogger } from \"../Logger\"\nimport { Pojo } from \"../Object\"\nimport { baseVersion } from \"../PhotoStructureVersion\"\nimport { picturesDir } from \"../PicturesDir\"\nimport { capitalize, dumbquote, padding, wrap } from \"../String\"\nimport { camel2snake } from \"../StringCase\"\nimport { userData } from \"../UserData\"\nimport { version } from \"../Version\"\nimport { ShortCmdTimeoutMs } from \"../volumes/VolumeTtls\"\nimport { libraryDataDir, setupLibraryDataDir } from \"./LibraryDirs\"\nimport { LibraryCategories, Setting, SystemCategories } from \"./Setting\"\nimport {\n  persistedLibrarySettings,\n  persistedSystemSettings,\n  Settings\n} from \"./Settings\"\n\nconst logger = mkLogger(\"SettingsIO\")\n\nconst Filename = \"settings.toml\"\n\nexport function systemSettingsFile() {\n  return PosixFile.for(userData()).join(Filename)\n}\n\nexport function librarySettingsFile(libraryPath?: Maybe<string>) {\n  return first([libraryPath, Settings.libraryPath.value], lp =>\n    mapNotBlank(lp, ea => map(libraryDataDir(ea), f => f.join(Filename)))\n  )\n}\n\nasync function migrateScanMyPictures() {\n  if (isTrue(Settings.scanMyPictures.value)) {\n    Settings.scanMyPictures.value = false\n    Settings.scanPaths.push(await picturesDir())\n  }\n}\n\n// Called by Service.setup:\nexport async function readSystemSettings(\n  settingsFile: BaseFile = systemSettingsFile()\n) {\n  const settings = await thenOrElse(importFileSettings(settingsFile), () => [])\n  await migrateScanMyPictures()\n  libraryHasSettings.unset()\n  return settings\n}\n\nexport async function envOrSavedLibraryPath() {\n  return Settings.libraryPath.value ?? savedLibraryPath()\n}\n\nexport function savedLibraryPath(): PromiseMaybe<string> {\n  return thenMap(\n    read(systemSettingsFile()),\n    ea => ea[Settings.libraryPath.name] as string\n  )\n}\n\nexport async function systemSettingsVersion(): PromiseMaybe<string> {\n  return readSettingsVersion(systemSettingsFile())\n}\n\nexport async function librarySettingsVersion(\n  libraryPath?: Maybe<string>\n): PromiseMaybe<string> {\n  return map(librarySettingsFile(libraryPath), ea => readSettingsVersion(ea))\n}\n\nexport const libraryHasSettings = lazy(\n  () => _libraryHasSettings(),\n  ShortCmdTimeoutMs\n)\nlater(() => {\n  onClearCache(() => libraryHasSettings.unset())\n  Settings.libraryPath.addListener(() => libraryHasSettings.unset())\n})\n\n// This needs to be sync for WebService and MenuItems:\nexport function _libraryHasSettings(libraryPath?: string): boolean {\n  const lsf = librarySettingsFile(libraryPath)\n  return logger.tap({\n    msg: \"_libraryHasSettings\",\n    result: orElse(lsf?.clear().existsSync(), false),\n    level: \"info\",\n    meta: {\n      libraryPath,\n      settings: Settings.libraryPath.value,\n      librarySettingsFile: lsf?.nativePath\n    }\n  })\n}\n\nconst versionRegExp = /^# PhotoStructure v(\\d+\\.\\d+\\.\\d+(?:-\\S+)?)$/i\n\nasync function readSettingsVersion(file: BaseFile): PromiseMaybe<string> {\n  return thenMap(file.firstMatchingLine(versionRegExp), m => m[1])\n}\n\nconst wrapComments = { maxLineLen: 78, prefix: \"# \" }\n\nasync function maybeWriteToml(file: BaseFile, settings: Setting<any>[]) {\n  const wip = await file.clear().isNonEmpty()\n  const dest = wip ? await file.wip() : file\n  await writeToml(dest, settings, file)\n  logger.info(\"maybeWriteFile(): wrote settings\", {\n    dest,\n    file,\n    nonDefaults: settings\n      .filter(ea => ea.hasValue())\n      .map(ea => ({\n        name: ea.name,\n        value: ea.value\n      }))\n  })\n\n  if (wip) {\n    if (await thenNot(eqlAsync(read(dest), read(file)))) {\n      logger.info(\"Archiving prior, different contents\", { dest, file })\n      await file.renameYMDHMS_(\"old\")\n    }\n    await dest.unwip_()\n  }\n}\n\n/**\n * Used by SettingIO.spec (to let the persisted system and library versions be\n * consistent)\n */\nexport const versionForSettings = lazy(() => version)\n\nasync function writeToml(\n  file: BaseFile,\n  settings: Setting<any>[],\n  src: BaseFile\n): Promise<void> {\n  const priorValues = orElse(await read(src), {})\n  const lines = flatten(\n    [\n      \"\",\n      \"Hello!\",\n      \"\",\n      `These are ${settings[0].categoryType} settings for PhotoStructure.`,\n      \"\",\n      \" - Please shut down PhotoStructure before editing this file.\",\n      \"\",\n      \" - PhotoStructure has TWO settings files!\",\n      \"\",\n      \" - Most settings have reasonable defaults, which are provided after the\",\n      `   description. Remove the \"#\" from the beginning of the line to override`,\n      \"   the default.\",\n      \"\",\n      \" - See <https://photostructure.com/getting-started/advanced-settings/>\",\n      \"   for more details\",\n      \"\",\n      \"Thanks for using PhotoStructure! Visit <https://photostructure.com/support> or email <support@photostructure.com> if you find any bugs or have any questions, ideas, or feedback. We'd love to hear from you.\",\n      \"\",\n      \"-- \",\n      \"\",\n      // DON'T EDIT THIS! WE USE IT TO CHECK THE VERSION! See `versionRegExp`\n      \"PhotoStructure v\" + versionForSettings()\n    ].map(s => wrap(s, wrapComments))\n  )\n\n  lines.push(\"\", \"\")\n\n  let priorCat = \"\"\n  settings.forEach(setting => {\n    const cat = `${capitalize(\n      setting.categoryType\n    )}.${setting.category.toLowerCase()}`\n\n    if (cat !== priorCat) {\n      priorCat = cat\n      lines.push(\n        \"\",\n        padding(\"#\", 78),\n        \"#\",\n        \"# Settings for \" + cat + \":\",\n        \"#\",\n        \"\",\n        \"\"\n      )\n    }\n\n    const border = \"# +\" + padding(\"-\", setting.name.length + 4) + \"+\"\n\n    const extra = entries({\n      env: setting.key,\n      ...mapNotEmpty(setting.opts.envAliases, ea => ({\n        \"env aliases\": ea\n      })),\n      ...setting.addToJSON()\n    })\n      .map(([k, v]) => `${k}: ${stringify(v)}`)\n      .join(\", \")\n\n    lines.push(\n      ...wrap(\n        [\n          border,\n          \"|  \" + setting.name + \"  |\",\n          border,\n          \"\",\n          `${setting.opts.description.replace(/\\n/g, \"\\n\\n\")}`,\n          `(${extra})`,\n          \"\"\n        ].join(\"\\n\"),\n        wrapComments\n      )\n    )\n\n    const prior = priorValues[setting.name]\n    const o = {}\n    const v = setting.valueToPersist(prior)\n    if (v != null) {\n      o[setting.name] = v\n      lines.push(...stringifyToml(o))\n    } else {\n      o[setting.name] = setting.exampleValue\n      lines.push(...stringifyToml(o).map(ea => \"# \" + ea))\n    }\n    lines.push(\"\", \"\")\n  })\n\n  await file.writeTxt_(\n    \"\\n\" + lines.map(ea => ea.trimRight()).join(\"\\n\") + \"\\n\\n\"\n  )\n  emitSettingsChanged()\n}\n\nexport function stringifyToml(obj: Pojo) {\n  return splitLines(\n    ...entries(obj).map(\n      ([k, v]) =>\n        // We add 2 spaces here to make long array values wrap:\n        k + \" = \" + stringify(v, undefined, 2)\n    )\n  )\n}\n\nexport async function writeSystemSettings(\n  dest: BaseFile = systemSettingsFile()\n) {\n  return maybeWriteToml(dest, persistedSystemSettings())\n}\n\nexport async function readLibrarySettings(libraryPath?: string) {\n  return map(librarySettingsFile(libraryPath), ea => importFileSettings(ea))\n}\n\n/**\n * @throws if there are errors\n */\nexport async function writeLibrarySettings(libraryPath?: string) {\n  await setupLibraryDataDir(\n    firstNotBlank(libraryPath, Settings.libraryPath.value)!\n  )\n  const file = librarySettingsFile(libraryPath)\n  logger.warn(\"writeLibrarySettings(\" + file + \")\")\n  await map(file, f => maybeWriteToml(f, persistedLibrarySettings()))\n  libraryHasSettings.unset()\n  return file\n}\n\nasync function read(file: BaseFile): PromiseMaybe<toml.JsonMap> {\n  return thenMap(file.readFile(), buf =>\n    logger.tap({\n      msg: `read(${file})`,\n      result: toml.parse(dumbquote(buf.toString()))\n    })\n  )\n}\n\nasync function importFileSettings(f: BaseFile): PromiseMaybe<Setting<any>[]> {\n  const log = mkLogger(\"SettingsIO.importFileSettings(\" + f.nativePath + \")\")\n  try {\n    const tomlMap = await read(f)\n    if (tomlMap == null) {\n      if (await f.isNonEmpty()) throw new Error(\"Failed to read \" + f)\n      else return []\n    }\n    const settings = new Map<string, Setting<any>>(\n      entries(Settings)\n        .filter(([, v]) => v instanceof Setting && !v.transient)\n        .map(([k, v]) => [k.toLowerCase(), v])\n    )\n    const imported = compact(\n      entries(tomlMap).map(([key, value]) => {\n        const s = settings.get(toS(key).toLowerCase())\n        if (s == null) {\n          log.warn(\"Failed to import (no setting with this name)\", {\n            key\n          })\n        } else {\n          s.importFromFile(value)\n        }\n        return s\n      })\n    )\n    log.info(\"loaded\", {\n      tomlMap,\n      imported: imported.map(s => pick(s, \"name\", \"value\", \"persist\"))\n    })\n    return imported\n  } catch (err) {\n    log.error(\"Cannot read\" + errorToVerbose(err))\n    return\n  }\n}\n\nconst UnclearableSettings = lazy(\n  () =>\n    new Set(\n      [\n        Settings.logLevel,\n        Settings.httpPort,\n        Settings.rpcPort,\n        Settings.license\n      ].map(ea => ea.key)\n    )\n)\n\n/**\n * Force all in-memory settings to default values.\n */\nexport function clearSettings() {\n  values(Settings)\n    // don't reset LOG, NODE_ENV, or random ports!\n    .filter(ea => !UnclearableSettings().has(ea.key))\n    .forEach(ea => ea.unset())\n  emitClearCache()\n  emitSettingsChanged()\n}\n\n/**\n * Force all in-memory Settings to default values, and delete both system and\n * library settings.\n *\n * Probably only useful for tests.\n */\nexport async function nukeSettings() {\n  await systemSettingsFile().unlink(\"debug\")\n  await map(librarySettingsFile(), ea => ea.unlink(\"debug\"))\n  clearSettings()\n  return\n}\n\nexport async function writeEnv(\n  file: BaseFile,\n  settings: Setting<any>[]\n): Promise<void> {\n  const lines = flatten(\n    [\n      \"\",\n      `Welcome to PhotoStructure! These are the settings for version ${baseVersion()}.`,\n      \"\",\n      \"Please see <https://photostructure.com/environment-variables> for more information about using environment variables with PhotoStructure.\",\n      \"\",\n      `PLEASE NOTE: PhotoStructure does not read the contents of this \"defaults.env\" (or any \".env\" variant).`,\n      \"\",\n      `The following settings categories are stored in the system settings.toml:`,\n      \"\",\n      ...sort([...SystemCategories]).map(ea => \"* System.\" + ea),\n      \"\",\n      `The following settings categories are stored in the library settings.toml:`,\n      \"\",\n      ...sort([...LibraryCategories]).map(ea => \"* Library.\" + ea),\n      \"\",\n      \"Please visit <https://forum.photostructure.com> if you find anything that may be a bug or have any questions, ideas, or feedback. We'd love to hear from you!\",\n      \"\"\n    ].map(s => wrap(s, wrapComments))\n  )\n\n  lines.push(\"\", \"\")\n\n  let priorCat = \"\"\n  settings.forEach(setting => {\n    const cat = `${capitalize(\n      setting.categoryType\n    )}.${setting.category.toLowerCase()}`\n\n    if (cat !== priorCat) {\n      priorCat = cat\n      lines.push(\n        \"\",\n        padding(\"#\", 78),\n        \"#\",\n        \"# Settings for \" + cat + \":\",\n        \"#\",\n        \"\",\n        \"\"\n      )\n    }\n\n    const name = setting.name\n    const border = \"# +\" + padding(\"-\", name.length + 4) + \"+\"\n\n    const extra: any = { ...setting.addToJSON() }\n    mapNotEmpty(setting.opts.envAliases, aliases => (extra.aliases = aliases))\n\n    const extraLines = entries(extra).map(\n      ([k, v]) => `${capitalize(camel2snake(k)).replace(/_/g, \" \")}: ${v}`\n    )\n\n    if (isNotEmpty(extraLines)) extraLines.push(\"\")\n\n    lines.push(\n      ...wrap(\n        [\n          // `Category: ${capitalize(setting.categoryType)}.${setting.category}`,\n          // \"\",\n          border,\n          `|  ${name}  |`,\n          border,\n          \"\",\n          setting.opts.description.replace(/\\n/g, \"\\n\\n\"),\n          \"\",\n          ...extraLines\n        ].join(\"\\n\"),\n        wrapComments\n      )\n    )\n\n    lines.push(`# ${setting.key}=${stringify(toS(setting.envValueOrDefault))}`)\n    lines.push(\"\", \"\")\n  })\n\n  await file.writeTxt_(lines.map(ea => ea.trimRight()).join(\"\\n\"))\n}\n", "import p from \"process\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { blank } from \"../../fe/Blank\"\n\nexport interface DaemonOptions {\n  daemon?: boolean\n  pidfile?: string\n  stop?: boolean\n}\n\nexport function isDaemon(opts?: DaemonOptions) {\n  return (\n    isTrue(p.env.__is_daemon) || isTrue(opts?.daemon) || !blank(opts?.pidfile)\n  )\n}\n", "import { Command } from \"commander\"\nimport { isTrue } from \"../../fe/Boolean\"\nimport { Pojo } from \"../../core/Object\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { map } from \"../../fe/Maybe\"\nimport { isDaemon } from \"./IsDaemon\"\n\n/**\n * Used by logcat and logtail\n */\nexport const LogArgs = {\n  beforeParse: (cmd: Command, skipInfoVerbose = false) => {\n    cmd.option(\n      \"--warn\",\n      `Emit \"warn\" and \"error\" messages from this process to stdout. Sets PS_LOG_LEVEL to \"warn\" and PS_LOG_STDOUT to true. Ignored if daemonized.`\n    )\n    if (!skipInfoVerbose) {\n      cmd.option(\n        \"--info|--verbose\",\n        `Emit \"info\", \"warn\", and \"error\" messages from this process to stdout. Sets PS_LOG_LEVEL to \"info\" and PS_LOG_STDOUT to true. Ignored if daemonized.`\n      )\n    }\n    cmd\n      .option(\n        \"--debug\",\n        `Emit \"debug\", \"info\", \"warn\", and \"error\" messages from this process to stdout. CAUTION: VERY NOISY. Sets PS_LOG_LEVEL to \"debug\" and PS_LOG_STDOUT to true. When run from the main service, all other process logs will also be emitted. Ignored if daemonized.`\n      )\n      .option(\"--color\", \"Enable ASCII terminal colors\", true)\n      .option(\"--no-color\", \"Disable ASCII terminal colors\")\n\n    return cmd\n  },\n  afterParse: (opts: Pojo) => {\n    map(opts.color, ea => (Settings.logColor.tmpValue = ea))\n\n    const warn = isTrue(opts.warn)\n    const info = isTrue(opts.info) || isTrue(opts.verbose)\n    const debug = isTrue(opts.debug)\n\n    if (warn) Settings.logLevel.tmpValue = \"warn\"\n    if (info) Settings.logLevel.tmpValue = \"info\"\n    if (debug) Settings.logLevel.tmpValue = \"debug\"\n\n    if (!isDaemon(opts) && (warn || info || debug)) {\n      Settings.logStdout.tmpValue = true\n    }\n  }\n}\n", "import { Command } from \"commander\"\nimport { CommandPlugin } from \"../../core/cli/CLI\"\nimport { isDaemon } from \"../../core/cli/IsDaemon\"\nimport { LogArgs } from \"../../core/cli/LogArgs\"\nimport { Pojo } from \"../../core/Object\"\nimport { Settings } from \"../../core/settings/Settings\"\nimport { isTrue } from \"../../fe/Boolean\"\n\n/**\n * Used by all services that log (which should be everything except logtail)\n */\nexport const CommonArgs: CommandPlugin = {\n  beforeParse: (cmd: Command) => {\n    const skipInfoVerbose = true\n    cmd\n      .option(\n        \"--info\",\n        `Emit \"info\", \"warn\", and \"error\" messages from this process to stdout. Sets PS_LOG_LEVEL to \"info\" and PS_LOG_STDOUT to true. Ignored if daemonized.`\n      )\n      .option(\n        \"--verbose\",\n        `Verbose logging from all processes. Shortcut for \"--info --tail\". Caution: noisy during imports!`\n      )\n      .option(\n        \"--tail\",\n        `Emit log messages from both this process and all other concurrently running PhotoStructure processes on this host to stdout. This can be really helpful in seeing how PhotoStructure's processes are coordinating work. Caution: very noisy especially during imports. Sets PS_TAIL_LOGS to true. Ignored if daemonized.`\n      )\n\n    LogArgs.beforeParse(cmd, skipInfoVerbose)\n\n    cmd.option(\n      \"--force-open,--forceOpen\",\n      `DANGEROUS: removes all previously-existing library locks. This should only be necessary if the prior PhotoStructure process was not shut down gracefully.`\n    )\n\n    return cmd\n  },\n  // This makes logtail sorting not work correctly:\n  // .option(\n  //   \"--elapsed\",\n  //   `Prefix log entries with elapsed time since process start, rather than absolute time. Sets PS_LOG_ELAPSED_MS to \"true\"`\n  // )\n\n  afterParse: (opts: Pojo) => {\n    LogArgs.afterParse(opts)\n\n    if (isTrue(opts.elapsed)) {\n      Settings.logElapsedMs.tmpValue = opts.elapsed\n    }\n    if (isDaemon(opts as any)) {\n      // don't log to stdout if we're a daemon:\n      Settings.logStdout.tmpValue = false\n      Settings.tailLogs.tmpValue = false\n    } else {\n      const verbose = isTrue(opts.verbose)\n      if (verbose && Settings.logLevel.isUnset()) {\n        Settings.logLevel.tmpValue = \"info\"\n      }\n\n      if (isTrue(opts.tail) || verbose) {\n        Settings.tailLogs.tmpValue = true\n      }\n\n      if (isTrue(opts.forceOpen)) {\n        Settings.forceOpen.tmpValue = true\n      }\n    }\n  }\n}\n", "import { BaseFile } from \"../../core/fs/BaseFile\"\nimport { Schema } from \"./Schema\"\n\nexport const SqliteExt = \".sqlite3\"\n\nexport function pathToDb<T extends BaseFile>(dataDir: T, schema: Schema): T {\n  return dataDir.join(schema, \"db\" + SqliteExt)\n}\n"],
  "mappings": "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MACA,OAGF,KAAK,oBAAoB,MAAO,GAChC,KAAK,oBAAoB,SAAU,GACnC,KAAK,oBAAoB,WAAY,GACrC,KAAK,oBAAoB,QAAS,GAGlC,KAAK,oBAAoB,UAAW,CAClC,OACA,aACA,UACA,QACA,OACA,YACA,OACA,gBACA,uBACA,SACA,WACA,WACA,SAGF,KAAK,oBAAoB,MAAO,CAC9B,WACA,UACA,UACA,OACA,qBAEF,KAAK,oBAAoB,MAAO,CAAC,SAAU,MAAO,GAAG,IAGrD,KAAK,oBAAoB,MAAO,CAAC,YAGjC,KAAK,oBAAoB,MAAO,CAC9B,QACA,QACA,QACA,MACA,QACA,OACA,MACA,OACA,MACA,OACA,QACA,QAIF,KAAK,oBAAoB,MAAO,CAC9B,QACA,MACA,MACA,OACA,MACA,OACA,MACA,KACA,YACA,QACA,WACA,SACA,SACA,MACA,MACA,MACA,MACA,YACA,MACA,SAEF,KAAK,oBAAoB,OAAQ,CAC/B,OACA,SACA,MACA,SACA,KACA,OACA,MACA,MACA,OACA,OACA,MACA,UACA,cACA,QAIF,KAAK,oBAAoB,UAAW,CAClC,sBACA,QACA,UACA,SACA,eACA,YACA,aACA,eACA,wBACA,gBACA,cACA,mBACA,YACA,eACA,oBACA,gBACA,aACA,cACA,QACA,aACA,aACA,WACA,gBACA,gBACA,oBACA,SACA,OACA,mBACA,YACA,eACA,gBACA,OACA,WACA,gBACA,gBACA,gBACA,eACA,OACA,kBACA,cACA,WACA,wBACA,SACA,YACA,YACA,WACA,OACA,UACA,gBACA,qBACA,UACA,WACA,SACA,YACA,mBACA,eACA,iBACA,UACA,gBACA,QACA,YACA,YAIF,KAAK,oBAAoB,MAAO,CAAC,OAAQ,SACzC,KAAK,oBAAoB,WAAY,CAAC,MAAO,OAAQ,QACrD,KAAK,oBAAoB,OAAQ,CAC/B,QACA,UACA,UACA,YACA,QAEF,KAAK,oBAAoB,MAAO,CAC9B,aACA,MACA,MACA,MACA,SACA,MACA,UACA,KACA,OACA,aAGF,KAAK,oBAAoB,MAAO,CAC9B,OACA,OACA,WACA,WACA,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",
  "names": []
}
