{
  "version": 3,
  "sources": ["../../../photostructure.ts", "../../../../core/cli/CliConstants.ts", "../../../../fe/toS.ts", "../../../../fe/ObjectType.ts", "../../../../fe/Opt.ts", "../../../../fe/Number.ts", "../../../../fe/Array.ts", "../../../../fe/String.ts", "../../../../core/Version.ts"],
  "sourcesContent": ["import { Command, program } from \"commander\"\nimport { argv } from \"process\"\nimport { addFooter, CliDesc } from \"../core/cli/CliConstants\"\nimport { version } from \"../core/Version\"\n\nprogram.version(version)\n\nprogram.description(\n  `Welcome to PhotoStructure, your new home for all your photos and videos.`\n)\n\naddFooter(program as Command)\n  .command(\"main\", CliDesc.main + \" (default)\", {\n    isDefault: true,\n    executableFile: \"bin/main.js\"\n  })\n  .command(\"info\", CliDesc.info, {\n    executableFile: \"bin/info.js\"\n  })\n  .command(\"list\", CliDesc.list, {\n    executableFile: \"bin/list.js\"\n  })\n  .command(\"logcat\", CliDesc.logcat, {\n    executableFile: \"bin/logcat.js\"\n  })\n  .command(\"logtail\", CliDesc.logtail, {\n    executableFile: \"bin/logtail.js\"\n  })\n  .command(\"web\", CliDesc.web, {\n    executableFile: \"bin/web.js\"\n  })\n  .command(\"sync\", CliDesc.sync, {\n    executableFile: \"bin/sync.js\"\n  })\n  .command(\"sync-file\", CliDesc[\"sync-file\"], {\n    executableFile: \"bin/sync-file.js\"\n  })\n  .parse(argv)\n", "import { Command } from \"commander\"\nimport { stdout } from \"process\"\nimport { wrap } from \"../../fe/String\"\n\nconst year = new Date().getFullYear()\n\nexport const descriptionFooter = `Please visit <https://photostructure.com/support/> for detailed usage and configuration instructions.\n\nCopyright \u00A9 2017-${year}, PhotoStructure Inc.\n\nRunning this software indicates your agreement to all the terms of this license: <https://photostructure.com/eula/>`\n\nexport const CliDesc = {\n  main:\n    \"PhotoStructure's main process manager. Runs and manages web and sync services.\",\n  info: \"Configuration, file metadata and import diagnostics tool. \",\n  list: \"List all paths in a Library.\",\n  logcat: \"Chronologically sort and pretty-print PhotoStructure logfiles.\",\n  logtail:\n    \"View the log messages of currently-running PhotoStructure processes. (Like `tail -f`).\",\n  web: \"PhotoStructure's web service. Automatically started by main.\",\n  sync:\n    \"PhotoStructure's directory synchronization service. Automatically started by main.\",\n  \"sync-file\":\n    \"PhotoStructure's file synchronization service. Automatically started by sync.\"\n}\n\nexport function addFooter(c: Command): Command {\n  return c.on(\"--help\", () => {\n    console.log(\n      \"\\n\" +\n        wrap(descriptionFooter, {\n          maxLineLen: stdout.columns ?? 78,\n          prefix: \"\"\n        }).join(\"\\n\") +\n        \"\\n\"\n    )\n  })\n}\n", "/**\n * Similar to `String(a)`, but `undefined` and `null` render as \"\", arrays are\n * comma-separated with no square bracket prefix/suffix\n */\nexport function toS(a?: any | any[]): string {\n  // PERF: unrolled\n  return a == null\n    ? \"\"\n    : typeof a === \"string\"\n    ? a\n    : Array.isArray(a)\n    ? a.map(toS).join(\",\")\n    : a.toString()\n}\n", "import { isIterable } from \"./Iterable\"\nimport { Defined } from \"./Maybe\"\nimport { isPrimitive } from \"./Primitive\"\n\n// eslint-disable-next-line no-shadow\nexport enum ObjectType {\n  Empty,\n  Primitive,\n  Symbol,\n  Object,\n  Array,\n  Iterable,\n  Instance,\n  Function,\n  Unknown\n}\n\nexport function isSymbol(obj: any): obj is symbol {\n  return typeof obj === \"symbol\"\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(obj: any): obj is Function {\n  return typeof obj === \"function\"\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isObject(obj: any): obj is Defined<any> {\n  return objectType(obj) === ObjectType.Object\n}\n\nexport function objectType(t: any): ObjectType {\n  if (t == null) {\n    return ObjectType.Empty\n  } else if (isSymbol(t)) {\n    return ObjectType.Symbol\n  } else if (isPrimitive(t)) {\n    return ObjectType.Primitive\n  } else if (Array.isArray(t)) {\n    return ObjectType.Array\n  } else if (isIterable(t)) {\n    return ObjectType.Iterable\n  } else if (isFunction(t)) {\n    return ObjectType.Function\n  } else if (typeof t === \"object\") {\n    // we're in fe, we can't use ?. TODO FIXME\n    return t.constructor != null && t.constructor.name === \"Object\"\n      ? ObjectType.Object\n      : ObjectType.Instance\n  } else {\n    return ObjectType.Unknown\n  }\n}\n", "import { Maybe, MaybeNull } from \"./MaybeTypes\"\n\n// Scala got a Some things right.\n// HUR HUR I AM HILLLARIOUS\n\n// \"Opt\" instead of \"Option\" due to Option being an html entity already\n\nexport type MaybeOpt<T> = Opt<T> | MaybeNull<T>\n\n/**\n * @see http://www.scala-lang.org/api/current/scala/Option.html\n */\nexport interface Opt<A> {\n  /**\n   * @return true if the option is an instance of Some, false otherwise\n   */\n  isDefined: boolean\n  /**\n   * @return true if the option is None, false otherwise\n   */\n  isEmpty: boolean\n  /**\n   * @return the option's value.\n   */\n  get(): Maybe<A>\n  /**\n   * @return true if this option is nonempty and the predicate `p` returns true\n   * when applied to this Option's value.\n   */\n  exists(p: (a: A) => boolean): boolean\n  /**\n   * @return a `Some` containing the result of applying `f` to this `Option`'s value\n   * if this `Option` is nonempty.\n   */\n  map<B>(f: (a: A) => B): Opt<B>\n  /**\n   * @return the result of applying `f` to this `Option`'s value if this\n   * `Option` is nonempty. By supporting `undefined` or `B`, we make caller's\n   * lives a little easier--we'll wrap the result in an `Option` for you.\n   */\n  flatMap<B>(f: (a: A) => MaybeOpt<B>): Opt<B>\n  /**\n   * @return this `Option` if it is both nonempty\n   * and applying the predicate `p` to this `Option`'s value returns true.\n   */\n  filter(p: (a: A) => boolean): Opt<A>\n  /**\n   * Apply the given procedure `f` to the `Option`'s value\n   * if this `Option` is nonempty.\n   * @return this (for fluent or chaining calls)\n   */\n  forEach(f: (a: A) => void): Opt<A>\n  /**\n   * @return this `Option`'s value if this `Option` is nonempty,\n   * otherwise return the result of evaluating `f`.\n   */\n  getOrElse(f: () => A): A\n  /**\n   * @return this `Option`'s value if this `Option` is nonempty,\n   * otherwise return the result of evaluating `f`.\n   */\n  orElse(f: () => MaybeOpt<A>): Opt<A>\n\n  /**\n   * @param f will only be invoked if both `this` and `b` are defined\n   */\n  zip1<B, T>(b: MaybeOpt<B>, f: (a: A, b: B) => MaybeOpt<T>): Opt<T>\n\n  zip2<B, C, T>(\n    b: MaybeOpt<B>,\n    c: MaybeOpt<C>,\n    f: (a: A, b: B, c: C) => MaybeOpt<T>\n  ): Opt<T>\n\n  zip3<B, C, D, T>(\n    b: MaybeOpt<B>,\n    c: MaybeOpt<C>,\n    d: MaybeOpt<D>,\n    f: (a: A, b: B, c: C, d: D) => MaybeOpt<T>\n  ): Opt<T>\n}\n\nnamespace NoneImpl {\n  export const isDefined = false\n  export const isEmpty = true\n  export const get = () => undefined\n  export const exists = () => false\n  const noop = () => NoneImpl\n  export const map = noop\n  export const flatMap = noop\n  export const filter = noop\n  export const forEach = noop\n  export const getOrElse = <A>(f: () => A): A => f()\n  export const orElse = <A>(f: () => MaybeOpt<A>): Opt<A> => opt(f())\n  export const zip1 = noop\n  export const zip2 = noop\n  export const zip3 = noop\n}\n\nexport const None: Opt<any> = NoneImpl\n\nexport class Some<A> implements Opt<A> {\n  readonly isDefined = true\n  readonly isEmpty = false\n\n  constructor(private readonly a: A) {}\n\n  get(): A {\n    return this.a\n  }\n\n  exists(f: (a: A) => boolean): boolean {\n    return f(this.a)\n  }\n\n  map<B>(f: (a: A) => B): Opt<B> {\n    return new Some(f(this.a))\n  }\n\n  flatMap<B>(f: (a: A) => Opt<B> | MaybeNull<B>): Opt<B> {\n    const b = f(this.a)\n    return isOpt(b) ? b : opt(b)\n  }\n\n  filter(f: (a: A) => boolean): Opt<A> {\n    return opt(f(this.a) ? this.a : undefined)\n  }\n\n  forEach(f: (a: A) => void): this {\n    f(this.a)\n    return this\n  }\n\n  getOrElse(): A {\n    return this.a\n  }\n\n  orElse(): Opt<A> {\n    return this\n  }\n\n  zip1<B, T>(b: MaybeOpt<B>, f: (a: A, b: B) => MaybeOpt<T>): Opt<T> {\n    return opt(b).flatMap(eb => f(this.a, eb))\n  }\n\n  zip2<B, C, T>(\n    b: Opt<B>,\n    c: Opt<C>,\n    f: (a: A, b: B, c: C) => MaybeOpt<T>\n  ): Opt<T> {\n    return opt(b).flatMap(eb => opt(c).flatMap(ec => f(this.a, eb, ec)))\n  }\n\n  zip3<B, C, D, T>(\n    b: MaybeOpt<B>,\n    c: MaybeOpt<C>,\n    d: MaybeOpt<D>,\n    f: (a: A, b: B, c: C, d: D) => MaybeOpt<T>\n  ): Opt<T> {\n    return opt(b).flatMap(eb =>\n      opt(c).flatMap(ec => opt(d).flatMap(ed => f(this.a, eb, ec, ed)))\n    )\n  }\n}\n\nexport function isOpt<A>(a: MaybeOpt<A>): a is Opt<A> {\n  return a instanceof Some || a === None\n}\n\n/**\n * @see http://www.scala-lang.org/api/current/scala/Option.html\n */\nexport function opt<A>(a: MaybeOpt<A>): Opt<A> {\n  return isOpt(a) ? a : a != null ? new Some(a) : None\n}\n", "import { blank } from \"./Blank\"\nimport { orElse } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport { isFunction } from \"./ObjectType\"\nimport { opt } from \"./Opt\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { toS } from \"./toS\"\n\nexport function isNumber(o: any): o is number {\n  return typeof o === \"number\" && !isNaN(o) && isFinite(o)\n}\n\nexport function mapFinite<T>(i: Maybe<number>, f: (ea: number) => T): Maybe<T> {\n  return isNumber(i) ? f(i) : undefined\n}\n\nconst mapPredicate = (f: (lhs: number, rhs: number) => boolean) => (\n  lhs: MaybeNull<number>,\n  rhs: MaybeNull<number>\n) => isNumber(lhs) && isNumber(rhs) && f(lhs, rhs)\n\nexport const lt = mapPredicate((i, j) => i < j)\nexport const lte = mapPredicate((i, j) => i <= j)\nexport const gt = mapPredicate((i, j) => i > j)\nexport const gte = mapPredicate((i, j) => i >= j)\n\nexport function finiteOrElse<T>(i: Maybe<number>, defaultValue: T): number | T {\n  return isNumber(i) ? i : defaultValue\n}\n\nexport function diff(i: Maybe<number>, j: Maybe<number>): Maybe<number> {\n  return isNumber(i) && isNumber(j) ? i - j : undefined\n}\n\nexport function absdiff(i: Maybe<number>, j: Maybe<number>): Maybe<number> {\n  return isNumber(i) && isNumber(j) ? Math.abs(i - j) : undefined\n}\n\nexport function safeDivide(numerator: number, denominator: number): number {\n  return numerator / (denominator === 0 ? 1e-8 : denominator)\n}\n\nexport function approximates(\n  a: MaybeNull<number>,\n  b: MaybeNull<number>,\n  ratioGte: number\n): boolean {\n  return a == null || b == null\n    ? false\n    : a === b\n    ? true\n    : gte(a < b ? safeDivide(a, b) : safeDivide(b, a), ratioGte)\n}\n\nexport function closeTo(\n  expected: MaybeNull<number>,\n  actual: MaybeNull<number>,\n  delta: number\n): boolean {\n  return expected == null || actual == null\n    ? false\n    : Math.abs(expected - actual) < delta\n}\n\nexport function trunc(n: Maybe<number>): Maybe<number> {\n  if (!isNumber(n)) return undefined\n  const i = Math.trunc(n)\n  return i === 0 ? Math.abs(i) : i\n}\n\nexport interface ToNumber {\n  toNumber(): number\n}\n\nexport function isToNumber(v: any): v is ToNumber {\n  return isFunction(v[\"toNumber\"])\n}\n\nfunction toNumber(\n  value: MaybeNull<number | string | ToNumber>,\n  opts: {\n    defaultValue: Maybe<number>\n    nton: (n: number) => number\n    ston: (s: string) => Maybe<number>\n  }\n) {\n  if (blank(value)) return opts.defaultValue\n  if (isNumber(value)) return opts.nton(value)\n  if (isToNumber(value)) return opts.nton(value.toNumber())\n  try {\n    const i = opts.ston(toS(value))\n    return isNumber(i) ? opts.nton(i) : opts.defaultValue\n  } catch {\n    return opts.defaultValue\n  }\n}\n\nexport function toInt(\n  value: MaybeNull<number | string | ToNumber>,\n  opts?: { defaultValue?: number }\n): Maybe<number> {\n  return toNumber(value, {\n    defaultValue: undefined,\n    nton: i => trunc(i)!,\n    ston: parseInt,\n    ...opts\n  })\n}\n\nexport function toFloat(\n  value: MaybeNull<number | string>,\n  opts?: { defaultValue?: number }\n): Maybe<number> {\n  return toNumber(value, {\n    defaultValue: undefined,\n    nton: i => i,\n    ston: parseFloat,\n    ...opts\n  })\n}\n\nexport function toGt0(n: any): Maybe<number> {\n  const i = toInt(n)\n  return i != null && i > 0 ? i : undefined\n}\n\nexport function lt0(n: any): n is number {\n  return isNumber(n) && n < 0\n}\n\nexport function gt0(n: any): n is number {\n  return isNumber(n) && n > 0\n}\n\nexport function gtOrElse(\n  n: Maybe<number>,\n  mustBeGreaterThan: number\n): Maybe<number> {\n  return isNumber(n) && isNumber(mustBeGreaterThan) && n > mustBeGreaterThan\n    ? n\n    : undefined\n}\n\nexport function lte0(n: any): n is number {\n  return isNumber(n) && n <= 0\n}\n\nexport function gte0(n: any): n is number {\n  return isNumber(n) && n >= 0\n}\n\nexport function mapInt<T>(o: any, f: (i: number) => T): Maybe<T> {\n  return opt(o)\n    .flatMap(i => toInt(i))\n    .flatMap(f)\n    .get()\n}\n\nexport function mapFloat<T>(o: any, f: (i: number) => T): Maybe<T> {\n  return opt(o)\n    .flatMap(i => toFloat(i))\n    .flatMap(f)\n    .get()\n}\n\n/**\n * @return a stringified `value` iff `value` is a positive integer\n */\nexport function id(value: Maybe<number | string>): Maybe<string> {\n  const i = toInt(value)\n  return gt0(i) ? String(i) : undefined\n}\n\nexport function mapIntOr<T>(o: any, f: (i: number) => T, orElseF: () => T): T {\n  return orElse(mapInt(o, f), orElseF)\n}\n\nexport function mapNumeric<T>(o: any, f: (i: number) => T): Maybe<T> {\n  return isNumber(o) ? f(o) : undefined\n}\n\nexport function map2Numeric<T>(\n  i: any,\n  j: any,\n  f: (ea1: number, ea2: number) => T\n): Maybe<T> {\n  return mapNumeric(i, ea1 => mapNumeric(j, ea2 => f(ea1, ea2)))\n}\n\nexport function mapNumericOr<T>(\n  o: any,\n  f: (i: number) => T,\n  defaultValue: T\n): T {\n  return isNumber(o) ? f(o) : defaultValue\n}\n\nexport function numericOr(o: any, defaultValue: ThunkOrT<number>): number {\n  return isNumber(o) ? o : tot(defaultValue)\n}\n\nexport function round(i: number): number {\n  // Workaround for bug in javascript (Math.round(-1.5) === -1 (!!)):\n  return i < 0 ? -Math.round(-i) : Math.round(i)\n}\n\nexport function toPrecisionMaybe(\n  i: Maybe<number>,\n  decimalPlaces: number\n): Maybe<number> {\n  return mapFinite(i, ea => toPrecision(ea, decimalPlaces))\n}\n\nexport function toFixed(i: Maybe<number>, decimals: number): Maybe<number> {\n  try {\n    return mapNumeric(i, ea => round(ea * 10 ** decimals) / 10 ** decimals)\n  } catch (err) {\n    return\n  }\n}\n\nexport function toPrecision(i: number, decimalPlaces: number): number {\n  if (i == null) return 0\n  // pow should be 1 for decimalPlaces = 0\n  const pow = Math.pow(10, decimalPlaces)\n  return round(i * pow) / pow\n}\n\nexport function sigFigs(i: number, digits: number): number {\n  if (i === 0 || digits === 0) {\n    return 0\n  }\n  const exp = digits - round(Math.ceil(Math.log10(Math.abs(i))))\n  const pow = Math.pow(10, Math.abs(exp))\n  // Prevent 120.000000001:\n  return exp < 0 ? round(i / pow) * pow : round(i * pow) / pow\n}\n\nexport function base2Ceil(i: number): number {\n  return Math.pow(2, Math.ceil(Math.log2(i)))\n}\n\nexport function base10Ceil(i: number): number {\n  return Math.pow(10, Math.ceil(Math.log10(i)))\n}\n\nexport function clamp(min: number, max: number, value: number): number {\n  if (min > max || !isNumber(min) || !isNumber(max))\n    throw new Error(`invalid clamp(${min}, ${max}, ${value})`)\n  if (!isNumber(value)) return round((min + max) / 2)\n  return value < min ? min : value > max ? max : value\n}\n\n/**\n * Accumulate the result of `f`, called `count` times. `f` receives a\n * zero-indexed argument.\n */\nexport function times<T>(count: number, f: (i: number) => T): T[] {\n  if (!gt0(count)) return []\n  const c = Math.round(count)\n  if (c <= 0) return []\n  return [...Array(c)].map((_, i) => f(i))\n}\n", "import { blankish } from \"./Blank\"\nimport { eql } from \"./Eql\"\nimport { isIterable } from \"./Iterable\"\nimport { stringify } from \"./JSON\"\nimport { isList, List } from \"./List\"\nimport { getOrSet } from \"./Map\"\nimport { Defined, defined, map } from \"./Maybe\"\nimport { Maybe, MaybeNull } from \"./MaybeTypes\"\nimport {\n  cmp,\n  Comparable,\n  isPrimitive,\n  isPrimitiveArray,\n  lt,\n  Primitivable,\n  Primitivables,\n  Primitive\n} from \"./Primitive\"\nimport { randomInt } from \"./Random\"\nimport { isString } from \"./String\"\nimport { ThunkOrT, tot } from \"./Thunk\"\nimport { toA } from \"./toA\"\nimport { toS } from \"./toS\"\n\n// Added isNotEmpty so I can make the arr is not null assertion:\nexport function isNotEmpty<L extends List<any>>(arr: Maybe<L>): arr is L {\n  return isList(arr) && arr.length > 0 && arr.some(ea => ea != null)\n}\n\nexport function notEmptyOr<L extends List<any>>(\n  arr: Maybe<L>,\n  defaultValue: ThunkOrT<L>\n): L {\n  return isNotEmpty(arr) ? arr : tot(defaultValue)\n}\n\nexport function isEmpty(arr: Maybe<List<any>>): arr is undefined {\n  return !isNotEmpty(arr)\n}\n\nexport function mapArray<T, U>(arr: Maybe<T[]>, f: (t: T[]) => U): Maybe<U> {\n  return Array.isArray(arr) ? f(arr) : undefined\n}\n\nexport function mapNotEmpty<L extends List<any>, R>(\n  arr: Maybe<L>,\n  f: (ea: L) => R\n): Maybe<R> {\n  return isNotEmpty(arr) ? f(arr) : undefined\n}\n\nexport function mapNotEmptyOr<L extends List<any>, R>(\n  arr: Maybe<L>,\n  f: (ea: L) => R,\n  defaultValue: ThunkOrT<R>\n): R {\n  return isNotEmpty(arr) ? f(arr) : tot(defaultValue)\n}\n\nfunction asPrim(\n  a: Primitive | Primitive[] | Primitivable | Primitivables\n): Primitive | Primitive[] {\n  return isPrimitive(a) || isPrimitiveArray(a) ? a : a.valueOf()\n}\n\n/**\n * Compacts and flattens ONE LEVEL\n */\nexport function flatten<T>(\n  arr: (MaybeNull<T> | MaybeNull<T>[])[],\n  result: T[] = []\n): T[] {\n  if (arr == null) return result\n  for (const ea of arr) {\n    if (ea != null) {\n      if (Array.isArray(ea)) {\n        // PERF: UNROLL\n        for (const ea1 of ea) {\n          if (ea1 != null) result.push(ea1)\n        }\n      } else {\n        result.push(ea)\n      }\n    }\n  }\n  return result\n}\n\nexport function sort<\n  T extends Primitive | Primitive[] | Primitivable | Primitivables\n>(arr: Maybe<T>[] | ReadonlyArray<Maybe<T>>): Defined<T>[] {\n  return sortByInPlace(compact(arr), asPrim)\n}\n\nexport function copyArrayTo<T>(source: T[], destination: T[]): T[] {\n  for (let i = 0; i < source.length; i++) {\n    destination[i] = source[i]\n  }\n  destination.length = source.length\n  return destination\n}\n\nexport function sortByInPlace<T>(arr: T[], f: (t: T) => Comparable): T[] {\n  return copyArrayTo(sortBy(arr, f), arr)\n}\n\nexport function sortUniqByInPlace<T>(arr: T[], f: (t: T) => Comparable): T[] {\n  const m = new Map<string, T>()\n  for (const ea of arr) {\n    getOrSet(m, stringify(f(ea)), () => ea)\n  }\n  return copyArrayTo(sortBy(m.values(), f), arr)\n}\n\nexport function sorted(arr: Primitivable[]): boolean {\n  return arr.every((ea, idx) => idx === 0 || ea > arr[idx - 1])\n}\n\nexport function sortedBy<T>(arr: T[], f: (t: T) => Primitive): boolean {\n  return arr.every((ea, idx) => idx === 0 || f(ea) > f(arr[idx - 1]))\n}\n\n/**\n * Returns a copy of arr, stable sorted by the given constraint. Note that false\n * < true, and that `f` may return an array for sort priorities, or undefined if\n * the item should be skipped from the returned result.\n *\n * Note: localeSort() thinks lower case should come before upper case (!!)\n */\nexport function sortBy<T, V extends Comparable>(\n  arr: Iterable<T> | T[],\n  f: (t: T, index: number) => Maybe<V>\n): T[] {\n  return toA(arr)\n    .filter(ea => ea != null)\n    .map((item, idx) => ({\n      item,\n      cmp: map(f(item, idx), ea => [ea, idx])\n    }))\n    .filter(ea => ea.cmp != null)\n    .sort((a, b) => cmp(a.cmp!, b.cmp!))\n    .map(ea => ea.item)\n}\n\nexport function deepSortBy<T, V extends Primitive | Primitive[]>(\n  arr: Iterable<T> | T[],\n  f: (t: T) => Maybe<V>\n): T[] {\n  return sortBy(arr, f).map(ea =>\n    isIterable(ea) ? deepSortBy(ea, f) : ea\n  ) as any // SITS typing\n}\n\nexport function arrayEql<T extends Primitive>(a: T[], b: T[]): boolean {\n  return (\n    a != null &&\n    b != null &&\n    a.length === b.length &&\n    a.every((ea, idx) => ea === b[idx])\n  )\n}\n\n/**\n * @return true if `prefix` == `haystack.slice(0, prefix.length)`.\n */\nexport function startsWith<T extends Primitive>(\n  haystack: T[],\n  prefix: T[]\n): boolean {\n  return arrayEql(haystack.slice(0, prefix.length), prefix)\n}\n\n/**\n * Retain all items from `arr` where the `keepIfTrue` returns `true`.\n * @return true if `arr` was changed.\n */\nexport function filterInPlace<T>(\n  arr: T[],\n  keepIfTrue: (item: T, index: number, ea: T[]) => boolean\n): T[] {\n  for (let i = 0; i < arr.length; ) {\n    if (keepIfTrue(arr[i], i, arr)) {\n      i++\n    } else {\n      arr.splice(i, 1)\n    }\n  }\n  return arr\n}\n\nexport function move<T>(arr: T[], fromIndex: number, toIndex: number): T[] {\n  if (\n    fromIndex === toIndex ||\n    fromIndex < 0 ||\n    toIndex < 0 ||\n    fromIndex >= arr.length ||\n    toIndex >= arr.length\n  ) {\n    return arr\n  }\n  const ea = arr[fromIndex]\n  arr.splice(fromIndex, 1)\n  arr.splice(toIndex, 0, ea)\n  return arr\n}\n\n// ES2016 polyfill that also supports Iterable\nexport function includes(\n  haystack: MaybeNull<any[] | Iterable<any>>,\n  needle: any\n): boolean {\n  if (haystack == null) return false\n  for (const ea of haystack) {\n    if (needle.valueOf() === ea.valueOf()) return true\n  }\n  return false\n}\n\nexport function indexOf<T>(\n  iter: Maybe<Iterable<T>>,\n  f: (t: T, index: number) => boolean\n): Maybe<number> {\n  if (iter == null) return\n  let index = 0\n  for (const ea of iter) {\n    if (f(ea, index)) return index\n    index++\n  }\n  return\n}\n\n/**\n * @returns true iff all `needles` are found in `haystack`\n */\nexport function includesAll(\n  haystack?: Primitive[],\n  needles?: Primitive[]\n): boolean {\n  if (haystack == null || needles == null) return false\n  return needles.every(needle => includes(haystack, needle))\n}\n\nexport function eqlUnordered(a: Primitive[], b: Primitive[]): boolean {\n  if (a == null || b == null || a.length !== b.length) return false\n  const a1 = sortBy(a, asPrim)\n  const b1 = sortBy(b, asPrim)\n  return a1.every((ea, idx) => ea === b1[idx])\n}\n\nexport function pushUniq<T>(arr: T[], ...items: T[]): T[] {\n  for (const item of items) {\n    if (!arr.some(ea => eql(ea, item))) {\n      arr.push(item)\n    }\n  }\n  return arr\n}\n\nexport function pushUniqBy<T>(\n  arr: T[],\n  items: T[],\n  valueOf: (t: T) => Comparable\n): T[] {\n  const vArr = arr.map(valueOf)\n  for (const item of items) {\n    const v = valueOf(item)\n    if (!vArr.includes(v)) {\n      arr.push(item)\n      vArr.push(v)\n    }\n  }\n  return arr\n}\n\nexport function insertAt<T>(arr: T[], index: number, ...items: T[]): T[] {\n  arr.splice(index, 0, ...items)\n  return arr\n}\n\n/**\n * Insert `item` into `arr` only if `item` is not in `arr` (according to `cmp`).\n *\n * Assumes `arr` is ascending-sorted.\n */\nexport function insertUniq<T>(\n  arr: T[],\n  item: T,\n  cmp_: (a: T, b: T) => number\n): T[] {\n  // verify the array is already in proper sort-order\n  for (let i = 0; i < arr.length - 1; i++) {\n    if (cmp_(arr[i], arr[i + 1]) > 0) {\n      throw new Error(\"badly sorted array: \" + arr)\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    const ea = arr[i]\n    const c = cmp_(ea, item)\n    if (c === 0) return arr\n    // if item is greater than ea, insert right before ea\n    if (c > 0) {\n      arr.splice(i, 0, item)\n      return arr\n    }\n  }\n  arr.push(item)\n  return arr\n}\n\nexport function compact<T>(iter: MaybeNull<Iterable<T>>): Defined<T>[] {\n  if (iter == null) return []\n  const arr = toA(iter)\n  return arr.every(defined) ? (arr as Defined<T>[]) : arr.filter(defined)\n}\n\nexport function compactBlankish<T>(iter: MaybeNull<Iterable<T>>): Defined<T>[] {\n  const arr = toA(iter).filter(ea => !blankish(toS(ea)))\n  return (isString(arr[0]) ? arr.map(ea => toS(ea).trim()) : arr) as any\n}\n\nexport function compactBlanks(arr: Maybe<any[]>): string[] {\n  // trim() to fix https://gitlab.com/mceachen/photostructure/issues/58\n  return toA(arr)\n    .map(ea => toS(ea).trim())\n    .filter(ea => ea.length > 0)\n}\n\nexport function uniq<T>(arr: Maybe<Maybe<T>[]>): Defined<T>[] {\n  return uniqBy(compact(arr), ea => stringify(ea))\n}\n\n/**\n * First-one-in-wins\n */\nexport function uniqBy<T, V extends Primitive>(\n  arr: Maybe<T>[],\n  f: (t: T) => Maybe<V> = ea => stringify(ea) as V\n): T[] {\n  if (isEmpty(arr)) return []\n  const m = new Map<V, T>()\n  for (const ea of arr) {\n    if (ea != null) {\n      const v = f(ea)\n      if (v != null) {\n        getOrSet(m, v, () => ea)\n      }\n    }\n  }\n  return [...m.values()]\n}\n\n/**\n * First-one-in-wins\n */\nexport function uniqBy2<T>(\n  arr: Maybe<T>[],\n  equals: (a: T, b: T) => boolean\n): T[] {\n  if (isEmpty(arr)) return []\n  const result: T[] = []\n  for (const a of arr) {\n    if (a != null && result.every(b => !equals(a, b))) {\n      result.push(a)\n    }\n  }\n  return result\n}\n\nexport function clear<T>(arr: T[]): T[] {\n  arr.length = 0\n  return arr\n}\n\n/**\n * Equivalent to filtering all items in an array to a new array and calling\n * length. This method avoids creating the intermediate array.\n *\n * @return the number of elements in `arr` that `predicate` returns `true`.\n */\nexport function count<T>(\n  arr: T[],\n  predicate: (t: T, idx: number) => boolean\n): number {\n  return arr.reduce((acc, ea, idx) => acc + (predicate(ea, idx) ? 1 : 0), 0)\n}\n\n/**\n * Equivalent to mapping all items in an array to a new number array and calling\n * Vector.sum(). This method avoids creating the intermediate array.\n *\n * @return the sum of elements of `f`-transmuted numbers from `arr`.\n */\nexport function sum<T>(\n  arr: T[],\n  f: (t: T, currentIndex: number) => number\n): number {\n  return arr.reduce((acc, ea, idx) => acc + f(ea, idx), 0)\n}\n\nexport function firstMatch(\n  re: RegExp,\n  arr: Maybe<string>[]\n): Maybe<RegExpExecArray> {\n  for (const s of compact(arr)) {\n    const m = re.exec(s)\n    if (m != null) return m\n  }\n  return\n}\n\nexport function commonPrefixLength<T extends Primitive>(\n  a: Maybe<T[] | string>,\n  b: Maybe<T[] | string>\n): number {\n  if (a == null || b == null) return 0\n  if (a === b) return a.length\n  if (typeof a === \"string\") a = (a.split(\"\") as any) as T[]\n  if (typeof b === \"string\") b = (b.split(\"\") as any) as T[]\n  if (arrayEql(a, b)) return a.length\n  let length = 0\n  while (a[length] === b[length]) length++\n  return length\n}\n\n/**\n * Make random perturbations to `array` to minimize the given expense function\n */\nexport function anneal<T>({\n  array,\n  expense,\n  allowedDelta\n}: {\n  array: T[]\n  expense: (arr: T[], fromIndex: number, toIndex: number) => Comparable\n  allowedDelta: number\n}): T[] {\n  const delta = Math.round(allowedDelta)\n  if (delta < 2) return array\n  for (let mid = 0; mid < array.length - 1; mid++) {\n    const newPos = randomInt(\n      Math.max(0, mid - delta),\n      Math.min(array.length, mid + delta),\n      [mid]\n    )\n    if (newPos == null) continue\n    // the range is either [mid - 1, newPos + 1] or [newPos - 1, mid + 1]\n    const i = Math.max(0, Math.min(newPos, mid) - 1)\n    const j = Math.min(array.length, Math.max(newPos, mid) + 1)\n    const currentExpense = expense(array, i, j)\n    move(array, mid, newPos)\n    const newExpense = expense(array, i, j)\n    // undo the move if newExpense isn't better:\n    if (lt(currentExpense, newExpense)) {\n      move(array, newPos, mid)\n    }\n  }\n  return array\n}\n\n/**\n * @param from inclusive\n * @param to exclusive\n * @param f\n */\nexport function range<T = number>(\n  from: number,\n  to: number,\n  f: (i: number) => T = ea => ea as any\n): T[] {\n  return stepRange(from, to, 1, f)\n}\n\n/**\n * @param to return an array up to but not including `to`\n * @see https://docs.python.org/2/library/functions.html#range\n */\nexport function stepRange<T = number>(\n  from: number,\n  to: number,\n  step: number = 1,\n  f: (i: number) => T = ea => ea as any\n): T[] {\n  const r: T[] = []\n  if (from < to) {\n    for (let i = from; i < to; i += step) {\n      r.push(f(i))\n    }\n  } else {\n    for (let i = from; i > to; i -= step) {\n      r.push(f(i))\n    }\n  }\n  return r\n}\n\n/**\n * `minuend - subtrahend`, or the elements in minuend that are not in\n * subtrahend. Only works with Primitives.\n *\n * @param {T[]} minuend (haystack)\n * @param {T[]} subtrahend (needles)\n * @returns {T[]} values in `minuend` that, according to `.valueOf()`, are not\n * in `subtrahend`. Neither arg is mutated.\n */\nexport function diff<T extends Primitive>(minuend: T[], subtrahend: T[]): T[] {\n  const s = new Set(subtrahend)\n  return minuend.filter(ea => !s.has(ea))\n}\n\nexport function last<T>(arr: Maybe<T[]>): Maybe<T> {\n  return arr != null ? arr[arr.length - 1] : undefined\n}\n\nexport function commaList(arr: string[], finalJoin = \"or\"): string {\n  if (arr.length <= 1) return arr.join(\"\")\n  if (arr.length === 2) return arr.join(\" \" + finalJoin + \" \")\n  return (\n    arr.slice(0, -1).join(\", \") + \", \" + finalJoin + \" \" + arr[arr.length - 1]\n  )\n}\n", "import { flatten } from \"./Array\"\nimport { toS } from \"./toS\"\n\nexport function isString(obj: any): obj is string {\n  return typeof obj === \"string\"\n}\n\nexport function ensurePrefix(s: string, prefix: string): string {\n  s = toS(s)\n  prefix = toS(prefix)\n  return s.startsWith(prefix) ? s : prefix + s\n}\n\nexport function ensureSuffix(s: string, suffix: string): string {\n  s = toS(s)\n  suffix = toS(suffix)\n  return s.endsWith(suffix) ? s : s + suffix\n}\n\nexport function ellipsize(a: any, maxLen: number = 80): string {\n  if (a == null) {\n    return \"\"\n  }\n  const s = toS(a)\n  return s.length <= maxLen ? s : s.slice(0, maxLen - 1) + \"\u2026\"\n}\n\nexport const newlineRe = /\\r?\\n/gm\n\n/**\n * Returns the nearest occurrence of a substring to the left of a given position in the string.\n * @param haystack The string to search against.\n * @param needle The substring to search for.\n * @param position The index at which to begin searching. If omitted, the search begins at the end of the string.\n */\nexport function leftIndexOf(\n  haystack: string,\n  needle: string,\n  position?: number\n) {\n  if (position == null) position = haystack.length\n  for (let i = position; i >= 0; i--) {\n    if (haystack.substr(i).startsWith(needle)) return i\n  }\n  return -1\n}\n\nexport function wrap(\n  s: string,\n  opts = { maxLineLen: 75, prefix: \"\" }\n): string[] {\n  if (s.includes(\"\\n\")) {\n    return flatten(s.split(newlineRe).map(ea => wrap(ea, opts)))\n  }\n  s = ensurePrefix(toS(s), opts.prefix).trim()\n  if (s.length <= opts.maxLineLen) {\n    return [s]\n  }\n  const leftSliceAt = leftIndexOf(s, \" \", opts.maxLineLen)\n\n  if (leftSliceAt > opts.prefix.length) {\n    return [s.slice(0, leftSliceAt), ...wrap(s.slice(leftSliceAt + 1), opts)]\n  } else {\n    const rightSliceAt = s.indexOf(\" \", opts.prefix.length + 1)\n    if (rightSliceAt > 0 && rightSliceAt < s.length - 1) {\n      return [\n        s.slice(0, rightSliceAt),\n        ...wrap(s.slice(rightSliceAt + 1), opts)\n      ]\n    } else {\n      return [s]\n    }\n  }\n\n  // }\n\n  // const index = s\n  //   .slice(0, opts.maxLineLen + 1)\n  //   .replace(/[\\s-]/g, \" \")\n  //   .lastIndexOf(\" \")\n  // const sliceAt =\n  //   index <= 1 ? opts.maxLineLen - (opts.prefix.length + 2) : index\n  // return [s.slice(0, sliceAt + 1).trim(), ...wrap(s.slice(sliceAt + 1), opts)]\n}\n\nexport function eqlStrings(a: string, b: string): boolean {\n  return a == null || b == null ? false : a.normalize() === b.normalize()\n}\n\nexport function replaceAll(\n  s: string,\n  searchValue: string | RegExp,\n  replaceValue: string\n): string {\n  if (searchValue === \"\") return s\n  return s.split(searchValue).join(replaceValue)\n}\n\nexport function compressWhitespace(...s: string[]): string {\n  return s.join(\" \").replace(/\\s+/g, \" \").trim()\n}\n", "export const version = \"1.0.0-alpha.1\";\nexport const release = \"1.0.0-alpha.1+20210314162034\";\nexport const gitSha = \"35109a3849a633155ab4c6b37c09648c754e6669\";\nexport const gitDate = new Date(1615764034000);\nexport default { version, release, gitSha, gitDate };\n"],
  "mappings": ";;;;ogBAAA,MAAiC,wBACjC,EAAqB,sBCArB,MAAuB,sBCGhB,WAAa,EAAyB,CAE3C,MAAO,IAAK,KACR,GACA,MAAO,IAAM,SACb,EACA,MAAM,QAAQ,GACd,EAAE,IAAI,GAAK,KAAK,KAChB,EAAE,WCPD,GAAK,GAAL,UAAK,EAAL,CACL,qBACA,6BACA,uBACA,uBACA,qBACA,2BACA,2BACA,2BACA,2BATU,WC6EZ,GAAU,GAAV,UAAU,EAAV,CACS,AAAM,YAAY,GACZ,UAAU,GACV,MAAM,IAAG,GACT,SAAS,IAAM,GAC5B,GAAM,GAAO,IAAM,EACZ,AAAM,MAAM,EACN,UAAU,EACV,SAAS,EACT,UAAU,EACV,YAAY,AAAI,GAAkB,IAClC,SAAS,AAAI,GAAiC,EAAI,KAClD,OAAO,EACP,OAAO,EACP,OAAO,IAdZ,WAiBH,GAAM,GAAiB,EAEvB,OAAgC,CAIrC,YAA6B,EAAM,CAAN,SAHpB,eAAY,GACZ,aAAU,GAInB,KAAS,CACP,MAAO,MAAK,EAGd,OAAO,EAA+B,CACpC,MAAO,GAAE,KAAK,GAGhB,IAAO,EAAwB,CAC7B,MAAO,IAAI,GAAK,EAAE,KAAK,IAGzB,QAAW,EAA4C,CACrD,GAAM,GAAI,EAAE,KAAK,GACjB,MAAO,GAAM,GAAK,EAAI,EAAI,GAG5B,OAAO,EAA8B,CACnC,MAAO,GAAI,EAAE,KAAK,GAAK,KAAK,EAAI,QAGlC,QAAQ,EAAyB,CAC/B,SAAE,KAAK,GACA,KAGT,WAAe,CACb,MAAO,MAAK,EAGd,QAAiB,CACf,MAAO,MAGT,KAAW,EAAgB,EAAwC,CACjE,MAAO,GAAI,GAAG,QAAQ,GAAM,EAAE,KAAK,EAAG,IAGxC,KACE,EACA,EACA,EACQ,CACR,MAAO,GAAI,GAAG,QAAQ,GAAM,EAAI,GAAG,QAAQ,GAAM,EAAE,KAAK,EAAG,EAAI,KAGjE,KACE,EACA,EACA,EACA,EACQ,CACR,MAAO,GAAI,GAAG,QAAQ,GACpB,EAAI,GAAG,QAAQ,GAAM,EAAI,GAAG,QAAQ,GAAM,EAAE,KAAK,EAAG,EAAI,EAAI,QAK3D,WAAkB,EAA6B,CACpD,MAAO,aAAa,IAAQ,IAAM,EAM7B,WAAgB,EAAwB,CAC7C,MAAO,GAAM,GAAK,EAAI,GAAK,KAAO,GAAI,GAAK,GAAK,ECrK3C,WAAkB,EAAqB,CAC5C,MAAO,OAAO,IAAM,UAAY,CAAC,MAAM,IAAM,SAAS,GAOxD,GAAM,GAAe,AAAC,GAA6C,CACjE,EACA,IACG,EAAS,IAAQ,EAAS,IAAQ,EAAE,EAAK,GAEjC,GAAK,EAAa,CAAC,EAAG,IAAM,EAAI,GAChC,GAAM,EAAa,CAAC,EAAG,IAAM,GAAK,GAClC,GAAK,EAAa,CAAC,EAAG,IAAM,EAAI,GAChC,GAAM,EAAa,CAAC,EAAG,IAAM,GAAK,GC4CxC,WACL,EACA,EAAc,GACT,CACL,GAAI,GAAO,KAAM,MAAO,GACxB,OAAW,KAAM,GACf,GAAI,GAAM,KACR,GAAI,MAAM,QAAQ,GAEhB,OAAW,KAAO,GAChB,AAAI,GAAO,MAAM,EAAO,KAAK,OAG/B,GAAO,KAAK,GAIlB,MAAO,GC9EF,WAAsB,EAAW,EAAwB,CAC9D,SAAI,EAAI,GACR,EAAS,EAAI,GACN,EAAE,WAAW,GAAU,EAAI,EAAS,EAiBtC,GAAM,GAAY,UAQlB,WACL,EACA,EACA,EACA,CACA,AAAI,GAAY,MAAM,GAAW,EAAS,QAC1C,OAAS,GAAI,EAAU,GAAK,EAAG,IAC7B,GAAI,EAAS,OAAO,GAAG,WAAW,GAAS,MAAO,GAEpD,MAAO,GAGF,WACL,EACA,EAAO,CAAE,WAAY,GAAI,OAAQ,IACvB,CACV,GAAI,EAAE,SAAS;AAAA,GACb,MAAO,GAAQ,EAAE,MAAM,GAAW,IAAI,GAAM,EAAK,EAAI,KAGvD,GADA,EAAI,EAAa,EAAI,GAAI,EAAK,QAAQ,OAClC,EAAE,QAAU,EAAK,WACnB,MAAO,CAAC,GAEV,GAAM,GAAc,EAAY,EAAG,IAAK,EAAK,YAE7C,GAAI,EAAc,EAAK,OAAO,OAC5B,MAAO,CAAC,EAAE,MAAM,EAAG,GAAc,GAAG,EAAK,EAAE,MAAM,EAAc,GAAI,IAC9D,CACL,GAAM,GAAe,EAAE,QAAQ,IAAK,EAAK,OAAO,OAAS,GACzD,MAAI,GAAe,GAAK,EAAe,EAAE,OAAS,EACzC,CACL,EAAE,MAAM,EAAG,GACX,GAAG,EAAK,EAAE,MAAM,EAAe,GAAI,IAG9B,CAAC,INlEd,GAAM,GAAO,GAAI,QAAO,cAEX,EAAoB;AAAA;AAAA,sBAEd;AAAA;AAAA,qHAIN,EAAU,CACrB,KACE,iFACF,KAAM,6DACN,KAAM,+BACN,OAAQ,iEACR,QACE,yFACF,IAAK,+DACL,KACE,qFACF,YACE,iFAGG,WAAmB,EAAqB,CAC7C,MAAO,GAAE,GAAG,SAAU,IAAM,CAC1B,QAAQ,IACN;AAAA,EACE,EAAK,EAAmB,CACtB,WAAY,SAAO,SAAW,GAC9B,OAAQ,KACP,KAAK;AAAA,GACR;KOnCD,GAAM,GAAU,gBAGhB,GAAM,IAAU,GAAI,MAAK,cREhC,UAAQ,QAAQ,GAEhB,UAAQ,YACN,4EAGF,EAAU,WACP,QAAQ,OAAQ,EAAQ,KAAO,aAAc,CAC5C,UAAW,GACX,eAAgB,gBAEjB,QAAQ,OAAQ,EAAQ,KAAM,CAC7B,eAAgB,gBAEjB,QAAQ,OAAQ,EAAQ,KAAM,CAC7B,eAAgB,gBAEjB,QAAQ,SAAU,EAAQ,OAAQ,CACjC,eAAgB,kBAEjB,QAAQ,UAAW,EAAQ,QAAS,CACnC,eAAgB,mBAEjB,QAAQ,MAAO,EAAQ,IAAK,CAC3B,eAAgB,eAEjB,QAAQ,OAAQ,EAAQ,KAAM,CAC7B,eAAgB,gBAEjB,QAAQ,YAAa,EAAQ,aAAc,CAC1C,eAAgB,qBAEjB,MAAM",
  "names": []
}
